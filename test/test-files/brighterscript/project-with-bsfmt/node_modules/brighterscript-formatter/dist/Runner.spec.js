"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fsExtra = require("fs-extra");
const brighterscript_1 = require("brighterscript");
const Runner_1 = require("./Runner");
const chai_1 = require("chai");
const sinon_1 = require("sinon");
let cwd = process.cwd();
let rootDir = brighterscript_1.standardizePath `${process.cwd()}/testRootDir`;
let baseOptions;
describe('Runner', () => {
    let sinon;
    beforeEach(() => {
        sinon = sinon_1.createSandbox();
    });
    afterEach(() => {
        sinon.restore();
        process.chdir(cwd);
    });
    let consoleOutput = '';
    beforeEach(() => {
        fsExtra.ensureDirSync(rootDir);
        fsExtra.emptyDirSync(rootDir);
        baseOptions = {
            cwd: rootDir,
            files: []
        };
        sinon.stub(console, 'log').callsFake((...args) => {
            if (consoleOutput !== '') {
                consoleOutput += '\n';
            }
            //simple console output string. Probably won't handle every situation, but good enough for our tests
            consoleOutput += args.join(' ');
        });
    });
    afterEach(() => {
        fsExtra.emptyDirSync(rootDir);
    });
    it('skips directories', async () => {
        fsExtra.mkdirSync(brighterscript_1.standardizePath `${rootDir}/source`);
        fsExtra.writeFileSync(brighterscript_1.standardizePath `${rootDir}/source/main.brs`, ``);
        const runner = new Runner_1.Runner();
        const spy = sinon.spy(runner, 'getFilePaths');
        await runner.run({
            cwd: rootDir,
            files: [
                '**/*'
            ]
        });
        chai_1.expect(spy.callCount).to.equal(1);
        chai_1.expect(spy.getCalls()[0].returnValue.map(x => brighterscript_1.standardizePath(x))).to.eql([
            brighterscript_1.standardizePath `${rootDir}/source/main.brs`
        ]);
    });
    describe('check', () => {
        it('catches unformatted files', async () => {
            let filePath = brighterscript_1.standardizePath `${rootDir}/lib.brs`;
            let originalContents = `sub main()\nreturn 1\nend sub`;
            fsExtra.writeFileSync(filePath, originalContents);
            let errorMessage = '';
            try {
                await run({
                    check: true,
                    files: [
                        brighterscript_1.standardizePath `${rootDir}/lib.brs`
                    ]
                });
            }
            catch (e) {
                errorMessage = e.message;
            }
            chai_1.expect(errorMessage).to.include('Formatting issues found in the above file(s)');
        });
        it('passes for perfectly formatted files', async () => {
            let filePath = brighterscript_1.standardizePath `${rootDir}/lib.brs`;
            let originalContents = `sub main()\n    return 1\nend sub`;
            fsExtra.writeFileSync(filePath, originalContents);
            await run({
                check: true,
                files: [
                    brighterscript_1.standardizePath `${rootDir}/lib.brs`
                ]
            });
            chai_1.expect(consoleOutput).to.include('All matched files are formatted properly!');
        });
        it('does not change the file on disk unless configured to do so', async () => {
            let filePath = brighterscript_1.standardizePath `${rootDir}/lib.brs`;
            let originalContents = `sub main()\nreturn1\nend sub`;
            fsExtra.writeFileSync(filePath, originalContents);
            try {
                await run({
                    check: true,
                    write: false,
                    files: [
                        brighterscript_1.standardizePath `${rootDir}/lib.brs`
                    ]
                });
            }
            catch (e) {
            }
            //the check command should not overwrite the file
            chai_1.expect(fsExtra.readFileSync(filePath).toString()).to.equal(originalContents);
        });
    });
    describe('write', () => {
        it('overwerites the file when the --write flag is provided', async () => {
            let filePath = brighterscript_1.standardizePath `${rootDir}/lib.brs`;
            let originalContents = `sub main()\nreturn 1\nend sub`;
            fsExtra.writeFileSync(filePath, originalContents);
            await run({
                write: true,
                files: [
                    brighterscript_1.standardizePath `${rootDir}/lib.brs`
                ]
            });
            //the check command should not overwrite the file
            chai_1.expect(fsExtra.readFileSync(filePath).toString()).to.equal(`sub main()\n    return 1\nend sub`);
        });
    });
    describe('normalizeArgs', () => {
        it('applies default values', () => {
            let runner = new Runner_1.Runner();
            chai_1.expect(runner.normalizeArgs({})).to.deep.equal({
                files: [],
                cwd: process.cwd()
            });
        });
    });
    describe('bsfmt.json', () => {
        it('gets loaded from default cwd during run', async () => {
            process.chdir(rootDir);
            fsExtra.writeFileSync(brighterscript_1.standardizePath `${rootDir}/bsfmt.json`, JSON.stringify({
                formatIndent: false,
                keywordCaseOverride: {
                    'not-real-key': 'lower'
                }
            }));
            //delete cwd so the runner uses the one from process
            delete baseOptions.cwd;
            let runner = await run();
            let options = runner.formatter.formattingOptions;
            chai_1.expect(options === null || options === void 0 ? void 0 : options.formatIndent).to.be.false;
            chai_1.expect(options === null || options === void 0 ? void 0 : options.keywordCaseOverride).to.have.key('not-real-key');
        });
        it('gets loaded from parameter cwd during run', async () => {
            fsExtra.ensureDirSync(brighterscript_1.standardizePath `${rootDir}/testFolder`);
            fsExtra.writeFileSync(brighterscript_1.standardizePath `${rootDir}/testFolder/bsfmt.json`, JSON.stringify({
                formatIndent: false,
                keywordCaseOverride: {
                    'not-real-key': 'lower'
                }
            }));
            let runner = await run({
                cwd: brighterscript_1.standardizePath `${rootDir}/testFolder`,
                files: []
            });
            let options = runner.formatter.formattingOptions;
            chai_1.expect(options === null || options === void 0 ? void 0 : options.formatIndent).to.be.false;
            chai_1.expect(options === null || options === void 0 ? void 0 : options.keywordCaseOverride).to.have.key('not-real-key');
        });
        it('throws exception when parsing invalid json', async () => {
            fsExtra.writeFileSync(brighterscript_1.standardizePath `${rootDir}/bsfmt.json`, `{asdf`);
            let threw;
            try {
                await run();
                threw = false;
            }
            catch (e) {
                threw = true;
            }
            chai_1.expect(threw).to.be.true;
        });
        it('throws exception when custom bsfmt file is provided but does not exist', async () => {
            let threw;
            try {
                await run({
                    bsfmtPath: './does-not-exist.json'
                });
                threw = false;
            }
            catch (e) {
                threw = true;
            }
            chai_1.expect(threw).to.be.true;
        });
    });
    describe('getBsfmtOptions', () => {
        it('does not load bsfmt from file when noBsfmt is provided', () => {
            chai_1.expect(new Runner_1.Runner().getBsfmtOptions(Object.assign(Object.assign({}, baseOptions), { noBsfmt: true }))).to.be.null;
        });
    });
    async function run(options) {
        const runner = new Runner_1.Runner();
        await runner.run(Object.assign(Object.assign({}, baseOptions), (options !== null && options !== void 0 ? options : {})));
        return runner;
    }
});
//# sourceMappingURL=Runner.spec.js.map