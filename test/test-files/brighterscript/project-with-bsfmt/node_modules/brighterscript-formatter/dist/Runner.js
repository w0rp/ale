"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const globAll = require("glob-all");
const fsExtra = require("fs-extra");
const Formatter_1 = require("./Formatter");
const path = require("path");
const jsonc_parser_1 = require("jsonc-parser");
/**
 * Runs the formatter for an entire project.
 */
class Runner {
    async run(runnerOptions) {
        var _a;
        let args = this.normalizeArgs(Object.assign(Object.assign({}, (_a = this.getBsfmtOptions(runnerOptions)) !== null && _a !== void 0 ? _a : {}), runnerOptions));
        const filePaths = this.getFilePaths(args.files, args.cwd);
        this.formatter = new Formatter_1.Formatter(args);
        //print the list of unformatted files if found (and enabled)
        if (args.check) {
            console.log('Checking formatting...');
        }
        let unformattedFiles = [];
        await Promise.all(filePaths.map(async (filePath) => {
            let text = (await fsExtra.readFile(filePath)).toString();
            let formattedText = this.formatter.format(text);
            //overwrite the file with the formatted version
            if (args.write) {
                await fsExtra.writeFile(filePath, formattedText);
            }
            else if (!args.check) {
                //print the file to the console (only if the user didnt specify --write and didnt specify --check
                //This is what prettier's CLI does, so it makes sense. You can leverage this when running single files at a time
                //to pipe to a separate file
                console.log(formattedText);
            }
            //if configured, compare formatted file to unformatted file
            //TODO find a more efficient way to do this other than string comparisons (large files could cause performance issues)
            if (args.check && text !== formattedText) {
                unformattedFiles.push(filePath);
            }
        }));
        //print the list of unformatted files if found (and enabled)
        if (args.check) {
            if (unformattedFiles.length > 0) {
                for (let filePath of unformattedFiles) {
                    console.log(filePath);
                }
                throw new Error('Formatting issues found in the above file(s)');
            }
            else {
                console.log('All matched files are formatted properly!');
            }
        }
    }
    /**
     * Get the list of file paths for this run.
     */
    getFilePaths(files, cwd) {
        const filePaths = globAll.sync(files, {
            cwd: cwd,
            absolute: true,
            //skip all directories
            nodir: true
        });
        return filePaths;
    }
    /**
     * Load the options from bsfmt.json
     * @throws whenever a custom bsfmt path is provided and does not exist
     * @returns {FormattingOptions} when found, or null if not found
     */
    getBsfmtOptions(runnerOptions) {
        var _a;
        //if options says not to load bsfmt, then return an empty object
        if (runnerOptions.noBsfmt) {
            return null;
        }
        const cwd = (_a = runnerOptions.cwd) !== null && _a !== void 0 ? _a : process.cwd();
        const bsfmtPath = runnerOptions.bsfmtPath
            //use custom path
            ? path.resolve(cwd, runnerOptions.bsfmtPath)
            //use default path
            : path.resolve(cwd, 'bsfmt.json');
        const configFileExists = fsExtra.pathExistsSync(bsfmtPath);
        //if using custom bsfmt.json path, then throw error if it doesn't exist.
        if (runnerOptions.bsfmtPath && configFileExists === false) {
            throw new Error(`bsfmt file does not exist at "${bsfmtPath}"`);
            //using the default bsfmt.json path, and it doesn't exist, so just return an empty object
        }
        else if (configFileExists === false) {
            return null;
        }
        const contents = fsExtra.readFileSync(bsfmtPath);
        const parseErrors = [];
        const config = jsonc_parser_1.parse(contents.toString(), parseErrors);
        //if there were errors parsing the bsfmt.json, fail now
        if (parseErrors.length > 0) {
            throw new Error(`Error parsing "${bsfmtPath}": ${jsonc_parser_1.printParseErrorCode(parseErrors[0].error)}`);
        }
        return config;
    }
    normalizeArgs(args) {
        var _a;
        args.files = Array.isArray(args.files) ? args.files : [];
        args.cwd = (_a = args.cwd) !== null && _a !== void 0 ? _a : process.cwd();
        return args;
    }
}
exports.Runner = Runner;
//# sourceMappingURL=Runner.js.map