import { Token, TokenKind } from 'brighterscript';
import { FormattingOptions } from './FormattingOptions';
export declare class Formatter {
    /**
     * Construct a new formatter. The options provided here will be normalized exactly once,
     * and stored on the formatter instance.
     */
    constructor(formattingOptions?: FormattingOptions);
    /**
     * The formatting options provided in the constructor. Can be undefined if none were provided
     */
    formattingOptions?: FormattingOptions;
    /**
     * The default number of spaces when indenting with spaces
     */
    static DEFAULT_INDENT_SPACE_COUNT: number;
    /**
     * Format the given input.
     * @param inputText the text to format
     * @param formattingOptions options specifying formatting preferences
     */
    format(inputText: string, formattingOptions?: FormattingOptions): string;
    /**
     * Format the given input and return the formatted text as well as a source map
     * @param inputText the text to format
     * @param sourcePath the path to the file being formatted (used for sourcemap generator)
     * @param formattingOptions options specifying formatting preferences
     * @returns an object with property `code` holding the formatted code, and `map` holding the source map.
     */
    formatWithSourceMap(inputText: string, sourcePath: string, formattingOptions?: FormattingOptions): import("source-map").CodeWithSourceMap;
    /**
     * Format the given input.
     * @param inputText the text to format
     * @param formattingOptions options specifying formatting preferences
     */
    getFormattedTokens(inputText: string, formattingOptions?: FormattingOptions): Token[];
    /**
     * Determines if the current index is the start of a single-line array or AA.
     * Walks forward until we find the equal number of open and close curlies/squares, or a newline
     */
    private isStartofSingleLineArrayOrAA;
    /**
     * Find the matching closing token for open square or open curly
     */
    private getClosingToken;
    /**
     * Given a kind like `}` or `]`, walk backwards until we find its match
     */
    private getOpeningToken;
    private isMatchingDoubleArrayOrArrayCurly;
    /**
     * Standardize multi-line objects and arrays by inserting newlines after leading and before trailing.
     */
    private formatMultiLineObjectsAndArrays;
    private dedupeWhitespace;
    private formatCompositeKeywords;
    private getCompositeKeywordParts;
    /**
     * Determine if the token is a type keyword (meaing preceeded by `as` token)
     * @param token
     */
    private isType;
    private formatKeywordCase;
    private formatIndentation;
    /**
     * Force all Whitespace between tokens to be exactly 1 space wide
     */
    private formatInteriorWhitespace;
    /**
     * Ensure exactly 1 or 0 spaces between all literal associative array keys and the colon after it
     */
    private formatSpaceBetweenAssociativeArrayLiteralKeyAndColon;
    /**
     * Format spacing between various tokens that are more specific than `formatInteriorWhitespace`
     */
    private formatTokenSpacing;
    /**
     * Remove Whitespace tokens backwards until a non-Whitespace token is encountered
     * @param startIndex the index of the non-Whitespace token to start with. This function will start iterating at `startIndex - 1`
     */
    private removeWhitespaceTokensBackwards;
    /**
     * Remove Whitespace until the next non-Whitespace character.
     * This operates on the array itself
     */
    private removeWhitespace;
    /**
     * Determine if the current token appears to be the negative sign for a numeric leteral
     */
    private looksLikeNegativeNumericLiteral;
    /**
     * Get the first token after the index that is NOT Whitespace. Returns undefined if stopAtNewLine===true and found a newline,
     * or if we found the EOF token
     */
    private getNextNonWhitespaceToken;
    /**
     * Get the first token before the index that is NOT Whitespace
     */
    private getPreviousNonWhitespaceToken;
    /**
     * Remove all trailing Whitespace
     */
    private formatTrailingWhiteSpace;
    /**
     * Get the tokens for the whole line starting at the given index (including the Newline or EOF token at the end)
     * @param startIndex
     * @param tokens
     */
    private getLineTokens;
    /**
     * Convert the character at the specified index to upper case
     */
    upperCaseLetter(text: string, index: number): string;
}
export declare const CompositeKeywords: TokenKind[];
export declare const BasicKeywords: TokenKind[];
export declare let Keywords: TokenKind[];
/**
 * The list of tokens that should cause an indent
 */
export declare let IndentSpacerTokenKinds: TokenKind[];
/**
 * The list of tokens that should cause an outdent
 */
export declare let OutdentSpacerTokenKinds: TokenKind[];
/**
 * The list of tokens that should cause an outdent followed by an immediate indent
 */
export declare let InterumSpacingTokenKinds: TokenKind[];
export declare let CallableKeywordTokenKinds: TokenKind[];
export declare let NumericLiteralTokenKinds: TokenKind[];
/**
 * Anytime one of these tokens are found before a minus sign,
 * we can safely assume the minus sign is associated with a negative numeric literal
 */
export declare let TokensBeforeNegativeNumericLiteral: TokenKind[];
export declare const TypeTokens: TokenKind[];
export declare const CompositeKeywordStartingWords: string[];
export declare const AllowedClassIdentifierKinds: TokenKind[];
