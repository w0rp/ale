"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var _fsExtra = require("fs-extra");
var request = require("request");
var archiver = require("archiver");
var dateformat = require("dateformat");
var errors = require("./Errors");
var minimatch = require("minimatch");
var glob = require("glob");
var xml2js = require("xml2js");
var util_1 = require("util");
var jsonc_parser_1 = require("jsonc-parser");
var globAsync = util_1.promisify(glob);
var util_2 = require("./util");
var RokuDeploy = /** @class */ (function () {
    function RokuDeploy() {
        //store the import on the class to make testing easier
        this.request = request;
        this.fsExtra = _fsExtra;
    }
    /**
     * Copies all of the referenced files to the staging folder
     * @param options
     */
    RokuDeploy.prototype.prepublishToStaging = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var files;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        files = this.normalizeFilesArray(options.files);
                        //clean the staging directory
                        return [4 /*yield*/, this.fsExtra.remove(options.stagingFolderPath)];
                    case 1:
                        //clean the staging directory
                        _a.sent();
                        //make sure the staging folder exists
                        return [4 /*yield*/, this.fsExtra.ensureDir(options.stagingFolderPath)];
                    case 2:
                        //make sure the staging folder exists
                        _a.sent();
                        return [4 /*yield*/, this.copyToStaging(files, options.stagingFolderPath, options.rootDir)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, options.stagingFolderPath];
                }
            });
        });
    };
    /**
     * Given an array of `FilesType`, normalize each of them into a standard {src;dest} object.
     * Each entry in the array or inner `src` array will be extracted out into its own object.
     * This makes it easier to reason about later on in the process.
     * @param files
     */
    RokuDeploy.prototype.normalizeFilesArray = function (files) {
        var result = [];
        for (var i = 0; i < files.length; i++) {
            var entry = files[i];
            //skip falsey and blank entries
            if (!entry) {
                continue;
                //string entries
            }
            else if (typeof entry === 'string') {
                result.push(entry);
                //objects with src: (string | string[])
            }
            else if ('src' in entry) {
                //validate dest
                if (entry.dest !== undefined && entry.dest !== null && typeof entry.dest !== 'string') {
                    throw new Error("Invalid type for \"dest\" at index " + i + " of files array");
                }
                //objects with src: string
                if (typeof entry.src === 'string') {
                    result.push({
                        src: util_2.util.standardizePath(entry.src),
                        dest: util_2.util.standardizePath(entry.dest)
                    });
                    //objects with src:string[]
                }
                else if ('src' in entry && Array.isArray(entry.src)) {
                    //create a distinct entry for each item in the src array
                    for (var _i = 0, _a = entry.src; _i < _a.length; _i++) {
                        var srcEntry = _a[_i];
                        result.push({
                            src: util_2.util.standardizePath(srcEntry),
                            dest: util_2.util.standardizePath(entry.dest)
                        });
                    }
                }
                else {
                    throw new Error("Invalid type for \"src\" at index " + i + " of files array");
                }
            }
            else {
                throw new Error("Invalid entry at index " + i + " in files array");
            }
        }
        return result;
    };
    /**
     * Given an already-populated staging folder, create a zip archive of it and copy it to the output folder
     * @param options
     */
    RokuDeploy.prototype.zipPackage = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var zipFilePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        //make sure the output folder exists
                        return [4 /*yield*/, this.fsExtra.ensureDir(options.outDir)];
                    case 1:
                        //make sure the output folder exists
                        _a.sent();
                        zipFilePath = this.getOutputZipFilePath(options);
                        return [4 /*yield*/, util_2.util.fileExistsCaseInsensitive(options.stagingFolderPath + "/manifest")];
                    case 2:
                        //ensure the manifest file exists in the staging folder
                        if (!(_a.sent())) {
                            throw new Error("Cannot zip package: missing manifest file in \"" + options.stagingFolderPath + "\"");
                        }
                        //create a zip of the staging folder
                        return [4 /*yield*/, this.zipFolder(options.stagingFolderPath, zipFilePath)];
                    case 3:
                        //create a zip of the staging folder
                        _a.sent();
                        if (!(options.retainStagingFolder !== true)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.fsExtra.remove(options.stagingFolderPath)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a zip folder containing all of the specified roku project files.
     * @param options
     */
    RokuDeploy.prototype.createPackage = function (options, beforeZipCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var manifestPath, parsedManifest, timestamp, info;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        return [4 /*yield*/, this.prepublishToStaging(options)];
                    case 1:
                        _a.sent();
                        manifestPath = util_2.util.standardizePath(options.stagingFolderPath + "/manifest");
                        return [4 /*yield*/, this.parseManifest(manifestPath)];
                    case 2:
                        parsedManifest = _a.sent();
                        if (!options.incrementBuildNumber) return [3 /*break*/, 4];
                        timestamp = dateformat(new Date(), 'yymmddHHMM');
                        parsedManifest.build_version = timestamp; //eslint-disable-line camelcase
                        return [4 /*yield*/, this.fsExtra.writeFile(manifestPath, this.stringifyManifest(parsedManifest))];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!beforeZipCallback) return [3 /*break*/, 6];
                        info = {
                            manifestData: parsedManifest,
                            stagingFolderPath: options.stagingFolderPath
                        };
                        return [4 /*yield*/, Promise.resolve(beforeZipCallback(info))];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [4 /*yield*/, this.zipPackage(options)];
                    case 7:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Given a root directory, normalize it to a full path.
     * Fall back to cwd if not specified
     * @param rootDir
     */
    RokuDeploy.prototype.normalizeRootDir = function (rootDir) {
        if (!rootDir || (typeof rootDir === 'string' && rootDir.trim().length === 0)) {
            return process.cwd();
        }
        else {
            return path.resolve(rootDir);
        }
    };
    /**
     * Get all file paths for the specified options
     * @param files
     * @param stagingFolderPath - the absolute path to the staging folder
     * @param rootFolderPath - the absolute path to the root dir where relative files entries are relative to
     */
    RokuDeploy.prototype.getFilePaths = function (files, rootDir) {
        return __awaiter(this, void 0, void 0, function () {
            var normalizedFiles, result, _loop_1, this_1, _i, normalizedFiles_1, entry, destPaths, i, entry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        //if the rootDir isn't absolute, convert it to absolute using the standard options flow
                        if (path.isAbsolute(rootDir) === false) {
                            rootDir = this.getOptions({ rootDir: rootDir }).rootDir;
                        }
                        normalizedFiles = this.normalizeFilesArray(files);
                        result = [];
                        _loop_1 = function (entry) {
                            var src, isNegated, entryResults, paths_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        src = typeof entry === 'string' ? entry : entry.src;
                                        isNegated = src.startsWith('!');
                                        //remove the ! so the glob will match properly
                                        if (isNegated) {
                                            src = src.substring(1);
                                        }
                                        return [4 /*yield*/, this_1.getFilePathsForEntry(typeof entry === 'string' ? src : __assign(__assign({}, entry), { src: src }), rootDir)];
                                    case 1:
                                        entryResults = _a.sent();
                                        //if negated, remove all of the negated matches from the results
                                        if (isNegated) {
                                            paths_1 = entryResults.map(function (x) { return x.src; });
                                            result = result.filter(function (x) { return !paths_1.includes(x.src); });
                                            //add all of the entries to the results
                                        }
                                        else {
                                            result.push.apply(result, entryResults);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _i = 0, normalizedFiles_1 = normalizedFiles;
                        _a.label = 1;
                    case 1:
                        if (!(_i < normalizedFiles_1.length)) return [3 /*break*/, 4];
                        entry = normalizedFiles_1[_i];
                        return [5 /*yield**/, _loop_1(entry)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        destPaths = {};
                        for (i = result.length - 1; i >= 0; i--) {
                            entry = result[i];
                            //if we have already seen this dest path, this is a duplicate...throw it out
                            if (destPaths[entry.dest]) {
                                result.splice(i, 1);
                            }
                            else {
                                //this is the first time we've seen this entry, keep it and move on
                                destPaths[entry.dest] = true;
                            }
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    RokuDeploy.prototype.getFilePathsForEntry = function (entry, rootDir) {
        return __awaiter(this, void 0, void 0, function () {
            var result, pattern, files, fileEntries, _i, files_1, filePathAbsolute;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = [];
                        pattern = typeof entry === 'string' ? entry : entry.src;
                        return [4 /*yield*/, globAsync(pattern, {
                                cwd: rootDir,
                                absolute: true,
                                follow: true
                            })];
                    case 1:
                        files = _a.sent();
                        fileEntries = [entry];
                        _i = 0, files_1 = files;
                        _a.label = 2;
                    case 2:
                        if (!(_i < files_1.length)) return [3 /*break*/, 5];
                        filePathAbsolute = files_1[_i];
                        return [4 /*yield*/, util_2.util.isFile(filePathAbsolute)];
                    case 3:
                        //only include files (i.e. skip directories)
                        if (_a.sent()) {
                            //throw an exception when a top-level string references a file outside of the rootDir
                            if (typeof entry === 'string' && util_2.util.isParentOfPath(rootDir, filePathAbsolute) === false) {
                                throw new Error('Cannot reference a file outside of rootDir when using a top-level string. Please use a src;des; object instead');
                            }
                            result.push({
                                src: util_2.util.standardizePath(filePathAbsolute),
                                dest: this.getDestPath(filePathAbsolute, fileEntries, rootDir, true)
                            });
                        }
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Given a full path to a file, determine its dest path
     * @param srcPathAbsolute the path to the file. This MUST be a file path, and it is not verified to exist on the filesystem
     * @param files the files array
     * @param rootDir the absolute path to the root dir
     * @param skipMatch - skip running the minimatch process (i.e. assume the file is a match
     * @returns the RELATIVE path to the dest location for the file.
     */
    RokuDeploy.prototype.getDestPath = function (srcPathAbsolute, files, rootDir, skipMatch) {
        if (skipMatch === void 0) { skipMatch = false; }
        //if the rootDir isn't absolute, convert it to absolute using the standard options flow
        if (path.isAbsolute(rootDir) === false) {
            rootDir = this.getOptions({ rootDir: rootDir }).rootDir;
        }
        //container for the files for this entry
        var standardizedFiles = this.normalizeFilesArray(files);
        var dest;
        //walk through the entire files array and find the last dest entry that matches
        for (var _i = 0, standardizedFiles_1 = standardizedFiles; _i < standardizedFiles_1.length; _i++) {
            var entry = standardizedFiles_1[_i];
            var srcGlobPattern = typeof entry === 'string' ? entry : entry.src;
            var isNegated = srcGlobPattern.startsWith('!');
            if (isNegated) {
                srcGlobPattern = srcGlobPattern.substring(1);
            }
            var isMatch = void 0;
            //if skipMatch is true, assume the file is a match and don't run the match function
            if (skipMatch === true) {
                isMatch = true;
            }
            else {
                //make the glob path absolute
                srcGlobPattern = path.resolve(util_2.util.toForwardSlashes(rootDir), srcGlobPattern);
                isMatch = minimatch(util_2.util.toForwardSlashes(srcPathAbsolute), srcGlobPattern);
            }
            //if not a match, move to the next pattern
            if (!isMatch) {
                continue;
            }
            //if this was a negated pattern, discard dest (i.e. exclude the file) and move to next pattern
            if (isNegated) {
                dest = undefined;
                continue;
            }
            //root-level files array strings are treated like file filters. These must be globs/paths relative to `rootDir`
            if (typeof entry === 'string') {
                //if the path is not found within the rootDir, this is not a match
                if (util_2.util.isParentOfPath(rootDir, srcPathAbsolute) === false) {
                    continue;
                }
                //normalize the path
                srcPathAbsolute = util_2.util.standardizePath(srcPathAbsolute);
                var srcPathRelative = util_2.util.stringReplaceInsensitive(srcPathAbsolute, rootDir, '');
                dest = util_2.util.standardizePath("" + srcPathRelative);
                continue;
            }
            //if this is an explicit file reference
            if (glob.hasMagic(entry.src) === false) {
                var isSrcPathAbsolute = path.isAbsolute(entry.src);
                var entrySrcPathAbsolute = isSrcPathAbsolute ? entry.src : util_2.util.standardizePath(rootDir + "/" + entry.src);
                var isSrcChildOfRootDir = util_2.util.isParentOfPath(rootDir, entrySrcPathAbsolute);
                var fileNameAndExtension = path.basename(entrySrcPathAbsolute);
                //no dest
                if (!entry.dest) {
                    //no dest, absolute path or file outside of rootDir
                    if (isSrcPathAbsolute || isSrcChildOfRootDir === false) {
                        //copy file to root of staging folder
                        dest = fileNameAndExtension;
                        //no dest, relative path, lives INSIDE rootDir
                    }
                    else {
                        //copy relative file structure to root of staging folder
                        var srcPathRelative = util_2.util.stringReplaceInsensitive(entrySrcPathAbsolute, rootDir, '');
                        dest = srcPathRelative;
                    }
                    //assume entry.dest is the relative path to the folder AND file if applicable
                }
                else {
                    dest = entry.dest;
                }
                continue;
            }
            //if src contains double wildcard
            if (entry.src.includes('**')) {
                //run the glob lookup
                srcPathAbsolute = util_2.util.standardizePath(srcPathAbsolute);
                //matches should retain structure relative to star star
                var absolutePathToStarStar = path.resolve(rootDir, entry.src.split('**')[0]);
                var srcPathRelative = util_2.util.stringReplaceInsensitive(srcPathAbsolute, absolutePathToStarStar, '');
                dest = entry.dest ? entry.dest : '';
                dest = util_2.util.standardizePath(dest + "/" + srcPathRelative);
                continue;
            }
            //src is some other type of glob
            {
                var fileNameAndExtension = path.basename(srcPathAbsolute);
                dest = entry.dest ? entry.dest : '';
                dest = util_2.util.standardizePath(dest + "/" + fileNameAndExtension);
                continue;
            }
        }
        //remove any leading slash
        dest = typeof dest === 'string' ? dest.replace(/^[\/\\]*/, '') : undefined;
        return dest;
    };
    /**
     * Copy all of the files to the staging directory
     * @param fileGlobs
     * @param stagingPath
     */
    RokuDeploy.prototype.copyToStaging = function (files, stagingPath, rootDir) {
        return __awaiter(this, void 0, void 0, function () {
            var fileObjects;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!stagingPath) {
                            throw new Error('stagingPath is required');
                        }
                        if (!rootDir) {
                            throw new Error('rootDir is required');
                        }
                        return [4 /*yield*/, this.fsExtra.pathExists(rootDir)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("rootDir does not exist at \"" + rootDir + "\"");
                        }
                        return [4 /*yield*/, this.getFilePaths(files, rootDir)];
                    case 2:
                        fileObjects = _a.sent();
                        //copy all of the files
                        return [4 /*yield*/, Promise.all(fileObjects.map(function (fileObject) { return __awaiter(_this, void 0, void 0, function () {
                                var destFilePath;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            destFilePath = util_2.util.standardizePath(stagingPath + "/" + fileObject.dest);
                                            //make sure the containing folder exists
                                            return [4 /*yield*/, this.fsExtra.ensureDir(path.dirname(destFilePath))];
                                        case 1:
                                            //make sure the containing folder exists
                                            _a.sent();
                                            //sometimes the copyfile action fails due to race conditions (normally to poorly constructed src;dest; objects with duplicate files in them
                                            return [4 /*yield*/, util_2.util.tryRepeatAsync(function () { return __awaiter(_this, void 0, void 0, function () {
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0: 
                                                            //copy the src item using the filesystem
                                                            return [4 /*yield*/, this.fsExtra.copy(fileObject.src, destFilePath, {
                                                                    //copy the actual files that symlinks point to, not the symlinks themselves
                                                                    dereference: true
                                                                })];
                                                            case 1:
                                                                //copy the src item using the filesystem
                                                                _a.sent();
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                }); }, 10)];
                                        case 2:
                                            //sometimes the copyfile action fails due to race conditions (normally to poorly constructed src;dest; objects with duplicate files in them
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 3:
                        //copy all of the files
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    RokuDeploy.prototype.generateBaseRequestOptions = function (requestPath, options) {
        options = this.getOptions(options);
        var url = "http://" + options.host + ":" + options.packagePort + "/" + requestPath;
        var baseRequestOptions = {
            url: url,
            timeout: options.timeout,
            auth: {
                user: options.username,
                pass: options.password,
                sendImmediately: false
            }
        };
        return baseRequestOptions;
    };
    /**
     * Simulate pressing the home button on the remote for this roku.
     * This makes the roku return to the home screen
     * @param host - the host
     * @param port - the port that should be used for the request. defaults to 8060
     * @param timeout - request timeout duration in milliseconds. defaults to 150000
     */
    RokuDeploy.prototype.pressHomeButton = function (host, port, timeout) {
        return __awaiter(this, void 0, void 0, function () {
            var options;
            return __generator(this, function (_a) {
                options = this.getOptions();
                port = port ? port : options.remotePort;
                timeout = timeout ? timeout : options.timeout;
                // press the home button to return to the main screen
                return [2 /*return*/, this.doPostRequest({
                        url: "http://" + host + ":" + port + "/keypress/Home",
                        timeout: timeout
                    }, false)];
            });
        });
    };
    /**
     * Publish a pre-existing packaged zip file to a remote Roku.
     * @param options
     */
    RokuDeploy.prototype.publish = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var zipFilePath, readStream_1, requestOptions, results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        if (!options.host) {
                            throw new errors.MissingRequiredOptionError('must specify the host for the Roku device');
                        }
                        //make sure the outDir exists
                        return [4 /*yield*/, this.fsExtra.ensureDir(options.outDir)];
                    case 1:
                        //make sure the outDir exists
                        _a.sent();
                        zipFilePath = this.getOutputZipFilePath(options);
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, , 6, 9]);
                        return [4 /*yield*/, this.fsExtra.pathExists(zipFilePath)];
                    case 3:
                        if ((_a.sent()) === false) {
                            throw new Error("Cannot publish because file does not exist at '" + zipFilePath + "'");
                        }
                        readStream_1 = this.fsExtra.createReadStream(zipFilePath);
                        //wait for the stream to open (no harm in doing this, and it helps solve an issue in the tests)
                        return [4 /*yield*/, new Promise(function (resolve) {
                                readStream_1.on('open', resolve);
                            })];
                    case 4:
                        //wait for the stream to open (no harm in doing this, and it helps solve an issue in the tests)
                        _a.sent();
                        requestOptions = this.generateBaseRequestOptions('plugin_install', options);
                        requestOptions.formData = {
                            mysubmit: 'Replace',
                            archive: readStream_1
                        };
                        if (options.remoteDebug) {
                            requestOptions.formData.remotedebug = '1';
                        }
                        return [4 /*yield*/, this.doPostRequest(requestOptions)];
                    case 5:
                        results = _a.sent();
                        if (options.failOnCompileError) {
                            if (results.body.indexOf('Install Failure: Compilation Failed.') > -1) {
                                throw new errors.CompileError('Compile error', results);
                            }
                        }
                        if (results.body.indexOf('Identical to previous version -- not replacing.') > -1) {
                            return [2 /*return*/, { message: 'Identical to previous version -- not replacing', results: results }];
                        }
                        return [2 /*return*/, { message: 'Successful deploy', results: results }];
                    case 6:
                        if (!(options.retainDeploymentArchive === false)) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.fsExtra.remove(zipFilePath)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8: return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Converts existing loaded package to squashfs for faster loading packages
     * @param options
     */
    RokuDeploy.prototype.convertToSquashfs = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, results;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        if (!options.host) {
                            throw new errors.MissingRequiredOptionError('must specify the host for the Roku device');
                        }
                        requestOptions = this.generateBaseRequestOptions('plugin_install', options);
                        requestOptions.formData = {
                            archive: '',
                            mysubmit: 'Convert to squashfs'
                        };
                        return [4 /*yield*/, this.doPostRequest(requestOptions)];
                    case 1:
                        results = _a.sent();
                        if (results.body.indexOf('Conversion succeeded') === -1) {
                            throw new errors.ConvertError('Squashfs conversion failed');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * resign Roku Device with supplied pkg and
     * @param options
     */
    RokuDeploy.prototype.rekeyDevice = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var rekeySignedPackagePath, requestOptions, results, resultTextSearch, devId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        if (!options.rekeySignedPackage) {
                            throw new errors.MissingRequiredOptionError('Must supply rekeySignedPackage');
                        }
                        if (!options.signingPassword) {
                            throw new errors.MissingRequiredOptionError('Must supply signingPassword');
                        }
                        rekeySignedPackagePath = options.rekeySignedPackage;
                        if (!path.isAbsolute(options.rekeySignedPackage)) {
                            rekeySignedPackagePath = path.join(options.rootDir, options.rekeySignedPackage);
                        }
                        requestOptions = this.generateBaseRequestOptions('plugin_inspect', options);
                        requestOptions.formData = {
                            mysubmit: 'Rekey',
                            passwd: options.signingPassword,
                            archive: this.fsExtra.createReadStream(rekeySignedPackagePath)
                        };
                        return [4 /*yield*/, this.doPostRequest(requestOptions)];
                    case 1:
                        results = _a.sent();
                        resultTextSearch = /<font color="red">([^<]+)<\/font>/.exec(results.body);
                        if (!resultTextSearch) {
                            throw new errors.UnparsableDeviceResponseError('Unknown Rekey Failure');
                        }
                        if (resultTextSearch[1] !== 'Success.') {
                            throw new errors.FailedDeviceResponseError('Rekey Failure: ' + resultTextSearch[1]);
                        }
                        if (!options.devId) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getDevId(options)];
                    case 2:
                        devId = _a.sent();
                        if (devId !== options.devId) {
                            throw new errors.UnknownDeviceResponseError('Rekey was successful but resulting Dev ID "' + devId + '" did not match expected value of "' + options.devId + '"');
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param options
     */
    RokuDeploy.prototype.signExistingPackage = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var manifestPath, parsedManifest, appName, requestOptions, results, failedSearchMatches, pkgSearchMatches;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        if (!options.signingPassword) {
                            throw new errors.MissingRequiredOptionError('Must supply signingPassword');
                        }
                        manifestPath = path.join(options.stagingFolderPath, 'manifest');
                        return [4 /*yield*/, this.parseManifest(manifestPath)];
                    case 1:
                        parsedManifest = _a.sent();
                        appName = parsedManifest.title + '/' + parsedManifest.major_version + '.' + parsedManifest.minor_version;
                        requestOptions = this.generateBaseRequestOptions('plugin_package', options);
                        requestOptions.formData = {
                            mysubmit: 'Package',
                            pkg_time: (new Date()).getTime(),
                            passwd: options.signingPassword,
                            app_name: appName //eslint-disable-line camelcase
                        };
                        return [4 /*yield*/, this.doPostRequest(requestOptions)];
                    case 2:
                        results = _a.sent();
                        failedSearchMatches = /<font.*>Failed: (.*)/.exec(results.body);
                        if (failedSearchMatches) {
                            throw new errors.FailedDeviceResponseError(failedSearchMatches[1], results);
                        }
                        pkgSearchMatches = /<a href="(pkgs\/[^\.]+\.pkg)">/.exec(results.body);
                        if (pkgSearchMatches) {
                            return [2 /*return*/, pkgSearchMatches[1]];
                        }
                        throw new errors.UnknownDeviceResponseError('Unknown error signing package', results);
                }
            });
        });
    };
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param pkgPath
     * @param options
     */
    RokuDeploy.prototype.retrieveSignedPackage = function (pkgPath, options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, pkgFilePath;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        requestOptions = this.generateBaseRequestOptions(pkgPath, options);
                        pkgFilePath = this.getOutputPkgFilePath(options);
                        return [4 /*yield*/, this.fsExtra.ensureDir(path.dirname(pkgFilePath))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                _this.request.get(requestOptions)
                                    .on('error', function (err) { return reject(err); })
                                    .on('response', function (response) {
                                    if (response.statusCode !== 200) {
                                        reject(new Error('Invalid response code: ' + response.statusCode));
                                    }
                                    resolve(pkgFilePath);
                                })
                                    .pipe(_this.fsExtra.createWriteStream(pkgFilePath));
                            })];
                }
            });
        });
    };
    /**
     * Centralized function for handling POST http requests
     * @param params
     */
    RokuDeploy.prototype.doPostRequest = function (params, verify) {
        if (verify === void 0) { verify = true; }
        return __awaiter(this, void 0, void 0, function () {
            var results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this.request.post(params, function (err, resp, body) {
                                if (err) {
                                    return reject(err);
                                }
                                return resolve({ response: resp, body: body });
                            });
                        })];
                    case 1:
                        results = _a.sent();
                        if (verify) {
                            this.checkRequest(results);
                        }
                        return [2 /*return*/, results];
                }
            });
        });
    };
    /**
     * Centralized function for handling GET http requests
     * @param params
     */
    RokuDeploy.prototype.doGetRequest = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this.request.get(params, function (err, resp, body) {
                                if (err) {
                                    return reject(err);
                                }
                                return resolve({ response: resp, body: body });
                            });
                        })];
                    case 1:
                        results = _a.sent();
                        this.checkRequest(results);
                        return [2 /*return*/, results];
                }
            });
        });
    };
    RokuDeploy.prototype.checkRequest = function (results) {
        if (!results || !results.response || typeof results.body !== 'string') {
            throw new errors.UnparsableDeviceResponseError('Invalid response', results);
        }
        if (results.response.statusCode === 401) {
            throw new errors.UnauthorizedDeviceResponseError('Unauthorized. Please verify username and password for target Roku.', results);
        }
        if (results.response.statusCode !== 200) {
            throw new errors.InvalidDeviceResponseCodeError('Invalid response code: ' + results.response.statusCode);
        }
    };
    /**
     * Create a zip of the project, and then publish to the target Roku device
     * @param options
     */
    RokuDeploy.prototype.deploy = function (options, beforeZipCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        return [4 /*yield*/, this.createPackage(options, beforeZipCallback)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.deleteInstalledChannel(options)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.publish(options)];
                    case 3:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Deletes any installed dev channel on the target Roku device
     * @param options
     */
    RokuDeploy.prototype.deleteInstalledChannel = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var deleteOptions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        deleteOptions = this.generateBaseRequestOptions('plugin_install', options);
                        deleteOptions.formData = {
                            mysubmit: 'Delete',
                            archive: ''
                        };
                        return [4 /*yield*/, this.doPostRequest(deleteOptions)];
                    case 1: return [2 /*return*/, (_a.sent())];
                }
            });
        });
    };
    /**
     * executes sames steps as deploy and signs the package and stores it in the out folder
     * @param options
     */
    RokuDeploy.prototype.deployAndSignPackage = function (options, beforeZipCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var originalOptionValueRetainStagingFolder, remotePkgPath, localPkgFilePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        originalOptionValueRetainStagingFolder = options.retainStagingFolder;
                        options = this.getOptions(options);
                        options.retainStagingFolder = true;
                        return [4 /*yield*/, this.deploy(options, beforeZipCallback)];
                    case 1:
                        _a.sent();
                        if (!options.convertToSquashfs) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.convertToSquashfs(options)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.signExistingPackage(options)];
                    case 4:
                        remotePkgPath = _a.sent();
                        return [4 /*yield*/, this.retrieveSignedPackage(remotePkgPath, options)];
                    case 5:
                        localPkgFilePath = _a.sent();
                        if (!(originalOptionValueRetainStagingFolder !== true)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.fsExtra.remove(options.stagingFolderPath)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/, localPkgFilePath];
                }
            });
        });
    };
    /**
     * Get an options with all overridden vaues, and then defaults for missing values
     * @param options
     */
    RokuDeploy.prototype.getOptions = function (options) {
        if (options === void 0) { options = {}; }
        var fileOptions = {};
        var fileNames = ['rokudeploy.json', 'bsconfig.json'];
        if (options.project) {
            fileNames.unshift(options.project);
        }
        for (var _i = 0, fileNames_1 = fileNames; _i < fileNames_1.length; _i++) {
            var fileName = fileNames_1[_i];
            if (this.fsExtra.existsSync(fileName)) {
                var configFileText = this.fsExtra.readFileSync(fileName).toString();
                var parseErrors = [];
                fileOptions = jsonc_parser_1.parse(configFileText, parseErrors);
                if (parseErrors.length > 0) {
                    throw new Error("Error parsing \"" + path.resolve(fileName) + "\": " + JSON.stringify(parseErrors.map(function (x) {
                        return {
                            message: jsonc_parser_1.printParseErrorCode(x.error),
                            offset: x.offset,
                            length: x.length
                        };
                    })));
                }
                break;
            }
        }
        var defaultOptions = {
            outDir: './out',
            outFile: 'roku-deploy',
            retainStagingFolder: false,
            retainDeploymentArchive: true,
            incrementBuildNumber: false,
            failOnCompileError: true,
            packagePort: 80,
            remotePort: 8060,
            timeout: 150000,
            rootDir: './',
            files: __spreadArrays(exports.DefaultFiles),
            username: 'rokudev'
        };
        //override the defaults with any found or provided options
        var finalOptions = __assign(__assign(__assign({}, defaultOptions), fileOptions), options);
        //fully resolve the folder paths
        finalOptions.rootDir = path.resolve(process.cwd(), finalOptions.rootDir);
        finalOptions.outDir = path.resolve(process.cwd(), finalOptions.outDir);
        //stagingFolderPath
        if (finalOptions.stagingFolderPath) {
            finalOptions.stagingFolderPath = path.resolve(process.cwd(), finalOptions.stagingFolderPath);
        }
        else {
            finalOptions.stagingFolderPath = path.resolve(process.cwd(), util_2.util.standardizePath(finalOptions.outDir + "/.roku-deploy-staging"));
        }
        return finalOptions;
    };
    /**
     * Centralizes getting output zip file path based on passed in options
     * @param options
     */
    RokuDeploy.prototype.getOutputZipFilePath = function (options) {
        options = this.getOptions(options);
        var zipFileName = options.outFile;
        if (!zipFileName.toLowerCase().endsWith('.zip')) {
            zipFileName += '.zip';
        }
        var outFolderPath = path.resolve(options.outDir);
        var outZipFilePath = path.join(outFolderPath, zipFileName);
        return outZipFilePath;
    };
    /**
     * Centralizes getting output pkg file path based on passed in options
     * @param options
     */
    RokuDeploy.prototype.getOutputPkgFilePath = function (options) {
        options = this.getOptions(options);
        var pkgFileName = options.outFile;
        if (pkgFileName.toLowerCase().endsWith('.zip')) {
            pkgFileName = pkgFileName.replace('.zip', '.pkg');
        }
        else {
            pkgFileName += '.pkg';
        }
        var outFolderPath = path.resolve(options.outDir);
        var outPkgFilePath = path.join(outFolderPath, pkgFileName);
        return outPkgFilePath;
    };
    RokuDeploy.prototype.getDeviceInfo = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var requestOptions, results, parsedContent, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        options = this.getOptions(options);
                        requestOptions = {
                            url: "http://" + options.host + ":" + options.remotePort + "/query/device-info",
                            timeout: options.timeout
                        };
                        return [4 /*yield*/, this.doGetRequest(requestOptions)];
                    case 1:
                        results = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, xml2js.parseStringPromise(results.body, {
                                explicitArray: false
                            })];
                    case 3:
                        parsedContent = _a.sent();
                        return [2 /*return*/, parsedContent['device-info']];
                    case 4:
                        e_1 = _a.sent();
                        throw new errors.UnparsableDeviceResponseError('Could not retrieve device info', results);
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    RokuDeploy.prototype.getDevId = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var deviceInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getDeviceInfo(options)];
                    case 1:
                        deviceInfo = _a.sent();
                        return [2 /*return*/, deviceInfo['keyed-developer-id']];
                }
            });
        });
    };
    RokuDeploy.prototype.parseManifest = function (manifestPath) {
        return __awaiter(this, void 0, void 0, function () {
            var manifestContents;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fsExtra.pathExists(manifestPath)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error(manifestPath + ' does not exist');
                        }
                        return [4 /*yield*/, this.fsExtra.readFile(manifestPath, 'utf-8')];
                    case 2:
                        manifestContents = _a.sent();
                        return [2 /*return*/, this.parseManifestFromString(manifestContents)];
                }
            });
        });
    };
    RokuDeploy.prototype.parseManifestFromString = function (manifestContents) {
        var manifestLines = manifestContents.split('\n');
        var manifestData = {};
        manifestData.keyIndexes = {};
        manifestData.lineCount = manifestLines.length;
        manifestLines.forEach(function (line, index) {
            var match = /(\w+)=(.+)/.exec(line);
            if (match) {
                var key = match[1];
                manifestData[key] = match[2];
                manifestData.keyIndexes[key] = index;
            }
        });
        return manifestData;
    };
    RokuDeploy.prototype.stringifyManifest = function (manifestData) {
        var output = [];
        if (manifestData.keyIndexes && manifestData.lineCount) {
            output.fill('', 0, manifestData.lineCount);
            var key = void 0;
            for (key in manifestData) {
                if (key === 'lineCount' || key === 'keyIndexes') {
                    continue;
                }
                var index = manifestData.keyIndexes[key];
                output[index] = key + "=" + manifestData[key];
            }
        }
        else {
            output = Object.keys(manifestData).map(function (key) {
                return key + "=" + manifestData[key];
            });
        }
        return output.join('\n');
    };
    /**
     * Given a path to a folder, zip up that folder and all of its contents
     * @param srcFolder
     * @param zipFilePath
     */
    RokuDeploy.prototype.zipFolder = function (srcFolder, zipFilePath) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var output = _this.fsExtra.createWriteStream(zipFilePath);
            var archive = archiver('zip');
            output.on('close', function () {
                resolve();
            });
            output.on('error', function (err) {
                reject(err);
            });
            /* istanbul ignore next */
            archive.on('warning', function (err) {
                if (err.code === 'ENOENT') {
                    console.warn(err);
                }
                else {
                    reject(err);
                }
            });
            /* istanbul ignore next */
            archive.on('error', function (err) {
                reject(err);
            });
            archive.pipe(output);
            //add every file in the source folder
            archive.directory(srcFolder, false);
            //finalize the archive
            archive.finalize();
        });
    };
    return RokuDeploy;
}());
exports.RokuDeploy = RokuDeploy;
exports.DefaultFiles = [
    'source/**/*.*',
    'components/**/*.*',
    'images/**/*.*',
    'manifest'
];
//# sourceMappingURL=RokuDeploy.js.map