import * as _fsExtra from 'fs-extra';
import * as request from 'request';
import { RokuDeployOptions, FileEntry } from './RokuDeployOptions';
export declare class RokuDeploy {
    request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;
    fsExtra: typeof _fsExtra;
    /**
     * Copies all of the referenced files to the staging folder
     * @param options
     */
    prepublishToStaging(options: RokuDeployOptions): Promise<string>;
    /**
     * Given an array of `FilesType`, normalize each of them into a standard {src;dest} object.
     * Each entry in the array or inner `src` array will be extracted out into its own object.
     * This makes it easier to reason about later on in the process.
     * @param files
     */
    normalizeFilesArray(files: FileEntry[]): (string | StandardizedFileEntry)[];
    /**
     * Given an already-populated staging folder, create a zip archive of it and copy it to the output folder
     * @param options
     */
    zipPackage(options: RokuDeployOptions): Promise<void>;
    /**
     * Create a zip folder containing all of the specified roku project files.
     * @param options
     */
    createPackage(options: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => Promise<void> | void): Promise<void>;
    /**
     * Given a root directory, normalize it to a full path.
     * Fall back to cwd if not specified
     * @param rootDir
     */
    normalizeRootDir(rootDir: string): string;
    /**
     * Get all file paths for the specified options
     * @param files
     * @param stagingFolderPath - the absolute path to the staging folder
     * @param rootFolderPath - the absolute path to the root dir where relative files entries are relative to
     */
    getFilePaths(files: FileEntry[], rootDir: string): Promise<StandardizedFileEntry[]>;
    private getFilePathsForEntry;
    /**
     * Given a full path to a file, determine its dest path
     * @param srcPathAbsolute the path to the file. This MUST be a file path, and it is not verified to exist on the filesystem
     * @param files the files array
     * @param rootDir the absolute path to the root dir
     * @param skipMatch - skip running the minimatch process (i.e. assume the file is a match
     * @returns the RELATIVE path to the dest location for the file.
     */
    getDestPath(srcPathAbsolute: string, files: FileEntry[], rootDir: string, skipMatch?: boolean): string | undefined;
    /**
     * Copy all of the files to the staging directory
     * @param fileGlobs
     * @param stagingPath
     */
    private copyToStaging;
    private generateBaseRequestOptions;
    /**
     * Simulate pressing the home button on the remote for this roku.
     * This makes the roku return to the home screen
     * @param host - the host
     * @param port - the port that should be used for the request. defaults to 8060
     * @param timeout - request timeout duration in milliseconds. defaults to 150000
     */
    pressHomeButton(host: any, port?: number, timeout?: number): Promise<{
        response: any;
        body: any;
    }>;
    /**
     * Publish a pre-existing packaged zip file to a remote Roku.
     * @param options
     */
    publish(options: RokuDeployOptions): Promise<{
        message: string;
        results: any;
    }>;
    /**
     * Converts existing loaded package to squashfs for faster loading packages
     * @param options
     */
    convertToSquashfs(options: RokuDeployOptions): Promise<void>;
    /**
     * resign Roku Device with supplied pkg and
     * @param options
     */
    rekeyDevice(options: RokuDeployOptions): Promise<void>;
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param options
     */
    signExistingPackage(options: RokuDeployOptions): Promise<string>;
    /**
     * Sign a pre-existing package using Roku and return path to retrieve it
     * @param pkgPath
     * @param options
     */
    retrieveSignedPackage(pkgPath: string, options: RokuDeployOptions): Promise<string>;
    /**
     * Centralized function for handling POST http requests
     * @param params
     */
    private doPostRequest;
    /**
     * Centralized function for handling GET http requests
     * @param params
     */
    private doGetRequest;
    private checkRequest;
    /**
     * Create a zip of the project, and then publish to the target Roku device
     * @param options
     */
    deploy(options?: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => void): Promise<{
        message: string;
        results: any;
    }>;
    /**
     * Deletes any installed dev channel on the target Roku device
     * @param options
     */
    deleteInstalledChannel(options?: RokuDeployOptions): Promise<{
        response: any;
        body: any;
    }>;
    /**
     * executes sames steps as deploy and signs the package and stores it in the out folder
     * @param options
     */
    deployAndSignPackage(options?: RokuDeployOptions, beforeZipCallback?: (info: BeforeZipCallbackInfo) => void): Promise<string>;
    /**
     * Get an options with all overridden vaues, and then defaults for missing values
     * @param options
     */
    getOptions(options?: RokuDeployOptions): {
        project?: string;
        outDir?: string;
        outFile?: string;
        rootDir?: string;
        files?: FileEntry[];
        retainStagingFolder?: boolean;
        retainDeploymentArchive?: boolean;
        stagingFolderPath?: string;
        host?: string;
        packagePort?: number;
        remoteDebug?: boolean;
        remotePort?: number;
        timeout?: number;
        username?: string;
        password?: string;
        signingPassword?: string;
        rekeySignedPackage?: string;
        devId?: string;
        incrementBuildNumber?: boolean;
        convertToSquashfs?: boolean;
        failOnCompileError?: boolean;
    };
    /**
     * Centralizes getting output zip file path based on passed in options
     * @param options
     */
    getOutputZipFilePath(options: RokuDeployOptions): string;
    /**
     * Centralizes getting output pkg file path based on passed in options
     * @param options
     */
    getOutputPkgFilePath(options?: RokuDeployOptions): string;
    getDeviceInfo(options?: RokuDeployOptions): Promise<any>;
    getDevId(options?: RokuDeployOptions): Promise<any>;
    parseManifest(manifestPath: string): Promise<ManifestData>;
    parseManifestFromString(manifestContents: string): ManifestData;
    stringifyManifest(manifestData: ManifestData): string;
    /**
     * Given a path to a folder, zip up that folder and all of its contents
     * @param srcFolder
     * @param zipFilePath
     */
    zipFolder(srcFolder: string, zipFilePath: string): Promise<unknown>;
}
export interface ManifestData {
    [key: string]: any;
    keyIndexes?: {
        [id: string]: number;
    };
    lineCount?: number;
}
export interface BeforeZipCallbackInfo {
    /**
     * Contains an associative array of the parsed values in the manifest
     */
    manifestData: ManifestData;
    stagingFolderPath: string;
}
export interface StandardizedFileEntry {
    /**
     * The full path to the source file
     */
    src: string;
    /**
     * The path relative to the root of the pkg to where the file should be placed
     */
    dest: string;
}
export declare const DefaultFiles: string[];
