"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const path = require("path");
const sinonImport = require("sinon");
const vscode_languageserver_1 = require("vscode-languageserver");
const DiagnosticMessages_1 = require("../DiagnosticMessages");
const Program_1 = require("../Program");
const BrsFile_1 = require("./BrsFile");
const XmlFile_1 = require("./XmlFile");
const util_1 = require("../util");
const BrsFile_spec_1 = require("./BrsFile.spec");
describe('XmlFile', () => {
    let rootDir = process.cwd();
    let program;
    let sinon = sinonImport.createSandbox();
    let file;
    let testTranspile = BrsFile_spec_1.getTestTranspile(() => [program, rootDir]);
    beforeEach(() => {
        program = new Program_1.Program({ rootDir: rootDir });
        file = new XmlFile_1.XmlFile(`${rootDir}/components/MainComponent.xml`, 'components/MainComponent.xml', program);
    });
    afterEach(() => {
        sinon.restore();
        program.dispose();
    });
    describe('parse', () => {
        it('allows modifying the parsed XML model', async () => {
            const expected = 'OtherName';
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            program.plugins.add({
                name: 'allows modifying the parsed XML model',
                afterFileParse: () => {
                    file.parsedXml.component.$.name = expected;
                }
            });
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="Scene">
                    <script type="text/brightscript" uri="ChildScene1.brs" /> <script type="text/brightscript" uri="ChildScene2.brs" /> <script type="text/brightscript" uri="ChildScene3.brs" />
                </component>
            `);
            chai_1.expect(file.componentName).to.equal(expected);
        });
        it('supports importing BrighterScript files', async () => {
            file = await program.addOrReplaceFile({ src: `${rootDir}/components/custom.xml`, dest: 'components/custom.xml' }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="Scene">
                    <script type="text/brightscript" uri="ChildScene.bs" />
                </component>
            `);
            chai_1.expect(file.scriptTagImports.map(x => x.pkgPath)[0]).to.equal(util_1.standardizePath `components/ChildScene.bs`);
        });
        it('does not include commented-out script imports', async () => {
            var _a, _b;
            file = await program.addOrReplaceFile({ src: `${rootDir}/components/custom.xml`, dest: 'components/custom.xml' }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="Scene">
                    <script type="text/brightscript" uri="ChildScene.brs" />
                    <!--
                        <script type="text/brightscript" uri="ChildScene.brs" />
                    -->
                </component>
            `);
            chai_1.expect((_b = (_a = file.scriptTagImports) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.pkgPath).to.eql(util_1.standardizePath `components/ChildScene.brs`);
        });
        it('finds scripts when more than one per line', async () => {
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="Scene">
                    <script type="text/brightscript" uri="ChildScene1.brs" /> <script type="text/brightscript" uri="ChildScene2.brs" /> <script type="text/brightscript" uri="ChildScene3.brs" />
                </component>
            `);
            chai_1.expect(file.scriptTagImports).to.be.lengthOf(3);
            chai_1.expect(file.scriptTagImports[0]).to.deep.include({
                text: 'ChildScene1.brs',
                filePathRange: vscode_languageserver_1.Range.create(3, 58, 3, 73)
            });
            chai_1.expect(file.scriptTagImports[1]).to.deep.include({
                text: 'ChildScene2.brs',
                filePathRange: vscode_languageserver_1.Range.create(3, 116, 3, 131)
            });
            chai_1.expect(file.scriptTagImports[2]).to.deep.include({
                text: 'ChildScene3.brs',
                filePathRange: vscode_languageserver_1.Range.create(3, 174, 3, 189)
            });
        });
        it('finds component names', async () => {
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="ParentScene">
                <script type="text/brightscript" uri="ChildScene.brs" />
                </component>
            `);
            chai_1.expect(file.parentComponentName).to.equal('ParentScene');
            chai_1.expect(file.componentName).to.equal('ChildScene');
        });
        it('Adds error when no component is declared in xml', async () => {
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            await file.parse('<script type="text/brightscript" uri="ChildScene.brs" />');
            chai_1.expect(file.diagnostics).to.be.lengthOf(1);
            chai_1.expect(file.diagnostics[0].message).to.equal(DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingComponentDeclaration().message);
        });
        it('adds error when component does not declare a name', async () => {
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component extends="ParentScene">
                <script type="text/brightscript" uri="ChildScene.brs" />
                </component>
            `);
            chai_1.expect(file.diagnostics).to.be.lengthOf(1);
            chai_1.expect(file.diagnostics[0]).to.deep.include({
                message: DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingNameAttribute().message,
                range: vscode_languageserver_1.Range.create(2, 16, 2, 26)
            });
        });
        it('catches xml parse errors', async () => {
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component 1extends="ParentScene">
                </component>
            `);
            chai_1.expect(file.diagnostics).to.be.lengthOf(1);
            chai_1.expect(file.diagnostics[0]).to.deep.include({
                code: DiagnosticMessages_1.DiagnosticMessages.xmlGenericParseError('Some generic parse error').code,
                range: vscode_languageserver_1.Range.create(2, 27, 2, 27)
            });
        });
        it('finds script imports', async () => {
            file = new XmlFile_1.XmlFile('abspath/components/cmp1.xml', 'components/cmp1.xml', program);
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Cmp1" extends="Scene">
                    <script type="text/brightscript" uri="pkg:/components/cmp1.brs" />
                </component>
            `);
            chai_1.expect(file.scriptTagImports.length).to.equal(1);
            chai_1.expect(file.scriptTagImports[0]).to.deep.include({
                sourceFile: file,
                text: 'pkg:/components/cmp1.brs',
                pkgPath: `components${path.sep}cmp1.brs`,
                filePathRange: vscode_languageserver_1.Range.create(3, 58, 3, 82)
            });
        });
        it('throws an error if the file has already been parsed', async () => {
            file = new XmlFile_1.XmlFile('abspath', 'relpath', program);
            await file.parse('a comment');
            try {
                await file.parse(`'a new comment`);
                chai_1.assert.fail(null, null, 'Should have thrown an exception, but did not');
            }
            catch (e) {
                //test passes
            }
        });
        it('resolves relative paths', async () => {
            file = await program.addOrReplaceFile({
                src: `${rootDir}/components/comp1.xml`,
                dest: 'components/comp1.xml'
            }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Cmp1" extends="Scene">
                    <script type="text/brightscript" uri="cmp1.brs" />
                </component>
            `);
            chai_1.expect(file.scriptTagImports.length).to.equal(1);
            chai_1.expect(file.scriptTagImports[0]).to.deep.include({
                text: 'cmp1.brs',
                pkgPath: `components${path.sep}cmp1.brs`
            });
        });
        it('finds correct position for empty uri in script tag', async () => {
            var _a;
            file = await program.addOrReplaceFile({
                src: `${rootDir}/components/comp1.xml`,
                dest: 'components/comp1.xml'
            }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Cmp1" extends="Scene">
                    <script type="text/brightscript" uri="" />
                </component>
            `);
            chai_1.expect(file.scriptTagImports.length).to.equal(1);
            chai_1.expect((_a = file.scriptTagImports[0]) === null || _a === void 0 ? void 0 : _a.filePathRange).to.eql(vscode_languageserver_1.Range.create(3, 58, 3, 58));
        });
    });
    describe('doesReferenceFile', () => {
        it('compares case insensitive', async () => {
            let xmlFile = await program.addOrReplaceFile({
                src: `${rootDir}/components/comp1.xml`,
                dest: 'components/comp1.xml'
            }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Cmp1" extends="Scene">
                    <script type="text/brightscript" uri="HeroGrid.brs" />
                </component>
            `);
            let brsFile = await program.addOrReplaceFile({
                src: `${rootDir}/components/HEROGRID.brs`,
                dest: `components/HEROGRID.brs`
            }, ``);
            chai_1.expect(xmlFile.doesReferenceFile(brsFile)).to.be.true;
        });
    });
    describe('autoImportComponentScript', () => {
        it('is not enabled by default', async () => {
            await program.addOrReplaceFile({ src: `${rootDir}/components/comp1.xml`, dest: 'components/comp1.xml' }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ParentScene" extends="GrandparentScene">
                    <script type="text/brightscript" uri="./lib.brs" />
                </component>
            `);
            await program.addOrReplaceFile({ src: `${rootDir}/components/lib.brs`, dest: 'components/lib.brs' }, `
                function libFunc()
                end function
            `);
            await program.addOrReplaceFile({ src: `${rootDir}/components/comp1.bs`, dest: 'components/comp1.bs' }, `
                function init()
                    libFunc()
                end function
            `);
            await program.validate();
            chai_1.expect(program.getDiagnostics().map(x => x.message)).to.include(DiagnosticMessages_1.DiagnosticMessages.fileNotReferencedByAnyOtherFile().message);
        });
        it('is not enabled by default', async () => {
            program = new Program_1.Program({
                rootDir: rootDir,
                autoImportComponentScript: true
            });
            await program.addOrReplaceFile({ src: `${rootDir}/components/comp1.xml`, dest: 'components/comp1.xml' }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ParentScene" extends="GrandparentScene">
                    <script type="text/brightscript" uri="./lib.brs" />
                </component>
            `);
            await program.addOrReplaceFile({ src: `${rootDir}/components/lib.brs`, dest: 'components/lib.brs' }, `
                function libFunc()
                end function
            `);
            await program.addOrReplaceFile({ src: `${rootDir}/components/comp1.bs`, dest: 'components/comp1.bs' }, `
                function init()
                    libFunc()
                end function
            `);
            await program.validate();
            //there should be no errors
            chai_1.expect(program.getDiagnostics().map(x => x.message)[0]).not.to.exist;
        });
    });
    describe('getCompletions', () => {
        it('formats completion paths with proper slashes', async () => {
            let scriptPath = util_1.standardizePath `C:/app/components/component1/component1.brs`;
            program.files[scriptPath] = new BrsFile_1.BrsFile(scriptPath, util_1.standardizePath `components/component1/component1.brs`, program);
            let xmlFile = new XmlFile_1.XmlFile(util_1.standardizePath `${rootDir}/components/component1/component1.xml`, util_1.standardizePath `components/component1/component1.xml`, program);
            xmlFile.scriptTagImports.push({
                pkgPath: util_1.standardizePath `components/component1/component1.brs`,
                text: 'component1.brs',
                filePathRange: vscode_languageserver_1.Range.create(1, 1, 1, 1),
                sourceFile: xmlFile
            });
            chai_1.expect((await xmlFile.getCompletions(vscode_languageserver_1.Position.create(1, 1)))[0]).to.include({
                label: 'component1.brs',
                kind: vscode_languageserver_1.CompletionItemKind.File
            });
            chai_1.expect((await xmlFile.getCompletions(vscode_languageserver_1.Position.create(1, 1)))[1]).to.include({
                label: 'pkg:/components/component1/component1.brs',
                kind: vscode_languageserver_1.CompletionItemKind.File
            });
        });
        it('returns empty set when out of range', async () => {
            await program.addOrReplaceFile({ src: `${rootDir}/components/Component1.brs`, dest: 'components/component1.brs' }, ``);
            chai_1.expect(await file.getCompletions(vscode_languageserver_1.Position.create(99, 99))).to.be.empty;
        });
        //TODO - refine this test once cdata scripts are supported
        it('prevents scope completions entirely', async () => {
            await program.addOrReplaceFile({ src: `${rootDir}/components/Component1.brs`, dest: 'components/component1.brs' }, ``);
            let xmlFile = await program.addOrReplaceFile({ src: `${rootDir}/components/Component1.xml`, dest: 'components/component1.xml' }, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ParentScene" extends="GrandparentScene">
                    <script type="text/brightscript" uri="./Component1.brs" />
                </component>
            `);
            chai_1.expect(program.getCompletions(xmlFile.pathAbsolute, vscode_languageserver_1.Position.create(1, 1))).to.be.empty;
        });
    });
    describe('getAllDependencies', () => {
        it('returns own imports', async () => {
            file = await program.addOrReplaceFile('components/comp1.xml', `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="BaseScene">
                    <script type="text/brightscript" uri="pkg:/source/lib.brs" />
                </component>
            `);
            chai_1.expect(file.getAllDependencies().sort()).to.eql([
                util_1.standardizePath `source/lib.brs`,
                util_1.standardizePath `source/lib.d.bs`
            ]);
        });
    });
    it('invalidates dependent scopes on change', async () => {
        let xmlFile = await program.addOrReplaceFile({
            src: `${rootDir}/components/comp1.xml`,
            dest: `components/comp1.xml`
        }, `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="ChildScene" extends="BaseScene">
                <script type="text/brightscript" uri="pkg:/source/lib.bs" />
            </component>
        `);
        await program.validate();
        let scope = program.getScopesForFile(xmlFile)[0];
        //scope should be validated
        chai_1.expect(scope.isValidated);
        //add lib1
        await program.addOrReplaceFile({
            src: `${rootDir}/source/lib.bs`,
            dest: `source/lib.bs`
        }, ``);
        //adding a dependent file should have invalidated the scope
        chai_1.expect(scope.isValidated).to.be.false;
        await program.validate();
        chai_1.expect(scope.isValidated).to.be.true;
        //update lib1 to include an import
        await program.addOrReplaceFile({
            src: `${rootDir}/source/lib.bs`,
            dest: `source/lib.bs`
        }, `
            import "lib2.bs"
        `);
        //scope should have been invalidated again
        chai_1.expect(scope.isValidated).to.be.false;
        await program.validate();
        chai_1.expect(scope.isValidated).to.be.true;
        //add the lib2 imported from lib
        await program.addOrReplaceFile({
            src: `${rootDir}/source/lib2.bs`,
            dest: `source/lib2.bs`
        }, ``);
        //scope should have been invalidated again because of chained dependency
        chai_1.expect(scope.isValidated).to.be.false;
        await program.validate();
        chai_1.expect(scope.isValidated).to.be.true;
        program.removeFile(`${rootDir}/source/lib.bs`);
        chai_1.expect(scope.isValidated).to.be.false;
    });
    it('does not invalidate unrelated scopes on change', async () => {
        let xmlFile1 = await program.addOrReplaceFile({
            src: `${rootDir}/components/comp1.xml`,
            dest: `components/comp1.xml`
        }, `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="ChildScene1" extends="BaseScene">
                <script type="text/brightscript" uri="pkg:/source/lib.brs" />
            </component>
        `);
        let xmlFile2 = await program.addOrReplaceFile({
            src: `${rootDir}/components/comp2.xml`,
            dest: `components/comp2.xml`
        }, `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="ChildScene2" extends="BaseScene">
            </component>
        `);
        await program.validate();
        //scope should be validated
        chai_1.expect(program.getScopesForFile(xmlFile1)[0].isValidated).to.be.true;
        chai_1.expect(program.getScopesForFile(xmlFile2)[0].isValidated).to.be.true;
        //add the lib file
        await program.addOrReplaceFile({
            src: `${rootDir}/source/lib.brs`,
            dest: `source/lib.brs`
        }, ``);
        chai_1.expect(program.getScopesForFile(xmlFile1)[0].isValidated).to.be.false;
        chai_1.expect(program.getScopesForFile(xmlFile2)[0].isValidated).to.be.true;
    });
    it('allows adding diagnostics', () => {
        const expected = [{
                message: 'message',
                file: undefined,
                range: undefined
            }];
        file.addDiagnostics(expected);
        const actual = file.getDiagnostics();
        chai_1.expect(actual).deep.equal(expected);
    });
    describe('findExtendsPosition', () => {
        it('works for single-line', () => {
            chai_1.expect(file.findExtendsPosition(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene" extends="BaseScene">
                </component>
            `)).to.eql(vscode_languageserver_1.Range.create(2, 54, 2, 63));
        });
        it('works for multi-line', () => {
            chai_1.expect(file.findExtendsPosition(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene"
                    extends="BaseScene">
                </component>
            `)).to.eql(vscode_languageserver_1.Range.create(3, 29, 3, 38));
        });
        it('does not throw when unable to find extends', () => {
            file.findExtendsPosition(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="ChildScene">
                </component>
            `);
        });
        it('adds warning when no "extends" attribute is found', async () => {
            file = await program.addOrReplaceFile({
                src: `${rootDir}/components/comp1.xml`,
                dest: `components/comp1.xml`
            }, `
                    <?xml version="1.0" encoding="utf-8" ?>
                    <component name="ChildScene">
                    </component>
                `);
            chai_1.expect(file.getDiagnostics()[0]).to.include({
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                message: DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingExtendsAttribute().message
            });
        });
    });
    it('detects when importing the codebehind file unnecessarily', async () => {
        var _a;
        program = new Program_1.Program({
            autoImportComponentScript: true,
            rootDir: rootDir
        });
        await program.addOrReplaceFile({
            src: `${rootDir}/components/SimpleScene.bs`,
            dest: `components/SimpleScene.bs`
        }, '');
        await program.addOrReplaceFile({
            src: `${rootDir}/components/SimpleScene.xml`,
            dest: `components/SimpleScene.xml`
        }, `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="SimpleScene" extends="Scene">
                <script type="text/brighterscript" uri="SimpleScene.bs" />
            </component>
        `);
        await program.validate();
        chai_1.expect((_a = program.getDiagnostics()[0]) === null || _a === void 0 ? void 0 : _a.message).to.equal(DiagnosticMessages_1.DiagnosticMessages.unnecessaryCodebehindScriptImport().message);
    });
    describe('transpile', () => {
        it('changes file extensions to brs from bs', async () => {
            await program.addOrReplaceFile(`components/SimpleScene.bs`, `
                import "pkg:/source/lib.bs"
            `);
            await program.addOrReplaceFile('source/lib.bs', ``);
            await testTranspile(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="SimpleScene" extends="Scene">
                    <script type="text/brighterscript" uri="SimpleScene.bs"/>
                </component>
            `, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="SimpleScene" extends="Scene">
                    <script type="text/brightscript" uri="SimpleScene.brs"/>
                    <script type="text/brightscript" uri="pkg:/source/lib.brs" />
                    <script type="text/brightscript" uri="pkg:/source/bslib.brs" />
                </component>
            `, 'none', 'components/SimpleScene.xml');
        });
    });
    describe('Transform plugins', () => {
        async function parseFileWithPlugins(validateXml) {
            const rootDir = process.cwd();
            const program = new Program_1.Program({
                rootDir: rootDir
            });
            file = new XmlFile_1.XmlFile('abs', 'rel', program);
            program.plugins.add({
                name: 'Transform plugins',
                afterFileParse: () => validateXml(file)
            });
            await file.parse(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Cmp1" extends="Scene">
                </component>
            `);
            return file;
        }
        it('Calls XML file validation plugins', async () => {
            const validateXml = sinon.spy();
            const file = await parseFileWithPlugins(validateXml);
            chai_1.expect(validateXml.callCount).to.equal(1);
            chai_1.expect(validateXml.calledWith(file)).to.be.true;
        });
    });
    it('plugin diagnostics work for xml files', async () => {
        program.plugins.add({
            name: 'Xml diagnostic test',
            afterFileParse: (file) => {
                if (file.pathAbsolute.endsWith('.xml')) {
                    file.addDiagnostics([{
                            file: file,
                            message: 'Test diagnostic',
                            range: vscode_languageserver_1.Range.create(0, 0, 0, 0),
                            code: 9999
                        }]);
                }
            }
        });
        await program.addOrReplaceFile('components/comp.xml', `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="Cmp1" extends="Scene">
            </component>
        `);
        await program.validate();
        chai_1.expect(program.getDiagnostics().map(x => ({ message: x.message, code: x.code }))).to.eql([{
                message: 'Test diagnostic',
                code: 9999
            }]);
    });
    describe('typedef', () => {
        it('loads `d.bs` files into scope', async () => {
            const xmlFile = await program.addOrReplaceFile('components/Component1.xml', `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Component1" extends="Scene">
                    <script uri="Component1.brs" />
                </component>
            `);
            await program.addOrReplaceFile('components/Component1.d.bs', `
                sub logInfo()
                end sub
            `);
            chai_1.expect(program.getScopesForFile(xmlFile)[0].getAllCallables().map(x => x.callable.name)).to.include('logInfo');
        });
        it('does not include `d.bs` script during transpile', async () => {
            await program.addOrReplaceFile('source/logger.d.bs', `
                sub logInfo()
                end sub
            `);
            await program.addOrReplaceFile('source/logger.brs', `
                sub logInfo()
                end sub
            `);
            await program.addOrReplaceFile('components/Component1.bs', `
                import "pkg:/source/logger.brs"
                sub logInfo()
                end sub
            `);
            await testTranspile(`
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Component1" extends="Scene">
                    <script type="text/brighterscript" uri="Component1.bs" />
                </component>
            `, `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Component1" extends="Scene">
                    <script type="text/brightscript" uri="Component1.brs" />
                    <script type="text/brightscript" uri="pkg:/source/logger.brs" />
                    <script type="text/brightscript" uri="pkg:/source/bslib.brs" />
                </component>
            `, 'none', 'components/Component1.xml');
        });
        it('does not load .brs information into scope if related d.bs is in scope', async () => {
            const xmlFile = await program.addOrReplaceFile('components/Component1.xml', `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Component1" extends="Scene">
                    <script uri="Component1.brs" />
                </component>
            `);
            const scope = program.getScopesForFile(xmlFile)[0];
            //load brs file
            await program.addOrReplaceFile('components/Component1.brs', `
                sub logInfo()
                end sub
                sub logWarning()
                end sub
            `);
            let functionNames = scope.getAllCallables().map(x => x.callable.name);
            chai_1.expect(functionNames).to.include('logInfo');
            chai_1.expect(functionNames).to.include('logWarning');
            //load d.bs file, which should shadow out the .brs file
            await program.addOrReplaceFile('components/Component1.d.bs', `
                sub logError()
                end sub
            `);
            functionNames = scope.getAllCallables().map(x => x.callable.name);
            chai_1.expect(functionNames).to.include('logError');
            chai_1.expect(functionNames).not.to.include('logInfo');
            chai_1.expect(functionNames).not.to.include('logWarning');
        });
        it('updates xml scope when typedef disappears', async () => {
            const xmlFile = await program.addOrReplaceFile('components/Component1.xml', `
                <?xml version="1.0" encoding="utf-8" ?>
                <component name="Component1" extends="Scene">
                    <script uri="Component1.brs" />
                </component>
            `);
            const scope = program.getScopesForFile(xmlFile)[0];
            //load brs file
            await program.addOrReplaceFile('components/Component1.brs', `
                sub logBrs()
                end sub
            `);
            //load d.bs file, which should shadow out the .brs file
            const typedef = await program.addOrReplaceFile('components/Component1.d.bs', `
                sub logTypedef()
                end sub
            `);
            await program.validate();
            let functionNames = scope.getOwnCallables().map(x => x.callable.name);
            chai_1.expect(functionNames).to.include('logTypedef');
            chai_1.expect(functionNames).not.to.include('logBrs');
            //remove the typdef file
            program.removeFile(typedef.pathAbsolute);
            await program.validate();
            functionNames = scope.getOwnCallables().map(x => x.callable.name);
            chai_1.expect(functionNames).not.to.include('logTypedef');
            chai_1.expect(functionNames).to.include('logBrs');
        });
    });
    it('finds script imports for single-quoted script tags', async () => {
        var _a;
        const file = await program.addOrReplaceFile('components/file.xml', `
            <?xml version="1.0" encoding="utf-8" ?>
            <component name="Cmp1" extends="Scene">
                <script uri='SingleQuotedFile.brs' />
            </component>
        `);
        chai_1.expect((_a = file.scriptTagImports[0]) === null || _a === void 0 ? void 0 : _a.text).to.eql('SingleQuotedFile.brs');
    });
});
//# sourceMappingURL=XmlFile.spec.js.map