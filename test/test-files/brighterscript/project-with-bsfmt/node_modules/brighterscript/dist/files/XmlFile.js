"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlFile = void 0;
const path = require("path");
const source_map_1 = require("source-map");
const deferred_1 = require("../deferred");
const DiagnosticMessages_1 = require("../DiagnosticMessages");
const util_1 = require("../util");
const Parser_1 = require("../parser/Parser");
const chalk_1 = require("chalk");
const Cache_1 = require("../Cache");
const extname = require("path-complete-extname");
class XmlFile {
    constructor(pathAbsolute, 
    /**
     * The absolute path to the file, relative to the pkg
     */
    pkgPath, program) {
        this.pathAbsolute = pathAbsolute;
        this.pkgPath = pkgPath;
        this.program = program;
        this.cache = new Cache_1.Cache();
        /**
         * If the file was given type definitions during parse. XML files never have a typedef
         */
        this.hasTypedef = false;
        /**
         * The list of script imports delcared in the XML of this file.
         * This excludes parent imports and auto codebehind imports
         */
        this.scriptTagImports = [];
        this.diagnostics = [];
        this.parser = new Parser_1.Parser();
        //TODO implement the xml CDATA parsing, which would populate this list
        this.callables = [];
        //TODO implement the xml CDATA parsing, which would populate this list
        this.functionCalls = [];
        this.functionScopes = [];
        /**
         * Does this file need to be transpiled?
         */
        this.needsTranspiled = false;
        /**
         * TODO: do we need this for xml files?
         */
        this.propertyNameCompletions = [];
        this.uriRangeRegex = /(.*?\s+uri\s*=\s*(?:'|"))(.*?)(?:'|")/g;
        this.scriptTypeRegex = /type\s*=\s*"(.*?)"/gi;
        this.parseDeferred = new deferred_1.Deferred();
        this.extension = path.extname(pathAbsolute).toLowerCase();
        this.possibleCodebehindPkgPaths = [
            this.pkgPath.replace('.xml', '.bs'),
            this.pkgPath.replace('.xml', '.brs')
        ];
    }
    /**
     * List of all pkgPaths to scripts that this XmlFile depends on directly, regardless of whether they are loaded in the program or not.
     * This does not account for parent component scripts
     * coming from:
     *  - script tags
     *  - implied codebehind file
     *  - import statements from imported scripts or their descendents
     */
    getAllDependencies() {
        return this.cache.getOrAdd(`allScriptImports`, () => {
            let value = this.program.dependencyGraph.getAllDependencies(this.dependencyGraphKey, [this.parentComponentDependencyGraphKey]);
            return value;
        });
    }
    /**
     * List of all pkgPaths to scripts that this XmlFile depends on that are actually loaded into the program.
     * This does not account for parent component scripts.
     * coming from:
     *  - script tags
     *  - inferred codebehind file
     *  - import statements from imported scripts or their descendants
     */
    getAvailableScriptImports() {
        return this.cache.getOrAdd('allAvailableScriptImports', () => {
            let allDependencies = this.getAllDependencies()
                //skip typedef files
                .filter(x => extname(x) !== '.d.bs');
            let result = [];
            let filesInProgram = this.program.getFilesByPkgPaths(allDependencies);
            for (let file of filesInProgram) {
                result.push(file.pkgPath);
            }
            this.logDebug('computed allAvailableScriptImports', () => result);
            return result;
        });
    }
    getDiagnostics() {
        return [...this.diagnostics];
    }
    addDiagnostics(diagnostics) {
        this.diagnostics.push(...diagnostics);
    }
    async parse(fileContents) {
        var _a;
        this.fileContents = fileContents;
        if (this.parseDeferred.isCompleted) {
            throw new Error(`File was already processed. Create a new file instead. ${this.pathAbsolute}`);
        }
        //split the text into lines
        this.lines = util_1.default.getLines(fileContents);
        this.parentNameRange = this.findExtendsPosition(fileContents);
        //create a range of the entire file
        this.fileRange = util_1.default.createRange(0, 0, this.lines.length, this.lines[this.lines.length - 1].length - 1);
        this.parsedXml = {};
        try {
            this.parsedXml = (await util_1.default.parseXml(fileContents)) || {};
            //notify AST ready
            this.program.plugins.emit('afterFileParse', this);
            if (this.parsedXml.component) {
                if (this.parsedXml.component.$) {
                    this.componentName = this.parsedXml.component.$.name;
                    this.parentComponentName = this.parsedXml.component.$.extends;
                }
                let componentRange;
                //find the range for the component element's opening tag
                for (let lineIndex = 0; lineIndex < this.lines.length; lineIndex++) {
                    let idx = this.lines[lineIndex].indexOf('<component');
                    if (idx > -1) {
                        componentRange = util_1.default.createRange(lineIndex, idx, lineIndex, idx + 10);
                        //calculate the range of the component's name (if it exists)
                        const match = /(.*?name\s*=\s*(?:'|"))(.*?)('|")/.exec(this.lines[lineIndex]);
                        if (match) {
                            this.componentNameRange = util_1.default.createRange(lineIndex, match[1].length, lineIndex, match[1].length + match[2].length);
                        }
                        break;
                    }
                }
                //component name not defined
                if (!this.componentName) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingNameAttribute()), { range: util_1.default.createRange(componentRange.start.line, componentRange.start.character, componentRange.start.line, componentRange.end.character), file: this }));
                }
                //parent component name not defined
                if (!this.parentComponentName) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingExtendsAttribute()), { range: util_1.default.createRange(componentRange.start.line, componentRange.start.character, componentRange.start.line, componentRange.end.character), file: this }));
                }
            }
            else {
                //the component xml element was not found in the file
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.xmlComponentMissingComponentDeclaration()), { range: util_1.default.createRange(0, 0, 0, Number.MAX_VALUE), file: this }));
            }
        }
        catch (e) {
            let match = /(.*)\r?\nLine:\s*(\d+)\r?\nColumn:\s*(\d+)\r?\nChar:\s*(\d*)/gi.exec(e.message);
            if (match) {
                let lineIndex = parseInt(match[2]);
                let columnIndex = parseInt(match[3]) - 1;
                //add basic xml parse diagnostic errors
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.xmlGenericParseError(match[1])), { range: util_1.default.createRange(lineIndex, columnIndex, lineIndex, columnIndex), file: this }));
            }
        }
        //find script imports
        if (this.parsedXml.component) {
            let scripts = this.parsedXml.component.script || [];
            let scriptImports = [];
            //get a list of all scripts
            for (let script of scripts) {
                let uri = (_a = script.$) === null || _a === void 0 ? void 0 : _a.uri;
                if (typeof uri === 'string') {
                    scriptImports.push({
                        filePathRange: null,
                        sourceFile: this,
                        text: uri,
                        pkgPath: util_1.default.getPkgPathFromTarget(this.pkgPath, uri)
                    });
                }
            }
            //make a lookup of every uri range
            let uriRanges = {};
            for (let lineIndex = 0; lineIndex < this.lines.length; lineIndex++) {
                let line = this.lines[lineIndex];
                //reset the regexes
                this.uriRangeRegex.lastIndex = 0;
                this.scriptTypeRegex.lastIndex = 0;
                let lineIndexOffset = 0;
                let match;
                while (match = this.uriRangeRegex.exec(line)) { //eslint-disable-line no-cond-assign
                    let preUriContent = match[1];
                    let uri = match[2];
                    if (!uriRanges[uri]) {
                        uriRanges[uri] = [];
                    }
                    let startColumnIndex = lineIndexOffset + preUriContent.length;
                    let endColumnIndex = startColumnIndex + uri.length;
                    uriRanges[uri].push(util_1.default.createRange(lineIndex, startColumnIndex, lineIndex, endColumnIndex));
                    lineIndexOffset += match[0].length;
                }
            }
            //try to compute the locations of each script import
            for (let scriptImport of scriptImports) {
                //take and remove the first item from the list
                let range = uriRanges[scriptImport.text].shift();
                scriptImport.filePathRange = range;
            }
            //add all of these script imports
            this.scriptTagImports = scriptImports;
        }
        //catch script imports with same path as the auto-imported codebehind file
        let explicitCodebehindScriptTag = this.program.options.autoImportComponentScript === true
            ? this.scriptTagImports.find(x => this.possibleCodebehindPkgPaths.includes(x.pkgPath))
            : undefined;
        if (explicitCodebehindScriptTag) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unnecessaryCodebehindScriptImport()), { file: this, range: explicitCodebehindScriptTag.filePathRange }));
        }
        this.parseDeferred.resolve();
    }
    /**
     * Attach the file to the dependency graph so it can monitor changes.
     * Also notify the dependency graph of our current dependencies so other dependents can be notified.
     */
    attachDependencyGraph(dependencyGraph) {
        if (this.unsubscribeFromDependencyGraph) {
            this.unsubscribeFromDependencyGraph();
        }
        //anytime a dependency changes, clean up some cached values
        this.unsubscribeFromDependencyGraph = this.program.dependencyGraph.onchange(this.dependencyGraphKey, () => {
            this.logDebug('clear cache because dependency graph changed');
            this.cache.clear();
        });
        let dependencies = [
            ...this.scriptTagImports.map(x => x.pkgPath.toLowerCase())
        ];
        //if autoImportComponentScript is enabled, add the .bs and .brs files with the same name
        if (this.program.options.autoImportComponentScript) {
            dependencies.push(
            //add the codebehind file dependencies.
            //These are kind of optional, so it doesn't hurt to just add both extension versions
            this.pkgPath.replace(/\.xml$/i, '.bs').toLowerCase(), this.pkgPath.replace(/\.xml$/i, '.brs').toLowerCase());
        }
        const len = dependencies.length;
        for (let i = 0; i < len; i++) {
            const dep = dependencies[i];
            //add a dependency on `d.bs` file for every `.brs` file
            if (dep.slice(-4).toLowerCase() === '.brs') {
                dependencies.push(util_1.default.getTypedefPath(dep));
            }
        }
        if (this.parentComponentName) {
            dependencies.push(this.parentComponentDependencyGraphKey);
        }
        this.program.dependencyGraph.addOrReplace(this.dependencyGraphKey, dependencies);
    }
    /**
     * The key used in the dependency graph for this file.
     * If we have a component name, we will use that so we can be discoverable by child components.
     * If we don't have a component name, use the pkgPath so at least we can self-validate
     */
    get dependencyGraphKey() {
        if (this.componentName) {
            return `component:${this.componentName}`.toLowerCase();
        }
        else {
            return this.pkgPath.toLowerCase();
        }
    }
    /**
     * The key used in the dependency graph for this component's parent.
     * If we have aparent, we will use that. If we don't, this will return undefined
     */
    get parentComponentDependencyGraphKey() {
        if (this.parentComponentName) {
            return `component:${this.parentComponentName}`.toLowerCase();
        }
        else {
            return undefined;
        }
    }
    /**
     * Indicates that the file is completely ready for interaction
     */
    isReady() {
        return this.parseDeferred.promise;
    }
    /**
     * Determines if this xml file has a reference to the specified file (or if it's itself)
     * @param file
     */
    doesReferenceFile(file) {
        return this.cache.getOrAdd(`doesReferenceFile: ${file.pkgPath}`, () => {
            if (file === this) {
                return true;
            }
            let allDependencies = this.getAllDependencies();
            for (let importPkgPath of allDependencies) {
                if (importPkgPath.toLowerCase() === file.pkgPath.toLowerCase()) {
                    return true;
                }
            }
            //if this is an xml file...do we extend the component it defines?
            if (path.extname(file.pkgPath).toLowerCase() === '.xml') {
                //didn't find any script imports for this file
                return false;
            }
            return false;
        });
    }
    /**
     * Get all available completions for the specified position
     * @param lineIndex
     * @param columnIndex
     */
    async getCompletions(position) {
        let scriptImport = util_1.default.getScriptImportAtPosition(this.scriptTagImports, position);
        if (scriptImport) {
            return this.program.getScriptImportCompletions(this.pkgPath, scriptImport);
        }
        else {
            return Promise.resolve([]);
        }
    }
    /**
     * Scan the xml and find the range of the parent component's name in the `extends="ParentComponentName"` attribute of the component
     */
    findExtendsPosition(fullText) {
        let regexp = /.*<component[^>]*((extends\s*=\s*")(\w*)")/gms;
        let match = regexp.exec(fullText);
        if (match) {
            let extendsText = match[1]; // `extends="something"`
            let extendsToFirstQuote = match[2]; // `extends="`
            let componentName = match[3]; // `something`
            let lines = util_1.default.getLines(match[0]);
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex];
                let extendsIdx = line.indexOf(extendsText);
                //we found the line index
                if (extendsIdx > -1) {
                    let colStartIndex = extendsIdx + extendsToFirstQuote.length;
                    let colEndIndex = colStartIndex + componentName.length;
                    return util_1.default.createRange(lineIndex, colStartIndex, lineIndex, colEndIndex);
                }
            }
        }
    }
    /**
     * Get the parent component (the component this component extends)
     */
    get parentComponent() {
        return this.cache.getOrAdd('parent', () => {
            var _a, _b;
            return (_b = (_a = this.program.getComponent(this.parentComponentName)) === null || _a === void 0 ? void 0 : _a.file) !== null && _b !== void 0 ? _b : null;
        });
    }
    getHover(position) {
        //TODO implement
        // let result = {} as Hover;
        return null;
    }
    getReferences(position) {
        //TODO implement
        return null;
    }
    getFunctionScopeAtPosition(position, functionScopes) {
        //TODO implement
        return null;
    }
    /**
     * Walk up the ancestor chain and aggregate all of the script tag imports
     */
    getAncestorScriptTagImports() {
        let result = [];
        let parent = this.parentComponent;
        while (parent) {
            result.push(...parent.scriptTagImports);
            parent = parent.parentComponent;
        }
        return result;
    }
    /**
     * Remove this file from the dependency graph as a node
     */
    detachDependencyGraph(dependencyGraph) {
        dependencyGraph.remove(this.dependencyGraphKey);
    }
    /**
     * Get the list of script imports that this file needs to include.
     * It compares the list of imports on this file to those of its parent,
     * and only includes the ones that are not found on the parent.
     * If no parent is found, all imports are returned
     */
    getMissingImportsForTranspile() {
        var _a, _b;
        let ownImports = this.getAvailableScriptImports();
        let parentImports = (_b = (_a = this.parentComponent) === null || _a === void 0 ? void 0 : _a.getAvailableScriptImports()) !== null && _b !== void 0 ? _b : [];
        let parentMap = parentImports.reduce((map, pkgPath) => {
            map[pkgPath] = true;
            return map;
        }, {});
        //if the XML already has this import, skip this one
        let alreadyThereScriptImportMap = this.scriptTagImports.reduce((map, fileReference) => {
            map[fileReference.pkgPath] = true;
            return map;
        }, {});
        let result = [];
        for (let ownImport of ownImports) {
            if (
            //if the parent doesn't have this import
            !parentMap[ownImport] &&
                //the XML doesn't already have a script reference for this
                !alreadyThereScriptImportMap[ownImport]) {
                result.push(ownImport);
            }
        }
        return result;
    }
    logDebug(...args) {
        this.program.logger.debug('XmlFile', chalk_1.default.green(this.pkgPath), ...args);
    }
    /**
     * Convert the brightscript/brighterscript source code into valid brightscript
     */
    transpile() {
        this.logDebug('transpile');
        //eventually we want to support sourcemaps and a full xml parser. However, for now just do some string transformations
        let chunks = [];
        for (let i = 0; i < this.lines.length; i++) {
            let line = this.lines[i];
            let lowerLine = line.toLowerCase();
            let componentLocationIndex = lowerLine.indexOf('</component>');
            //include any bs import statements
            if (componentLocationIndex > -1) {
                let missingImports = this.getMissingImportsForTranspile()
                    //change the file extension to .brs since they will be transpiled
                    .map(x => x.replace('.bs', '.brs'));
                //always include the bslib file
                missingImports.push('source/bslib.brs');
                for (let missingImport of missingImports) {
                    let scriptTag = `<script type="text/brightscript" uri="${util_1.default.getRokuPkgPath(missingImport)}" />`;
                    //indent the script tag
                    let indent = ''.padStart(componentLocationIndex + 4, ' ');
                    chunks.push('\n', new source_map_1.SourceNode(1, 0, this.pathAbsolute, indent + scriptTag));
                }
            }
            else {
                //we couldn't find the closing component tag....so maybe there's something wrong? or this isn't actually a component?
            }
            //convert .bs extensions to .brs
            let idx = line.indexOf('.bs"');
            if (idx > -1) {
                line = line.substring(0, idx) + '.brs' + line.substring(idx + 3);
            }
            //convert "text/brighterscript" to "text/brightscript"
            line = line.replace(`"text/brighterscript"`, `"text/brightscript"`);
            chunks.push(chunks.length > 0 ? '\n' : '', line);
        }
        return new source_map_1.SourceNode(null, null, this.pathAbsolute, chunks).toStringWithSourceMap();
    }
    dispose() {
        if (this.unsubscribeFromDependencyGraph) {
            this.unsubscribeFromDependencyGraph();
        }
    }
}
exports.XmlFile = XmlFile;
//# sourceMappingURL=XmlFile.js.map