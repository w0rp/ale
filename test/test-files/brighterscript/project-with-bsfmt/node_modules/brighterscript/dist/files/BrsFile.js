"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeywordCompletions = exports.BrsFile = void 0;
const source_map_1 = require("source-map");
const vscode_languageserver_1 = require("vscode-languageserver");
const chalk_1 = require("chalk");
const DiagnosticMessages_1 = require("../DiagnosticMessages");
const FunctionScope_1 = require("../FunctionScope");
const deferred_1 = require("../deferred");
const lexer_1 = require("../lexer");
const parser_1 = require("../parser");
const DynamicType_1 = require("../types/DynamicType");
const FunctionType_1 = require("../types/FunctionType");
const VoidType_1 = require("../types/VoidType");
const util_1 = require("../util");
const TranspileState_1 = require("../parser/TranspileState");
const Preprocessor_1 = require("../preprocessor/Preprocessor");
const Logger_1 = require("../Logger");
const serialize_error_1 = require("serialize-error");
const reflection_1 = require("../astUtils/reflection");
const visitors_1 = require("../astUtils/visitors");
const extname = require("path-complete-extname");
/**
 * Holds all details about this file within the scope of the whole program
 */
class BrsFile {
    constructor(pathAbsolute, 
    /**
     * The full pkg path to this file
     */
    pkgPath, program) {
        this.pathAbsolute = pathAbsolute;
        this.pkgPath = pkgPath;
        this.program = program;
        this.parseDeferred = new deferred_1.Deferred();
        this.diagnostics = [];
        this.commentFlags = [];
        this.callables = [];
        this.functionCalls = [];
        /**
         * files referenced by import statements
         */
        this.ownScriptImports = [];
        /**
         * Does this file need to be transpiled?
         */
        this.needsTranspiled = false;
        this.scopesByFunc = new Map();
        this.pathAbsolute = util_1.standardizePath `${this.pathAbsolute}`;
        this.pkgPath = util_1.standardizePath `${this.pkgPath}`;
        this.dependencyGraphKey = this.pkgPath.toLowerCase();
        this.extension = extname(this.pkgPath).toLowerCase();
        //all BrighterScript files need to be transpiled
        if (this.extension.endsWith('.bs')) {
            this.needsTranspiled = true;
        }
        this.isTypedef = this.extension === '.d.bs';
        if (!this.isTypedef) {
            this.typedefKey = util_1.util.getTypedefPath(this.pathAbsolute);
        }
        //global file doesn't have a program, so only resolve typedef info if we have a program
        if (this.program) {
            this.resolveTypdef();
        }
    }
    /**
     * The parseMode used for the parser for this file
     */
    get parseMode() {
        return this.extension.endsWith('.bs') ? parser_1.ParseMode.BrighterScript : parser_1.ParseMode.BrightScript;
    }
    /**
     * Indicates that the file is completely ready for interaction
     */
    isReady() {
        return this.parseDeferred.promise;
    }
    getDiagnostics() {
        return [...this.diagnostics];
    }
    addDiagnostics(diagnostics) {
        this.diagnostics.push(...diagnostics);
    }
    get functionScopes() {
        if (!this._functionScopes) {
            this.createFunctionScopes();
        }
        return this._functionScopes;
    }
    /**
     * The AST for this file
     */
    get ast() {
        return this.parser.ast;
    }
    /**
     * Get the token at the specified position
     * @param position
     */
    getTokenAt(position) {
        for (let token of this.parser.tokens) {
            if (util_1.util.rangeContains(token.range, position)) {
                return token;
            }
        }
    }
    get parser() {
        if (!this._parser) {
            //remove the typedef file (if it exists)
            this.hasTypedef = false;
            this.typedefFile = undefined;
            //reset the deferred
            this.parseDeferred = new deferred_1.Deferred();
            //parse the file (it should parse fully since there's no linked typedef
            this.parse(this.fileContents);
            //re-link the typedef (if it exists...which it should)
            this.resolveTypdef();
        }
        return this._parser;
    }
    /**
     * Find and set the typedef variables (if a matching typedef file exists)
     */
    resolveTypdef() {
        this.typedefFile = this.program.getFileByPathAbsolute(this.typedefKey);
        this.hasTypedef = !!this.typedefFile;
    }
    /**
     * Attach the file to the dependency graph so it can monitor changes.
     * Also notify the dependency graph of our current dependencies so other dependents can be notified.
     */
    attachDependencyGraph(dependencyGraph) {
        if (this.unsubscribeFromDependencyGraph) {
            this.unsubscribeFromDependencyGraph();
        }
        //event that fires anytime a dependency changes
        this.unsubscribeFromDependencyGraph = this.program.dependencyGraph.onchange(this.dependencyGraphKey, () => {
            this.resolveTypdef();
        });
        const dependencies = this.ownScriptImports.filter(x => !!x.pkgPath).map(x => x.pkgPath.toLowerCase());
        //if this is a .brs file, watch for typedef changes
        if (this.extension === '.brs') {
            dependencies.push(util_1.util.getTypedefPath(this.pkgPath));
        }
        dependencyGraph.addOrReplace(this.dependencyGraphKey, dependencies);
    }
    /**
     * Calculate the AST for this file
     * @param fileContents
     */
    parse(fileContents) {
        try {
            this.fileContents = fileContents;
            if (this.parseDeferred.isCompleted) {
                throw new Error(`File was already processed. Create a new instance of BrsFile instead. ${this.pathAbsolute}`);
            }
            //if we have a typedef file, skip parsing this file
            if (this.hasTypedef) {
                this.parseDeferred.resolve();
                return;
            }
            //tokenize the input file
            let lexer = this.program.logger.time(Logger_1.LogLevel.debug, ['lexer.lex', chalk_1.default.green(this.pathAbsolute)], () => {
                return lexer_1.Lexer.scan(fileContents, {
                    includeWhitespace: false
                });
            });
            this.getIgnores(lexer.tokens);
            let preprocessor = new Preprocessor_1.Preprocessor();
            //remove all code inside false-resolved conditional compilation statements.
            //TODO preprocessor should go away in favor of the AST handling this internally (because it affects transpile)
            //currently the preprocessor throws exceptions on syntax errors...so we need to catch it
            try {
                this.program.logger.time(Logger_1.LogLevel.debug, ['preprocessor.process', chalk_1.default.green(this.pathAbsolute)], () => {
                    preprocessor.process(lexer.tokens, this.program.getManifest());
                });
            }
            catch (error) {
                //if the thrown error is DIFFERENT than any errors from the preprocessor, add that error to the list as well
                if (this.diagnostics.find((x) => x === error) === undefined) {
                    this.diagnostics.push(error);
                }
            }
            //if the preprocessor generated tokens, use them.
            let tokens = preprocessor.processedTokens.length > 0 ? preprocessor.processedTokens : lexer.tokens;
            this.program.logger.time(Logger_1.LogLevel.debug, ['parser.parse', chalk_1.default.green(this.pathAbsolute)], () => {
                this._parser = parser_1.Parser.parse(tokens, {
                    mode: this.parseMode,
                    logger: this.program.logger
                });
            });
            //absorb all lexing/preprocessing/parsing diagnostics
            this.diagnostics.push(...lexer.diagnostics, ...preprocessor.diagnostics, ...this._parser.diagnostics);
            //notify AST ready
            this.program.plugins.emit('afterFileParse', this);
            //extract all callables from this file
            this.findCallables();
            //find all places where a sub/function is being called
            this.findFunctionCalls();
            this.findAndValidateImportAndImportStatements();
            //attach this file to every diagnostic
            for (let diagnostic of this.diagnostics) {
                diagnostic.file = this;
            }
        }
        catch (e) {
            this._parser = new parser_1.Parser();
            this.diagnostics.push(Object.assign({ file: this, range: util_1.util.createRange(0, 0, 0, Number.MAX_VALUE) }, DiagnosticMessages_1.DiagnosticMessages.genericParserMessage('Critical error parsing file: ' + JSON.stringify(serialize_error_1.serializeError(e)))));
        }
        this.parseDeferred.resolve();
    }
    findAndValidateImportAndImportStatements() {
        var _a;
        let topOfFileIncludeStatements = [];
        for (let stmt of this.ast.statements) {
            //skip comments
            if (reflection_1.isCommentStatement(stmt)) {
                continue;
            }
            //if we found a non-library statement, this statement is not at the top of the file
            if (reflection_1.isLibraryStatement(stmt) || reflection_1.isImportStatement(stmt)) {
                topOfFileIncludeStatements.push(stmt);
            }
            else {
                //break out of the loop, we found all of our library statements
                break;
            }
        }
        let statements = [
            ...this._parser.references.libraryStatements,
            ...this._parser.references.importStatements
        ];
        for (let result of statements) {
            //register import statements
            if (reflection_1.isImportStatement(result) && result.filePathToken) {
                this.ownScriptImports.push({
                    filePathRange: result.filePathToken.range,
                    pkgPath: util_1.util.getPkgPathFromTarget(this.pkgPath, result.filePath),
                    sourceFile: this,
                    text: (_a = result.filePathToken) === null || _a === void 0 ? void 0 : _a.text
                });
            }
            //if this statement is not one of the top-of-file statements,
            //then add a diagnostic explaining that it is invalid
            if (!topOfFileIncludeStatements.includes(result)) {
                if (reflection_1.isLibraryStatement(result)) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.libraryStatementMustBeDeclaredAtTopOfFile()), { range: result.range, file: this }));
                }
                else if (reflection_1.isImportStatement(result)) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.importStatementMustBeDeclaredAtTopOfFile()), { range: result.range, file: this }));
                }
            }
        }
    }
    /**
     * Find a class by its full namespace-prefixed name.
     * Returns undefined if not found.
     * @param namespaceName - the namespace to resolve relative classes from.
     */
    getClassByName(className, namespaceName) {
        let scopes = this.program.getScopesForFile(this);
        let lowerClassName = className.toLowerCase();
        //if the class is namespace-prefixed, look only for this exact name
        if (className.includes('.')) {
            for (let scope of scopes) {
                const cls = scope.getClass(lowerClassName);
                if (cls) {
                    return cls;
                }
            }
            //we have a class name without a namespace prefix.
        }
        else {
            let globalClass;
            let namespacedClass;
            for (let scope of scopes) {
                //get the global class if it exists
                let possibleGlobalClass = scope.getClass(lowerClassName);
                if (possibleGlobalClass && !globalClass) {
                    globalClass = possibleGlobalClass;
                }
                if (namespaceName) {
                    let possibleNamespacedClass = scope.getClass(namespaceName.toLowerCase() + '.' + lowerClassName);
                    if (possibleNamespacedClass) {
                        namespacedClass = possibleNamespacedClass;
                        break;
                    }
                }
            }
            if (namespacedClass) {
                return namespacedClass;
            }
            else if (globalClass) {
                return globalClass;
            }
        }
    }
    findPropertyNameCompletions() {
        //Build completion items from all the "properties" found in the file
        const { propertyHints } = this.parser.references;
        const results = [];
        for (const key of Object.keys(propertyHints)) {
            results.push({
                label: propertyHints[key],
                kind: vscode_languageserver_1.CompletionItemKind.Text
            });
        }
        return results;
    }
    get propertyNameCompletions() {
        if (!this._propertyNameCompletions) {
            this._propertyNameCompletions = this.findPropertyNameCompletions();
        }
        return this._propertyNameCompletions;
    }
    /**
     * Find all comment flags in the source code. These enable or disable diagnostic messages.
     * @param lines - the lines of the program
     */
    getIgnores(tokens) {
        //TODO use the comment statements found in the AST for this instead of text search
        let allCodesExcept1014 = DiagnosticMessages_1.diagnosticCodes.filter((x) => x !== DiagnosticMessages_1.DiagnosticMessages.unknownDiagnosticCode(0).code);
        this.commentFlags = [];
        for (let token of tokens) {
            let tokenized = util_1.util.tokenizeBsDisableComment(token);
            if (!tokenized) {
                continue;
            }
            let affectedRange;
            if (tokenized.disableType === 'line') {
                affectedRange = util_1.util.createRange(token.range.start.line, 0, token.range.start.line, token.range.start.character);
            }
            else if (tokenized.disableType === 'next-line') {
                affectedRange = util_1.util.createRange(token.range.start.line + 1, 0, token.range.start.line + 1, Number.MAX_SAFE_INTEGER);
            }
            let commentFlag;
            //statement to disable EVERYTHING
            if (tokenized.codes.length === 0) {
                commentFlag = {
                    file: this,
                    //null means all codes
                    codes: null,
                    range: token.range,
                    affectedRange: affectedRange
                };
                //disable specific diagnostic codes
            }
            else {
                let codes = [];
                for (let codeToken of tokenized.codes) {
                    let codeInt = parseInt(codeToken.code);
                    //add a warning for unknown codes
                    if (DiagnosticMessages_1.diagnosticCodes.includes(codeInt)) {
                        codes.push(codeInt);
                    }
                    else {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unknownDiagnosticCode(codeInt)), { file: this, range: codeToken.range }));
                    }
                }
                if (codes.length > 0) {
                    commentFlag = {
                        file: this,
                        codes: codes,
                        range: token.range,
                        affectedRange: affectedRange
                    };
                }
            }
            if (commentFlag) {
                this.commentFlags.push(commentFlag);
                //add an ignore for everything in this comment except for Unknown_diagnostic_code_1014
                this.commentFlags.push({
                    affectedRange: commentFlag.range,
                    range: commentFlag.range,
                    codes: allCodesExcept1014,
                    file: this
                });
            }
        }
    }
    /**
     * Create a scope for every function in this file
     */
    createFunctionScopes() {
        //find every function
        let functions = this.parser.references.functionExpressions;
        //create a functionScope for every function
        this._functionScopes = [];
        for (let func of functions) {
            let scope = new FunctionScope_1.FunctionScope(func);
            //find parent function, and add this scope to it if found
            {
                let parentScope = this.scopesByFunc.get(func.parentFunction);
                //add this child scope to its parent
                if (parentScope) {
                    parentScope.childrenScopes.push(scope);
                }
                //store the parent scope for this scope
                scope.parentScope = parentScope;
            }
            //add every parameter
            for (let param of func.parameters) {
                scope.variableDeclarations.push({
                    nameRange: param.name.range,
                    lineIndex: param.name.range.start.line,
                    name: param.name.text,
                    type: param.type
                });
            }
            this.scopesByFunc.set(func, scope);
            //find every statement in the scope
            this._functionScopes.push(scope);
        }
        //find every variable assignment in the whole file
        let assignmentStatements = this.parser.references.assignmentStatements;
        for (let statement of assignmentStatements) {
            //find this statement's function scope
            let scope = this.scopesByFunc.get(statement.containingFunction);
            //skip variable declarations that are outside of any scope
            if (scope) {
                scope.variableDeclarations.push({
                    nameRange: statement.name.range,
                    lineIndex: statement.name.range.start.line,
                    name: statement.name.text,
                    type: this.getBscTypeFromAssignment(statement, scope)
                });
            }
        }
    }
    getBscTypeFromAssignment(assignment, scope) {
        try {
            //function
            if (reflection_1.isFunctionExpression(assignment.value)) {
                let functionType = new FunctionType_1.FunctionType(assignment.value.returnType);
                functionType.isSub = assignment.value.functionType.text === 'sub';
                if (functionType.isSub) {
                    functionType.returnType = new VoidType_1.VoidType();
                }
                functionType.setName(assignment.name.text);
                for (let param of assignment.value.parameters) {
                    let isRequired = !param.defaultValue;
                    //TODO compute optional parameters
                    functionType.addParameter(param.name.text, param.type, isRequired);
                }
                return functionType;
                //literal
            }
            else if (reflection_1.isLiteralExpression(assignment.value)) {
                return assignment.value.type;
                //function call
            }
            else if (reflection_1.isCallExpression(assignment.value)) {
                let calleeName = assignment.value.callee.name.text;
                if (calleeName) {
                    let func = this.getCallableByName(calleeName);
                    if (func) {
                        return func.type.returnType;
                    }
                }
            }
            else if (reflection_1.isVariableExpression(assignment.value)) {
                let variableName = assignment.value.name.text;
                let variable = scope.getVariableByName(variableName);
                return variable.type;
            }
        }
        catch (e) {
            //do nothing. Just return dynamic
        }
        //fallback to dynamic
        return new DynamicType_1.DynamicType();
    }
    getCallableByName(name) {
        name = name ? name.toLowerCase() : undefined;
        if (!name) {
            return;
        }
        for (let func of this.callables) {
            if (func.name.toLowerCase() === name) {
                return func;
            }
        }
    }
    findCallables() {
        var _a;
        for (let statement of (_a = this.parser.references.functionStatements) !== null && _a !== void 0 ? _a : []) {
            let functionType = new FunctionType_1.FunctionType(statement.func.returnType);
            functionType.setName(statement.name.text);
            functionType.isSub = statement.func.functionType.text.toLowerCase() === 'sub';
            if (functionType.isSub) {
                functionType.returnType = new VoidType_1.VoidType();
            }
            //extract the parameters
            let params = [];
            for (let param of statement.func.parameters) {
                let callableParam = {
                    name: param.name.text,
                    type: param.type,
                    isOptional: !!param.defaultValue,
                    isRestArgument: false
                };
                params.push(callableParam);
                let isRequired = !param.defaultValue;
                functionType.addParameter(callableParam.name, callableParam.type, isRequired);
            }
            this.callables.push({
                isSub: statement.func.functionType.text.toLowerCase() === 'sub',
                name: statement.name.text,
                nameRange: statement.name.range,
                file: this,
                params: params,
                range: statement.func.range,
                type: functionType,
                getName: statement.getName.bind(statement),
                hasNamespace: !!statement.namespaceName,
                functionStatement: statement
            });
        }
    }
    findFunctionCalls() {
        this.functionCalls = [];
        //for every function in the file
        for (let func of this._parser.references.functionExpressions) {
            //for all function calls in this function
            for (let expression of func.callExpressions) {
                if (
                //filter out dotted function invocations (i.e. object.doSomething()) (not currently supported. TODO support it)
                expression.callee.obj ||
                    //filter out method calls on method calls for now (i.e. getSomething().getSomethingElse())
                    expression.callee.callee) {
                    continue;
                }
                let functionName = expression.callee.name.text;
                //callee is the name of the function being called
                let callee = expression.callee;
                let columnIndexBegin = callee.range.start.character;
                let columnIndexEnd = callee.range.end.character;
                let args = [];
                //TODO convert if stmts to use instanceof instead
                for (let arg of expression.args) {
                    //is a literal parameter value
                    if (reflection_1.isLiteralExpression(arg)) {
                        args.push({
                            range: arg.range,
                            type: arg.type,
                            text: arg.token.text
                        });
                        //is variable being passed into argument
                    }
                    else if (arg.name) {
                        args.push({
                            range: arg.range,
                            //TODO - look up the data type of the actual variable
                            type: new DynamicType_1.DynamicType(),
                            text: arg.name.text
                        });
                    }
                    else if (arg.value) {
                        let text = '';
                        /* istanbul ignore next: TODO figure out why value is undefined sometimes */
                        if (arg.value.value) {
                            text = arg.value.value.toString();
                        }
                        let callableArg = {
                            range: arg.range,
                            //TODO not sure what to do here
                            type: new DynamicType_1.DynamicType(),
                            text: text
                        };
                        //wrap the value in quotes because that's how it appears in the code
                        if (reflection_1.isStringType(callableArg.type)) {
                            callableArg.text = '"' + callableArg.text + '"';
                        }
                        args.push(callableArg);
                    }
                    else {
                        args.push({
                            range: arg.range,
                            type: new DynamicType_1.DynamicType(),
                            //TODO get text from other types of args
                            text: ''
                        });
                    }
                }
                let functionCall = {
                    range: util_1.util.createRangeFromPositions(expression.range.start, expression.closingParen.range.end),
                    functionScope: this.getFunctionScopeAtPosition(callee.range.start),
                    file: this,
                    name: functionName,
                    nameRange: util_1.util.createRange(callee.range.start.line, columnIndexBegin, callee.range.start.line, columnIndexEnd),
                    //TODO keep track of parameters
                    args: args
                };
                this.functionCalls.push(functionCall);
            }
        }
    }
    /**
     * Find the function scope at the given position.
     * @param position
     * @param functionScopes
     */
    getFunctionScopeAtPosition(position, functionScopes) {
        if (!functionScopes) {
            functionScopes = this.functionScopes;
        }
        for (let scope of functionScopes) {
            if (util_1.util.rangeContains(scope.range, position)) {
                //see if any of that scope's children match the position also, and give them priority
                let childScope = this.getFunctionScopeAtPosition(position, scope.childrenScopes);
                if (childScope) {
                    return childScope;
                }
                else {
                    return scope;
                }
            }
        }
    }
    /**
     * Get completions available at the given cursor. This aggregates all values from this file and the current scope.
     */
    async getCompletions(position, scope) {
        let result = [];
        let parseMode = this.getParseMode();
        //wait for the file to finish processing
        await this.isReady();
        //a map of lower-case names of all added options
        let names = {};
        //handle script import completions
        let scriptImport = util_1.util.getScriptImportAtPosition(this.ownScriptImports, position);
        if (scriptImport) {
            return this.program.getScriptImportCompletions(this.pkgPath, scriptImport);
        }
        //if cursor is within a comment, disable completions
        let currentToken = this.getTokenAt(position);
        if (currentToken && currentToken.kind === lexer_1.TokenKind.Comment) {
            return [];
        }
        //determine if cursor is inside a function
        let functionScope = this.getFunctionScopeAtPosition(position);
        if (!functionScope) {
            //we aren't in any function scope, so return the keyword completions
            return exports.KeywordCompletions;
        }
        //is next to a period (or an identifier that is next to a period). include the property names
        if (this.isPositionNextToDot(position)) {
            let namespaceCompletions = this.getNamespaceCompletions(currentToken, parseMode, scope);
            //if the text to the left of the dot is a part of a known namespace, complete with additional namespace information
            if (namespaceCompletions.length > 0) {
                result.push(...namespaceCompletions);
            }
            else {
                result.push(...scope.getPropertyNameCompletions());
            }
        }
        else {
            //include the global callables
            result.push(...scope.getCallablesAsCompletions(parseMode));
            //add `m` because that's always valid within a function
            result.push({
                label: 'm',
                kind: vscode_languageserver_1.CompletionItemKind.Variable
            });
            names.m = true;
            result.push(...exports.KeywordCompletions);
            //include local variables
            let variables = functionScope.variableDeclarations;
            for (let variable of variables) {
                //skip duplicate variable names
                if (names[variable.name.toLowerCase()]) {
                    continue;
                }
                names[variable.name.toLowerCase()] = true;
                result.push({
                    label: variable.name,
                    kind: reflection_1.isFunctionType(variable.type) ? vscode_languageserver_1.CompletionItemKind.Function : vscode_languageserver_1.CompletionItemKind.Variable
                });
            }
            if (parseMode === parser_1.ParseMode.BrighterScript) {
                //include the first part of namespaces
                let namespaces = scope.getNamespaceStatements();
                for (let stmt of namespaces) {
                    let firstPart = stmt.nameExpression.getNameParts().shift();
                    //skip duplicate namespace names
                    if (names[firstPart.toLowerCase()]) {
                        continue;
                    }
                    names[firstPart.toLowerCase()] = true;
                    result.push({
                        label: firstPart,
                        kind: vscode_languageserver_1.CompletionItemKind.Module
                    });
                }
            }
        }
        return result;
    }
    getNamespaceCompletions(currentToken, parseMode, scope) {
        //BrightScript does not support namespaces, so return an empty list in that case
        if (parseMode === parser_1.ParseMode.BrightScript) {
            return [];
        }
        let completionName = this.getPartialVariableName(currentToken);
        //remove any trailing identifer and then any trailing dot, to give us the
        //name of its immediate parent namespace
        let closestParentNamespaceName = completionName.replace(/\.([a-z0-9_]*)?$/gi, '');
        let namespaceLookup = scope.namespaceLookup;
        let result = [];
        for (let key in namespaceLookup) {
            let namespace = namespaceLookup[key.toLowerCase()];
            //completionName = "NameA."
            //completionName = "NameA.Na
            //NameA
            //NameA.NameB
            //NameA.NameB.NameC
            if (namespace.fullName.toLowerCase() === closestParentNamespaceName.toLowerCase()) {
                //add all of this namespace's immediate child namespaces
                for (let childKey in namespace.namespaces) {
                    result.push({
                        label: namespace.namespaces[childKey].lastPartName,
                        kind: vscode_languageserver_1.CompletionItemKind.Module
                    });
                }
                //add function and class statement completions
                for (let stmt of namespace.statements) {
                    if (reflection_1.isClassStatement(stmt)) {
                        result.push({
                            label: stmt.name.text,
                            kind: vscode_languageserver_1.CompletionItemKind.Class
                        });
                    }
                    else if (reflection_1.isFunctionStatement(stmt)) {
                        result.push({
                            label: stmt.name.text,
                            kind: vscode_languageserver_1.CompletionItemKind.Function
                        });
                    }
                }
            }
        }
        return result;
    }
    /**
     * Given a current token, walk
     */
    getPartialVariableName(currentToken) {
        let identifierAndDotKinds = [lexer_1.TokenKind.Identifier, ...lexer_1.AllowedLocalIdentifiers, lexer_1.TokenKind.Dot];
        //consume tokens backwards until we find something other than a dot or an identifier
        let tokens = [];
        const parser = this.parser;
        for (let i = parser.tokens.indexOf(currentToken); i >= 0; i--) {
            currentToken = parser.tokens[i];
            if (identifierAndDotKinds.includes(currentToken.kind)) {
                tokens.unshift(currentToken.text);
            }
            else {
                break;
            }
        }
        //if we found name and dot tokens, join them together to make the namespace name
        if (tokens.length > 0) {
            return tokens.join('');
        }
        else {
            return undefined;
        }
    }
    /**
     * Determine if this file is a brighterscript file
     */
    getParseMode() {
        return this.pathAbsolute.toLowerCase().endsWith('.bs') ? parser_1.ParseMode.BrighterScript : parser_1.ParseMode.BrightScript;
    }
    isPositionNextToDot(position) {
        let closestToken = this.getClosestToken(position);
        let previousToken = this.getPreviousToken(closestToken);
        //next to a dot
        if (closestToken.kind === lexer_1.TokenKind.Dot) {
            return true;
        }
        else if (closestToken.kind === lexer_1.TokenKind.Newline || previousToken.kind === lexer_1.TokenKind.Newline) {
            return false;
            //next to an identifier, which is next to a dot
        }
        else if (closestToken.kind === lexer_1.TokenKind.Identifier && previousToken.kind === lexer_1.TokenKind.Dot) {
            return true;
        }
        else {
            return false;
        }
    }
    getPreviousToken(token) {
        const parser = this.parser;
        let idx = parser.tokens.indexOf(token);
        return parser.tokens[idx - 1];
    }
    /**
     * Find the first scope that has a namespace with this name.
     * Returns false if no namespace was found with that name
     */
    calleeStartsWithNamespace(callee) {
        let left = callee;
        while (reflection_1.isDottedGetExpression(left)) {
            left = left.obj;
        }
        if (reflection_1.isVariableExpression(left)) {
            let lowerName = left.name.text.toLowerCase();
            //find the first scope that contains this namespace
            let scopes = this.program.getScopesForFile(this);
            for (let scope of scopes) {
                if (scope.namespaceLookup[lowerName]) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Determine if the callee (i.e. function name) is a known function declared on the given namespace.
     */
    calleeIsKnownNamespaceFunction(callee, namespaceName) {
        //if we have a variable and a namespace
        if (reflection_1.isVariableExpression(callee) && namespaceName) {
            let lowerCalleeName = callee.name.text.toLowerCase();
            let scopes = this.program.getScopesForFile(this);
            for (let scope of scopes) {
                let namespace = scope.namespaceLookup[namespaceName.toLowerCase()];
                if (namespace.functionStatements[lowerCalleeName]) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get the token closest to the position. if no token is found, the previous token is returned
     * @param position
     * @param tokens
     */
    getClosestToken(position) {
        let tokens = this.parser.tokens;
        for (let i = 0; i < tokens.length; i++) {
            let token = tokens[i];
            if (util_1.util.rangeContains(token.range, position)) {
                return token;
            }
            //if the position less than this token range, then this position touches no token,
            if (util_1.util.positionIsGreaterThanRange(position, token.range) === false) {
                let t = tokens[i - 1];
                //return the token or the first token
                return t ? t : tokens[0];
            }
        }
        //return the last token
        return tokens[tokens.length - 1];
    }
    /**
     * Builds a list of document symbols for this file. Used by LanguageServer's onDocumentSymbol functionality
     */
    async getDocumentSymbols() {
        if (this.documentSymbols) {
            return this.documentSymbols;
        }
        let symbols = [];
        await this.isReady();
        for (const statement of this.ast.statements) {
            const symbol = this.getDocumentSymbol(statement);
            if (symbol) {
                symbols.push(symbol);
            }
        }
        this.documentSymbols = symbols;
        return symbols;
    }
    /**
     * Builds a list of workspace symbols for this file. Used by LanguageServer's onWorkspaceSymbol functionality
     */
    async getWorkspaceSymbols() {
        if (this.workspaceSymbols) {
            return this.workspaceSymbols;
        }
        let symbols = [];
        await this.isReady();
        for (const statement of this.ast.statements) {
            for (const symbol of this.generateWorkspaceSymbols(statement)) {
                symbols.push(symbol);
            }
        }
        this.workspaceSymbols = symbols;
        return symbols;
    }
    /**
     * Builds a single DocumentSymbol object for use by LanguageServer's onDocumentSymbol functionality
     */
    getDocumentSymbol(statement) {
        let symbolKind;
        const children = [];
        if (reflection_1.isFunctionStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Function;
        }
        else if (reflection_1.isClassMethodStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Method;
        }
        else if (reflection_1.isNamespaceStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Namespace;
            for (const childStatement of statement.body.statements) {
                const symbol = this.getDocumentSymbol(childStatement);
                if (symbol) {
                    children.push(symbol);
                }
            }
        }
        else if (reflection_1.isClassStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Class;
            for (const childStatement of statement.body) {
                const symbol = this.getDocumentSymbol(childStatement);
                if (symbol) {
                    children.push(symbol);
                }
            }
        }
        else {
            return;
        }
        const name = statement.getName(parser_1.ParseMode.BrighterScript);
        return vscode_languageserver_1.DocumentSymbol.create(name, '', symbolKind, statement.range, statement.range, children);
    }
    /**
     * Builds a single SymbolInformation object for use by LanguageServer's onWorkspaceSymbol functionality
     */
    generateWorkspaceSymbols(statement, containerStatement) {
        let symbolKind;
        const symbols = [];
        if (reflection_1.isFunctionStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Function;
        }
        else if (reflection_1.isClassMethodStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Method;
        }
        else if (reflection_1.isNamespaceStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Namespace;
            for (const childStatement of statement.body.statements) {
                for (const symbol of this.generateWorkspaceSymbols(childStatement, statement)) {
                    symbols.push(symbol);
                }
            }
        }
        else if (reflection_1.isClassStatement(statement)) {
            symbolKind = vscode_languageserver_1.SymbolKind.Class;
            for (const childStatement of statement.body) {
                for (const symbol of this.generateWorkspaceSymbols(childStatement, statement)) {
                    symbols.push(symbol);
                }
            }
        }
        else {
            return symbols;
        }
        const name = statement.getName(parser_1.ParseMode.BrighterScript);
        const uri = util_1.util.pathToUri(this.pathAbsolute);
        const symbol = vscode_languageserver_1.SymbolInformation.create(name, symbolKind, statement.range, uri, containerStatement === null || containerStatement === void 0 ? void 0 : containerStatement.getName(parser_1.ParseMode.BrighterScript));
        symbols.push(symbol);
        return symbols;
    }
    /**
     * Given a position in a file, if the position is sitting on some type of identifier,
     * go to the definition of that identifier (where this thing was first defined)
     */
    async getDefinition(position) {
        await this.isReady();
        let results = [];
        //get the token at the position
        const token = this.getTokenAt(position);
        // While certain other tokens are allowed as local variables (AllowedLocalIdentifiers: https://github.com/rokucommunity/brighterscript/blob/master/src/lexer/TokenKind.ts#L418), these are converted by the parser to TokenKind.Identifier by the time we retrieve the token using getTokenAt
        let definitionTokenTypes = [
            lexer_1.TokenKind.Identifier,
            lexer_1.TokenKind.StringLiteral
        ];
        //throw out invalid tokens and the wrong kind of tokens
        if (!token || !definitionTokenTypes.includes(token.kind)) {
            return results;
        }
        let textToSearchFor = token.text.toLowerCase();
        if (token.kind === lexer_1.TokenKind.StringLiteral) {
            // We need to strip off the quotes but only if present
            const startIndex = textToSearchFor.startsWith('"') ? 1 : 0;
            let endIndex = textToSearchFor.length;
            if (textToSearchFor.endsWith('"')) {
                endIndex--;
            }
            textToSearchFor = textToSearchFor.substring(startIndex, endIndex);
        }
        //look through local variables first, get the function scope for this position (if it exists)
        const functionScope = this.getFunctionScopeAtPosition(position);
        if (functionScope) {
            //find any variable with this name
            for (const varDeclaration of functionScope.variableDeclarations) {
                //we found a variable declaration with this token text!
                if (varDeclaration.name.toLowerCase() === textToSearchFor) {
                    const uri = util_1.util.pathToUri(this.pathAbsolute);
                    results.push(vscode_languageserver_1.Location.create(uri, varDeclaration.nameRange));
                }
            }
        }
        const filesSearched = {};
        //look through all files in scope for matches
        for (const scope of this.program.getScopesForFile(this)) {
            for (const file of scope.getFiles()) {
                if (reflection_1.isXmlFile(file) || filesSearched[file.pathAbsolute]) {
                    continue;
                }
                filesSearched[file.pathAbsolute] = true;
                const statementHandler = (statement) => {
                    if (statement.getName(this.getParseMode()).toLowerCase() === textToSearchFor) {
                        const uri = util_1.util.pathToUri(file.pathAbsolute);
                        results.push(vscode_languageserver_1.Location.create(uri, statement.range));
                    }
                };
                file.parser.ast.walk(visitors_1.createVisitor({
                    FunctionStatement: statementHandler,
                    ClassMethodStatement: statementHandler
                }), {
                    walkMode: visitors_1.WalkMode.visitStatements
                });
            }
        }
        return results;
    }
    async getHover(position) {
        await this.isReady();
        //get the token at the position
        let token = this.getTokenAt(position);
        let hoverTokenTypes = [
            lexer_1.TokenKind.Identifier,
            lexer_1.TokenKind.Function,
            lexer_1.TokenKind.EndFunction,
            lexer_1.TokenKind.Sub,
            lexer_1.TokenKind.EndSub
        ];
        //throw out invalid tokens and the wrong kind of tokens
        if (!token || !hoverTokenTypes.includes(token.kind)) {
            return null;
        }
        let lowerTokenText = token.text.toLowerCase();
        //look through local variables first
        {
            //get the function scope for this position (if exists)
            let functionScope = this.getFunctionScopeAtPosition(position);
            if (functionScope) {
                //find any variable with this name
                for (let varDeclaration of functionScope.variableDeclarations) {
                    //we found a variable declaration with this token text!
                    if (varDeclaration.name.toLowerCase() === lowerTokenText) {
                        let typeText;
                        if (reflection_1.isFunctionType(varDeclaration.type)) {
                            typeText = varDeclaration.type.toString();
                        }
                        else {
                            typeText = `${varDeclaration.name} as ${varDeclaration.type.toString()}`;
                        }
                        return {
                            range: token.range,
                            //append the variable name to the front for scope
                            contents: typeText
                        };
                    }
                }
            }
        }
        //look through all callables in relevant scopes
        {
            let scopes = this.program.getScopesForFile(this);
            for (let scope of scopes) {
                let callable = scope.getCallableByName(lowerTokenText);
                if (callable) {
                    return {
                        range: token.range,
                        contents: callable.type.toString()
                    };
                }
            }
        }
    }
    getSignatureHelp(statement) {
        const func = statement.func;
        const funcStartPosition = func.range.start;
        // Get function comments in reverse order
        let currentToken = this.getTokenAt(funcStartPosition);
        let functionComments = [];
        while (true) {
            currentToken = this.getPreviousToken(currentToken);
            if (!currentToken) {
                break;
            }
            if (currentToken.range.start.line + 1 < funcStartPosition.line) {
                if (functionComments.length === 0) {
                    break;
                }
            }
            const kind = currentToken.kind;
            if (kind === lexer_1.TokenKind.Comment) {
                // Strip off common leading characters to make it easier to read
                const commentText = currentToken.text.replace(/^[' *\/]+/, '');
                functionComments.unshift(commentText);
            }
            else if (kind === lexer_1.TokenKind.Newline) {
                if (functionComments.length === 0) {
                    continue;
                }
                // if we already had a new line as the last token then exit out
                if (functionComments[0] === currentToken.text) {
                    break;
                }
                functionComments.unshift(currentToken.text);
            }
            else {
                break;
            }
        }
        const documentation = functionComments.join('').trim();
        const lines = util_1.util.splitIntoLines(this.fileContents);
        const params = [];
        for (const param of func.parameters) {
            params.push(vscode_languageserver_1.ParameterInformation.create(param.name.text));
        }
        const label = util_1.util.getTextForRange(lines, util_1.util.createRangeFromPositions(func.functionType.range.start, func.body.range.start)).trim();
        const signature = vscode_languageserver_1.SignatureInformation.create(label, documentation, ...params);
        return signature;
    }
    async getReferences(position) {
        await this.isReady();
        const callSiteToken = this.getTokenAt(position);
        let locations = [];
        const searchFor = callSiteToken.text.toLowerCase();
        const scopes = this.program.getScopesForFile(this);
        for (const scope of scopes) {
            for (const file of scope.getFiles()) {
                if (reflection_1.isXmlFile(file)) {
                    continue;
                }
                file.ast.walk(visitors_1.createVisitor({
                    VariableExpression: (e) => {
                        if (e.name.text.toLowerCase() === searchFor) {
                            locations.push(vscode_languageserver_1.Location.create(util_1.util.pathToUri(file.pathAbsolute), e.range));
                        }
                    }
                }), {
                    walkMode: visitors_1.WalkMode.visitExpressionsRecursive
                });
            }
        }
        return locations;
    }
    /**
     * Convert the brightscript/brighterscript source code into valid brightscript
     */
    transpile() {
        const state = new TranspileState_1.TranspileState(this);
        if (this.needsTranspiled) {
            let programNode = new source_map_1.SourceNode(null, null, this.pathAbsolute, this.ast.transpile(state));
            let result = programNode.toStringWithSourceMap({
                file: this.pathAbsolute
            });
            return result;
        }
        else {
            //create a source map from the original source code
            let chunks = [];
            let lines = util_1.util.splitIntoLines(this.fileContents);
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex];
                chunks.push(lineIndex > 0 ? '\n' : '', new source_map_1.SourceNode(lineIndex + 1, 0, state.pathAbsolute, line));
            }
            return new source_map_1.SourceNode(null, null, state.pathAbsolute, chunks).toStringWithSourceMap();
        }
    }
    getTypedef() {
        const state = new TranspileState_1.TranspileState(this);
        const typedef = this.ast.getTypedef(state);
        const programNode = new source_map_1.SourceNode(null, null, this.pathAbsolute, typedef);
        return programNode.toString();
    }
    dispose() {
        var _a;
        (_a = this._parser) === null || _a === void 0 ? void 0 : _a.dispose();
    }
}
exports.BrsFile = BrsFile;
/**
 * List of completions for all valid keywords/reserved words.
 * Build this list once because it won't change for the lifetime of this process
 */
exports.KeywordCompletions = Object.keys(lexer_1.Keywords)
    //remove any keywords with whitespace
    .filter(x => !x.includes(' '))
    //create completions
    .map(x => {
    return {
        label: x,
        kind: vscode_languageserver_1.CompletionItemKind.Keyword
    };
});
//# sourceMappingURL=BrsFile.js.map