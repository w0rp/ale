import type { CompletionItem, Hover, Position } from 'vscode-languageserver';
import { Location, SignatureInformation, DocumentSymbol, SymbolInformation } from 'vscode-languageserver';
import type { Scope } from '../Scope';
import { FunctionScope } from '../FunctionScope';
import type { Callable, CommentFlag, FunctionCall, BsDiagnostic, FileReference } from '../interfaces';
import type { Token } from '../lexer';
import { Parser, ParseMode } from '../parser';
import type { FunctionExpression, Expression } from '../parser/Expression';
import type { ClassStatement, FunctionStatement, ClassMethodStatement } from '../parser/Statement';
import type { Program } from '../Program';
import type { DependencyGraph } from '../DependencyGraph';
/**
 * Holds all details about this file within the scope of the whole program
 */
export declare class BrsFile {
    pathAbsolute: string;
    /**
     * The full pkg path to this file
     */
    pkgPath: string;
    program: Program;
    constructor(pathAbsolute: string, 
    /**
     * The full pkg path to this file
     */
    pkgPath: string, program: Program);
    /**
     * The parseMode used for the parser for this file
     */
    get parseMode(): ParseMode;
    /**
     * The key used to identify this file in the dependency graph
     */
    dependencyGraphKey: string;
    /**
     * The all-lowercase extension for this file (including the leading dot)
     */
    extension: string;
    private parseDeferred;
    /**
     * Indicates that the file is completely ready for interaction
     */
    isReady(): Promise<void>;
    private diagnostics;
    getDiagnostics(): BsDiagnostic[];
    addDiagnostics(diagnostics: BsDiagnostic[]): void;
    commentFlags: CommentFlag[];
    callables: Callable[];
    functionCalls: FunctionCall[];
    private _functionScopes;
    get functionScopes(): FunctionScope[];
    /**
     * files referenced by import statements
     */
    ownScriptImports: FileReference[];
    /**
     * Does this file need to be transpiled?
     */
    needsTranspiled: boolean;
    /**
     * The AST for this file
     */
    get ast(): import("../parser").Body;
    private documentSymbols;
    private workspaceSymbols;
    /**
     * Get the token at the specified position
     * @param position
     */
    private getTokenAt;
    get parser(): Parser;
    private _parser;
    fileContents: string;
    /**
     * If this is a typedef file
     */
    isTypedef: boolean;
    /**
     * The key to find the typedef file in the program's files map.
     * A falsey value means this file is ineligable for a typedef
     */
    typedefKey?: string;
    /**
     * If the file was given type definitions during parse
     */
    hasTypedef: any;
    /**
     * A reference to the typedef file (if one exists)
     */
    typedefFile?: BrsFile;
    /**
     * An unsubscribe function for the dependencyGraph subscription
     */
    private unsubscribeFromDependencyGraph;
    /**
     * Find and set the typedef variables (if a matching typedef file exists)
     */
    private resolveTypdef;
    /**
     * Attach the file to the dependency graph so it can monitor changes.
     * Also notify the dependency graph of our current dependencies so other dependents can be notified.
     */
    attachDependencyGraph(dependencyGraph: DependencyGraph): void;
    /**
     * Calculate the AST for this file
     * @param fileContents
     */
    parse(fileContents: string): void;
    findAndValidateImportAndImportStatements(): void;
    /**
     * Find a class by its full namespace-prefixed name.
     * Returns undefined if not found.
     * @param namespaceName - the namespace to resolve relative classes from.
     */
    getClassByName(className: string, namespaceName?: string): ClassStatement;
    findPropertyNameCompletions(): CompletionItem[];
    private _propertyNameCompletions;
    get propertyNameCompletions(): CompletionItem[];
    /**
     * Find all comment flags in the source code. These enable or disable diagnostic messages.
     * @param lines - the lines of the program
     */
    getIgnores(tokens: Token[]): void;
    scopesByFunc: Map<FunctionExpression, FunctionScope>;
    /**
     * Create a scope for every function in this file
     */
    private createFunctionScopes;
    private getBscTypeFromAssignment;
    private getCallableByName;
    private findCallables;
    private findFunctionCalls;
    /**
     * Find the function scope at the given position.
     * @param position
     * @param functionScopes
     */
    getFunctionScopeAtPosition(position: Position, functionScopes?: FunctionScope[]): FunctionScope;
    /**
     * Get completions available at the given cursor. This aggregates all values from this file and the current scope.
     */
    getCompletions(position: Position, scope?: Scope): Promise<CompletionItem[]>;
    private getNamespaceCompletions;
    /**
     * Given a current token, walk
     */
    private getPartialVariableName;
    /**
     * Determine if this file is a brighterscript file
     */
    getParseMode(): ParseMode;
    private isPositionNextToDot;
    getPreviousToken(token: Token): Token;
    /**
     * Find the first scope that has a namespace with this name.
     * Returns false if no namespace was found with that name
     */
    calleeStartsWithNamespace(callee: Expression): boolean;
    /**
     * Determine if the callee (i.e. function name) is a known function declared on the given namespace.
     */
    calleeIsKnownNamespaceFunction(callee: Expression, namespaceName: string): boolean;
    /**
     * Get the token closest to the position. if no token is found, the previous token is returned
     * @param position
     * @param tokens
     */
    getClosestToken(position: Position): Token;
    /**
     * Builds a list of document symbols for this file. Used by LanguageServer's onDocumentSymbol functionality
     */
    getDocumentSymbols(): Promise<DocumentSymbol[]>;
    /**
     * Builds a list of workspace symbols for this file. Used by LanguageServer's onWorkspaceSymbol functionality
     */
    getWorkspaceSymbols(): Promise<SymbolInformation[]>;
    /**
     * Builds a single DocumentSymbol object for use by LanguageServer's onDocumentSymbol functionality
     */
    private getDocumentSymbol;
    /**
     * Builds a single SymbolInformation object for use by LanguageServer's onWorkspaceSymbol functionality
     */
    private generateWorkspaceSymbols;
    /**
     * Given a position in a file, if the position is sitting on some type of identifier,
     * go to the definition of that identifier (where this thing was first defined)
     */
    getDefinition(position: Position): Promise<Location[]>;
    getHover(position: Position): Promise<Hover>;
    getSignatureHelp(statement: FunctionStatement | ClassMethodStatement): SignatureInformation;
    getReferences(position: Position): Promise<Location[]>;
    /**
     * Convert the brightscript/brighterscript source code into valid brightscript
     */
    transpile(): import("source-map").CodeWithSourceMap;
    getTypedef(): string;
    dispose(): void;
}
/**
 * List of completions for all valid keywords/reserved words.
 * Build this list once because it won't change for the lifetime of this process
 */
export declare const KeywordCompletions: CompletionItem[];
