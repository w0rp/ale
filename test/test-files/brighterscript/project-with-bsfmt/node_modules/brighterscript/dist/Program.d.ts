import type { CompletionItem, Position, SignatureInformation } from 'vscode-languageserver';
import { Location } from 'vscode-languageserver';
import type { BsConfig } from './BsConfig';
import { Scope } from './Scope';
import { BrsFile } from './files/BrsFile';
import { XmlFile } from './files/XmlFile';
import type { BsDiagnostic, File, FileReference, FileObj, BscFile } from './interfaces';
import { XmlScope } from './XmlScope';
import { DependencyGraph } from './DependencyGraph';
import { Logger } from './Logger';
import PluginInterface from './PluginInterface';
export interface SourceObj {
    pathAbsolute: string;
    source: string;
    definitions?: string;
}
export interface TranspileObj {
    file: BscFile;
    outputPath: string;
}
export declare class Program {
    /**
     * The root directory for this program
     */
    options: BsConfig;
    constructor(
    /**
     * The root directory for this program
     */
    options: BsConfig, logger?: Logger, plugins?: PluginInterface);
    logger: Logger;
    private createGlobalScope;
    /**
     * A graph of all files and their dependencies.
     * For example:
     *      File.xml -> [lib1.brs, lib2.brs]
     *      lib2.brs -> [lib3.brs] //via an import statement
     */
    dependencyGraph: DependencyGraph;
    private diagnosticFilterer;
    private util;
    /**
     * A list of functions that will be used to load file contents.
     * In most cases, there will only be the "read from filesystem" resolver.
     * However, when running inside the LanguageServer, a second resolver will be added
     * to resolve the opened file contents from memory instead of going to disk.
     */
    fileResolvers: FileResolver[];
    /**
     * A scope that contains all built-in global functions.
     * All scopes should directly or indirectly inherit from this scope
     */
    globalScope: Scope;
    /**
     * Plugins which can provide extra diagnostics or transform AST
     */
    plugins: PluginInterface;
    /**
     * A set of diagnostics. This does not include any of the scope diagnostics.
     * Should only be set from `this.validate()`
     */
    private diagnostics;
    /**
     * A map of every file loaded into this program, indexed by its original file location
     */
    files: Record<string, BscFile>;
    private pkgMap;
    private scopes;
    protected addScope(scope: Scope): void;
    /**
     * A map of every component currently loaded into the program, indexed by the component name
     */
    private components;
    /**
     * Get the component with the specified name
     */
    getComponent(componentName: string): {
        file: XmlFile;
        scope: XmlScope;
    };
    /**
     * Register (or replace) the reference to a component in the component map
     */
    private registerComponent;
    /**
     * Remove the specified component from the components map
     */
    private unregisterComponent;
    /**
     * Get the contents of the specified file as a string.
     * This walks backwards through the file resolvers until we get a value.
     * This allow the language server to provide file contents directly from memory.
     */
    getFileContents(pathAbsolute: string): Promise<string>;
    /**
     * Get a list of all files that are included in the project but are not referenced
     * by any scope in the program.
     */
    getUnreferencedFiles(): File[];
    /**
     * Get the list of errors for the entire program. It's calculated on the fly
     * by walking through every file, so call this sparingly.
     */
    getDiagnostics(): BsDiagnostic[];
    addDiagnostics(diagnostics: BsDiagnostic[]): void;
    /**
     * Determine if the specified file is loaded in this program right now.
     * @param filePath
     */
    hasFile(filePath: string): boolean;
    /**
     * Add and parse all of the provided files.
     * Files that are already loaded will be replaced by the latest
     * contents from the file system.
     * @param filePaths
     */
    addOrReplaceFiles<T extends BscFile[]>(fileObjects: Array<FileObj>): Promise<T>;
    getPkgPath(...args: any[]): any;
    /**
     * roku filesystem is case INsensitive, so find the scope by key case insensitive
     * @param scopeName
     */
    getScopeByName(scopeName: string): Scope;
    /**
     * Return all scopes
     */
    getScopes(): Scope[];
    /**
     * Find the scope for the specified component
     */
    getComponentScope(componentName: string): XmlScope;
    /**
     * Load a file into the program. If that file already exists, it is replaced.
     * If file contents are provided, those are used, Otherwise, the file is loaded from the file system
     * @param relativePath the file path relative to the root dir
     * @param fileContents the file contents. If not provided, the file will be loaded from disk
     */
    addOrReplaceFile<T extends BscFile>(relativePath: string, fileContents?: string): Promise<T>;
    /**
     * Load a file into the program. If that file already exists, it is replaced.
     * If file contents are provided, those are used, Otherwise, the file is loaded from the file system
     * @param fileEntry an object that specifies src and dest for the file.
     * @param fileContents the file contents. If not provided, the file will be loaded from disk
     */
    addOrReplaceFile<T extends BscFile>(fileEntry: FileObj, fileContents?: string): Promise<T>;
    /**
     * Ensure source scope is created.
     * Note: automatically called internally, and no-op if it exists already.
     */
    createSourceScope(): void;
    /**
     * Find the file by its absolute path. This is case INSENSITIVE, since
     * Roku is a case insensitive file system. It is an error to have multiple files
     * with the same path with only case being different.
     * @param pathAbsolute
     */
    getFileByPathAbsolute<T extends BrsFile | XmlFile>(pathAbsolute: string): T;
    /**
     * Get a list of files for the given (platform-normalized) pkgPath array.
     * Missing files are just ignored.
     */
    getFilesByPkgPaths<T extends BscFile[]>(pkgPaths: string[]): T;
    /**
     * Get a file with the specified (platform-normalized) pkg path.
     * If not found, return undefined
     */
    getFileByPkgPath<T extends BscFile>(pkgPath: string): T;
    /**
     * Remove a set of files from the program
     * @param absolutePaths
     */
    removeFiles(absolutePaths: string[]): void;
    /**
     * Remove a file from the program
     * @param pathAbsolute
     */
    removeFile(pathAbsolute: string): void;
    /**
     * Traverse the entire project, and validate all scopes
     * @param force - if true, then all scopes are force to validate, even if they aren't marked as dirty
     */
    validate(): Promise<void>;
    /**
     * Flag all duplicate component names
     */
    private detectDuplicateComponentNames;
    /**
     * Determine if the given file is included in at least one scope in this program
     */
    private fileIsIncludedInAnyScope;
    /**
     * Get the file at the given path
     * @param pathAbsolute
     */
    private getFile;
    /**
     * Get a list of all scopes the file is loaded into
     * @param file
     */
    getScopesForFile(file: XmlFile | BrsFile): Scope[];
    /**
     * Find all available completion items at the given position
     * @param pathAbsolute
     * @param lineIndex
     * @param columnIndex
     */
    getCompletions(pathAbsolute: string, position: Position): Promise<CompletionItem[]>;
    /**
     * Goes through each file and builds a list of workspace symbols for the program. Used by LanguageServer's onWorkspaceSymbol functionality
     */
    getWorkspaceSymbols(): Promise<import("vscode-languageserver-types").SymbolInformation[]>;
    /**
     * Given a position in a file, if the position is sitting on some type of identifier,
     * go to the definition of that identifier (where this thing was first defined)
     */
    getDefinition(pathAbsolute: string, position: Position): Location[] | Promise<Location[]>;
    getHover(pathAbsolute: string, position: Position): Promise<import("vscode-languageserver-types").Hover>;
    getSignatureHelp(callSitePathAbsolute: string, callableName: string): Promise<SignatureInformation[]>;
    getReferences(pathAbsolute: string, position: Position): Promise<Location[]>;
    /**
     * Get a list of all script imports, relative to the specified pkgPath
     * @param sourcePkgPath - the pkgPath of the source that wants to resolve script imports.
     */
    getScriptImportCompletions(sourcePkgPath: string, scriptImport: FileReference): CompletionItem[];
    /**
     * Transpile a single file and get the result as a string.
     * This does not write anything to the file system.
     */
    getTranspiledFileContents(pathAbsolute: string): Promise<{
        pathAbsolute: string;
        pkgPath: string;
        code: string;
        map: import("source-map").SourceMapGenerator;
    }>;
    transpile(fileEntries: FileObj[], stagingFolderPath: string): Promise<void>;
    /**
     * Get a map of the manifest information
     */
    getManifest(): Map<string, string | number | boolean>;
    private _manifest;
    dispose(): void;
}
export declare type FileResolver = (pathAbsolute: string) => string | undefined | Thenable<string | undefined> | void;
