"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const Parser_1 = require("../../Parser");
const lexer_1 = require("../../../lexer");
const Parser_spec_1 = require("../Parser.spec");
const vscode_languageserver_1 = require("vscode-languageserver");
describe('parser indexed assignment', () => {
    describe('dotted', () => {
        it('assigns anonymous functions', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Dot, '.'),
                Parser_spec_1.identifier('bar'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.Function, 'function'),
                Parser_spec_1.token(lexer_1.TokenKind.LeftParen, '('),
                Parser_spec_1.token(lexer_1.TokenKind.RightParen, ')'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\\n'),
                Parser_spec_1.token(lexer_1.TokenKind.EndFunction, 'end function'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
        it('assigns boolean expressions', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Dot, '.'),
                Parser_spec_1.identifier('bar'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.And, 'and'),
                Parser_spec_1.token(lexer_1.TokenKind.False, 'false'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
        it('assignment operator', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Dot, '.'),
                Parser_spec_1.identifier('bar'),
                Parser_spec_1.token(lexer_1.TokenKind.StarEqual, '*='),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '5'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
    });
    describe('bracketed', () => {
        it('assigns anonymous functions', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('someArray'),
                Parser_spec_1.token(lexer_1.TokenKind.LeftSquareBracket, '['),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '0'),
                Parser_spec_1.token(lexer_1.TokenKind.RightSquareBracket, ']'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.Function, 'function'),
                Parser_spec_1.token(lexer_1.TokenKind.LeftParen, '('),
                Parser_spec_1.token(lexer_1.TokenKind.RightParen, ')'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\\n'),
                Parser_spec_1.token(lexer_1.TokenKind.EndFunction, 'end function'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
        it('assigns boolean expressions', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('someArray'),
                Parser_spec_1.token(lexer_1.TokenKind.LeftSquareBracket, '['),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '0'),
                Parser_spec_1.token(lexer_1.TokenKind.RightSquareBracket, ']'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.And, 'and'),
                Parser_spec_1.token(lexer_1.TokenKind.False, 'false'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
        it('assignment operator', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.identifier('someArray'),
                Parser_spec_1.token(lexer_1.TokenKind.LeftSquareBracket, '['),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '0'),
                Parser_spec_1.token(lexer_1.TokenKind.RightSquareBracket, ']'),
                Parser_spec_1.token(lexer_1.TokenKind.StarEqual, '*='),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '3'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.empty;
            chai_1.expect(statements).to.exist;
            chai_1.expect(statements).not.to.be.null;
        });
    });
    it('location tracking', () => {
        /**
         *    0   0   0   1   1
         *    0   4   8   2   6
         *  +------------------
         * 0| arr[0] = 1
         * 1| obj.a = 5
         */
        let { statements, diagnostics } = Parser_1.Parser.parse([
            {
                kind: lexer_1.TokenKind.Identifier,
                text: 'arr',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 0, 0, 3),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.LeftSquareBracket,
                text: '[',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 3, 0, 4),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.IntegerLiteral,
                text: '0',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 4, 0, 5),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.RightSquareBracket,
                text: ']',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 5, 0, 6),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Equal,
                text: '=',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 7, 0, 8),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.IntegerLiteral,
                text: '1',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 9, 0, 10),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Newline,
                text: '\n',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(0, 10, 0, 11),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Identifier,
                text: 'obj',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 0, 1, 3),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Dot,
                text: '.',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 3, 1, 4),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Identifier,
                text: 'a',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 4, 1, 5),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Equal,
                text: '=',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 6, 1, 7),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.IntegerLiteral,
                text: '5',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 8, 1, 9),
                leadingWhitespace: ''
            },
            {
                kind: lexer_1.TokenKind.Eof,
                text: '\0',
                isReserved: false,
                range: vscode_languageserver_1.Range.create(1, 10, 1, 11),
                leadingWhitespace: ''
            }
        ]);
        chai_1.expect(diagnostics).to.be.empty;
        chai_1.expect(statements).to.be.lengthOf(2);
        chai_1.expect(statements.map(s => s.range)).to.deep.equal([
            vscode_languageserver_1.Range.create(0, 0, 0, 10),
            vscode_languageserver_1.Range.create(1, 0, 1, 9)
        ]);
    });
});
//# sourceMappingURL=Set.spec.js.map