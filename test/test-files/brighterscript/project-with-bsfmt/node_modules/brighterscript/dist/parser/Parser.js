"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseMode = exports.Parser = void 0;
const lexer_1 = require("../lexer");
const Statement_1 = require("./Statement");
const DiagnosticMessages_1 = require("../DiagnosticMessages");
const util_1 = require("../util");
const Expression_1 = require("./Expression");
const Logger_1 = require("../Logger");
const reflection_1 = require("../astUtils/reflection");
const visitors_1 = require("../astUtils/visitors");
const creators_1 = require("../astUtils/creators");
class Parser {
    constructor() {
        /**
         * The array of tokens passed to `parse()`
         */
        this.tokens = [];
        /**
         * The list of statements for the parsed file
         */
        this.ast = new Statement_1.Body([]);
        this._references = createReferences();
        this.globalTerminators = [];
        /**
         * Annotations collected which should be attached to the next statement
         */
        this.pendingAnnotations = [];
        /**
         * An array of CallExpression for the current function body
         */
        this.callExpressions = [];
    }
    get statements() {
        return this.ast.statements;
    }
    /**
     * References for significant statements/expressions in the parser.
     * These are initially extracted during parse-time to improve performance, but will also be dynamically regenerated if need be.
     *
     * If a plugin modifies the AST, then the plugin should call Parser#invalidateReferences() to force this list to refresh
     */
    get references() {
        //build the references object if it's missing.
        if (!this._references) {
            this.findReferences();
        }
        return this._references;
    }
    /**
     * Invalidates (clears) the references collection. This should be called anytime the AST has been manipulated.
     */
    invalidateReferences() {
        this._references = undefined;
    }
    addPropertyHints(item) {
        if (lexer_1.isToken(item)) {
            const name = item.text;
            this._references.propertyHints[name.toLowerCase()] = name;
        }
        else {
            for (const member of item.elements) {
                if (!reflection_1.isCommentStatement(member)) {
                    const name = member.keyToken.text;
                    if (!name.startsWith('"')) {
                        this._references.propertyHints[name.toLowerCase()] = name;
                    }
                }
            }
        }
    }
    /**
     * Get the currently active global terminators
     */
    peekGlobalTerminators() {
        var _a;
        return (_a = this.globalTerminators[this.globalTerminators.length - 1]) !== null && _a !== void 0 ? _a : [];
    }
    static parse(toParse, options) {
        let tokens;
        if (typeof toParse === 'string') {
            tokens = lexer_1.Lexer.scan(toParse).tokens;
        }
        else {
            tokens = toParse;
        }
        return new Parser().parse(tokens, options);
    }
    /**
     * Parses an array of `Token`s into an abstract syntax tree
     * @param toParse the array of tokens to parse. May not contain any whitespace tokens
     * @returns the same instance of the parser which contains the diagnostics and statements
     */
    parse(tokens, options) {
        var _a;
        this.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) !== null && _a !== void 0 ? _a : new Logger_1.Logger();
        this.tokens = tokens;
        this.options = this.sanitizeParseOptions(options);
        this.allowedLocalIdentifiers = [
            ...lexer_1.AllowedLocalIdentifiers,
            //when in plain brightscript mode, the BrighterScript source literals can be used as regular variables
            ...(this.options.mode === ParseMode.BrightScript ? lexer_1.BrighterScriptSourceLiterals : [])
        ];
        this.current = 0;
        this.diagnostics = [];
        this.namespaceAndFunctionDepth = 0;
        this.ast = this.body();
        return this;
    }
    body() {
        let body = new Statement_1.Body([]);
        if (this.tokens.length > 0) {
            try {
                while (
                //not at end of tokens
                !this.isAtEnd() &&
                    //the next token is not one of the end terminators
                    !this.checkAny(...this.peekGlobalTerminators())) {
                    let dec = this.declaration();
                    if (dec) {
                        //attach annotations to statements
                        if (this.pendingAnnotations.length > 0) {
                            dec.annotations = this.pendingAnnotations;
                            this.pendingAnnotations = [];
                        }
                        body.statements.push(dec);
                    }
                }
            }
            catch (parseError) {
                //do nothing with the parse error for now. perhaps we can remove this?
                console.error(parseError);
            }
        }
        return body;
    }
    sanitizeParseOptions(options) {
        return Object.assign({ mode: 'brightscript' }, (options || {}));
    }
    /**
     * Determine if the parser is currently parsing tokens at the root level.
     */
    isAtRootLevel() {
        return this.namespaceAndFunctionDepth === 0;
    }
    /**
     * Throws an error if the input file type is not BrighterScript
     */
    warnIfNotBrighterScriptMode(featureName) {
        if (this.options.mode !== ParseMode.BrighterScript) {
            let diagnostic = Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.bsFeatureNotSupportedInBrsFiles(featureName)), { range: this.peek().range });
            this.diagnostics.push(diagnostic);
        }
    }
    /**
     * Throws an exception using the last diagnostic message
     */
    lastDiagnosticAsError() {
        var _a;
        let error = new Error((_a = this.diagnostics[this.diagnostics.length - 1]) === null || _a === void 0 ? void 0 : _a.message);
        error.isDiagnostic = true;
        return error;
    }
    declaration(...additionalTerminators) {
        try {
            // consume any leading newlines
            while (this.match(lexer_1.TokenKind.Newline)) { }
            if (this.check(lexer_1.TokenKind.Class)) {
                return this.classDeclaration();
            }
            if (this.checkAny(lexer_1.TokenKind.Sub, lexer_1.TokenKind.Function)) {
                return this.functionDeclaration(false);
            }
            if (this.checkLibrary()) {
                return this.libraryStatement();
            }
            if (this.check(lexer_1.TokenKind.Namespace)) {
                return this.namespaceStatement();
            }
            if (this.check(lexer_1.TokenKind.At) && this.checkNext(lexer_1.TokenKind.Identifier)) {
                this.annotationExpression();
                return;
            }
            // BrightScript is like python, in that variables can be declared without a `var`,
            // `let`, (...) keyword. As such, we must check the token *after* an identifier to figure
            // out what to do with it.
            if (this.checkAny(lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers) &&
                this.checkAnyNext(...lexer_1.AssignmentOperators)) {
                return this.assignment(...additionalTerminators);
            }
            if (this.check(lexer_1.TokenKind.Comment)) {
                let stmt = this.commentStatement();
                //scrap consecutive newlines
                while (this.match(lexer_1.TokenKind.Newline)) {
                }
                return stmt;
            }
            //catch certain global terminators to prevent unnecessary lookahead (i.e. like `end namespace`, no need to continue)
            if (this.checkAny(...this.peekGlobalTerminators())) {
                return;
            }
            return this.statement(...additionalTerminators);
        }
        catch (error) {
            //if the error is not a diagnostic, then log the error for debugging purposes
            if (!error.isDiagnostic) {
                this.logger.error(error);
            }
            this.synchronize();
        }
    }
    /**
     * A BrighterScript class declaration
     */
    classDeclaration() {
        this.warnIfNotBrighterScriptMode('class declarations');
        let classKeyword = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedClassKeyword(), lexer_1.TokenKind.Class);
        let extendsKeyword;
        let parentClassName;
        //get the class name
        let className = this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.expectedIdentifierAfterKeyword('class'), lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers);
        //see if the class inherits from parent
        if (this.peek().text.toLowerCase() === 'extends') {
            extendsKeyword = this.advance();
            parentClassName = this.getNamespacedVariableNameExpression();
            //the only thing allowed after a class declaration is a comment or a newline
            this.flagUntil(lexer_1.TokenKind.Comment, lexer_1.TokenKind.Newline);
        }
        let body = [];
        //consume any trailing comments on the class declaration line
        if (this.check(lexer_1.TokenKind.Comment)) {
            body.push(this.commentStatement());
        }
        //consume newlines (at least one)
        while (this.match(lexer_1.TokenKind.Newline)) {
        }
        //gather up all class members (Fields, Methods)
        while (this.checkAny(lexer_1.TokenKind.Public, lexer_1.TokenKind.Protected, lexer_1.TokenKind.Private, lexer_1.TokenKind.Function, lexer_1.TokenKind.Sub, lexer_1.TokenKind.Comment, lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties)) {
            try {
                let accessModifier;
                if (this.checkAny(lexer_1.TokenKind.Public, lexer_1.TokenKind.Protected, lexer_1.TokenKind.Private)) {
                    //use actual access modifier
                    accessModifier = this.advance();
                }
                let overrideKeyword;
                if (this.peek().text.toLowerCase() === 'override') {
                    overrideKeyword = this.advance();
                }
                //methods (function/sub keyword OR identifier followed by opening paren)
                if (this.checkAny(lexer_1.TokenKind.Function, lexer_1.TokenKind.Sub) || (this.checkAny(lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties) && this.checkNext(lexer_1.TokenKind.LeftParen))) {
                    let funcDeclaration = this.functionDeclaration(false, false);
                    //remove this function from the lists because it's not a callable
                    const functionStatement = this._references.functionStatements.pop();
                    //if we have an overrides keyword AND this method is called 'new', that's not allowed
                    if (overrideKeyword && funcDeclaration.name.text.toLowerCase() === 'new') {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.cannotUseOverrideKeywordOnConstructorFunction()), { range: overrideKeyword.range }));
                    }
                    const methodStatement = new Statement_1.ClassMethodStatement(accessModifier, funcDeclaration.name, funcDeclaration.func, overrideKeyword);
                    //refer to this statement as parent of the expression
                    functionStatement.func.functionStatement = methodStatement;
                    body.push(methodStatement);
                    //fields
                }
                else if (this.checkAny(lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties)) {
                    body.push(this.classFieldDeclaration(accessModifier));
                    //class fields cannot be overridden
                    if (overrideKeyword) {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.classFieldCannotBeOverridden()), { range: overrideKeyword.range }));
                    }
                    //comments
                }
                else if (this.check(lexer_1.TokenKind.Comment)) {
                    body.push(this.commentStatement());
                }
            }
            catch (e) {
                //throw out any failed members and move on to the next line
                this.flagUntil(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof);
            }
            if (this.check(lexer_1.TokenKind.Comment)) {
                body.push(this.commentStatement());
            }
            //if the previous token was NOT a newline, then
            //there shouldn't be anything else after the method / field declaration, so flag extra stuff
            if (!this.checkPrevious(lexer_1.TokenKind.Newline)) {
                this.flagUntil(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof);
            }
            //consume trailing newlines
            while (this.match(lexer_1.TokenKind.Newline)) { }
        }
        //consume trailing newlines
        while (this.match(lexer_1.TokenKind.Newline)) { }
        let endingKeyword = this.advance();
        if (endingKeyword.kind !== lexer_1.TokenKind.EndClass) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.couldNotFindMatchingEndKeyword('class')), { range: endingKeyword.range }));
        }
        //consume any trailing newlines
        while (this.match(lexer_1.TokenKind.Newline)) {
        }
        const result = new Statement_1.ClassStatement(classKeyword, className, body, endingKeyword, extendsKeyword, parentClassName, this.currentNamespaceName);
        this._references.classStatements.push(result);
        return result;
    }
    classFieldDeclaration(accessModifier) {
        let name = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedClassFieldIdentifier(), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
        let asToken;
        let fieldType;
        //look for `as SOME_TYPE`
        if (this.check(lexer_1.TokenKind.As)) {
            asToken = this.advance();
            fieldType = this.advance();
            //no field type specified
            if (!util_1.util.tokenToBscType(fieldType) && !this.check(lexer_1.TokenKind.Identifier)) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedValidTypeToFollowAsKeyword()), { range: this.peek().range }));
            }
        }
        let initialValue;
        let equal;
        //if there is a field initializer
        if (this.check(lexer_1.TokenKind.Equal)) {
            equal = this.advance();
            initialValue = this.expression();
        }
        return new Statement_1.ClassFieldStatement(accessModifier, name, asToken, fieldType, equal, initialValue);
    }
    functionDeclaration(isAnonymous, checkIdentifier = true) {
        var _a;
        let previousCallExpressions = this.callExpressions;
        this.callExpressions = [];
        try {
            //track depth to help certain statements need to know if they are contained within a function body
            this.namespaceAndFunctionDepth++;
            let functionType;
            if (this.checkAny(lexer_1.TokenKind.Sub, lexer_1.TokenKind.Function)) {
                functionType = this.advance();
            }
            else {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.missingCallableKeyword()), { range: this.peek().range }));
                functionType = {
                    isReserved: true,
                    kind: lexer_1.TokenKind.Function,
                    text: 'function',
                    //zero-length location means derived
                    range: {
                        start: this.peek().range.start,
                        end: this.peek().range.start
                    },
                    leadingWhitespace: ''
                };
            }
            let isSub = functionType && functionType.kind === lexer_1.TokenKind.Sub;
            let functionTypeText = isSub ? 'sub' : 'function';
            let name;
            let leftParen;
            if (isAnonymous) {
                leftParen = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedLeftParenAfterCallable(functionTypeText), lexer_1.TokenKind.LeftParen);
            }
            else {
                name = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNameAfterCallableKeyword(functionTypeText), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
                leftParen = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedLeftParenAfterCallableName(functionTypeText), lexer_1.TokenKind.LeftParen);
                //prevent functions from ending with type designators
                let lastChar = name.text[name.text.length - 1];
                if (['$', '%', '!', '#', '&'].includes(lastChar)) {
                    //don't throw this error; let the parser continue
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.functionNameCannotEndWithTypeDesignator(functionTypeText, name.text, lastChar)), { range: name.range }));
                }
                //flag functions with keywords for names (only for standard functions)
                if (checkIdentifier && lexer_1.DisallowedFunctionIdentifiersText.has(name.text.toLowerCase())) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.cannotUseReservedWordAsIdentifier(name.text)), { range: name.range }));
                }
            }
            let params = [];
            let asToken;
            let typeToken;
            if (!this.check(lexer_1.TokenKind.RightParen)) {
                do {
                    if (params.length >= Expression_1.CallExpression.MaximumArguments) {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.tooManyCallableParameters(params.length, Expression_1.CallExpression.MaximumArguments)), { range: this.peek().range }));
                    }
                    params.push(this.functionParameter());
                } while (this.match(lexer_1.TokenKind.Comma));
            }
            let rightParen = this.advance();
            if (this.check(lexer_1.TokenKind.As)) {
                asToken = this.advance();
                typeToken = this.advance();
                if (!util_1.util.tokenToBscType(typeToken)) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.invalidFunctionReturnType((_a = typeToken.text) !== null && _a !== void 0 ? _a : '')), { range: typeToken.range }));
                }
            }
            params.reduce((haveFoundOptional, param) => {
                if (haveFoundOptional && !param.defaultValue) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.requiredParameterMayNotFollowOptionalParameter(param.name.text)), { range: param.range }));
                }
                return haveFoundOptional || !!param.defaultValue;
            }, false);
            let comment;
            //get a comment if available
            if (this.check(lexer_1.TokenKind.Comment)) {
                comment = this.commentStatement();
            }
            this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterCallableSignature(functionTypeText), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon);
            while (this.match(lexer_1.TokenKind.Newline)) { }
            let func = new Expression_1.FunctionExpression(params, undefined, //body
            functionType, undefined, //ending keyword
            leftParen, rightParen, asToken, typeToken, this.currentFunctionExpression);
            //if there is a parent function, register this function with the parent
            if (this.currentFunctionExpression) {
                this.currentFunctionExpression.childFunctionExpressions.push(func);
            }
            this._references.functionExpressions.push(func);
            let previousFunctionExpression = this.currentFunctionExpression;
            this.currentFunctionExpression = func;
            //make sure to restore the currentFunctionExpression even if the body block fails to parse
            try {
                //support ending the function with `end sub` OR `end function`
                func.body = this.block(lexer_1.TokenKind.EndSub, lexer_1.TokenKind.EndFunction);
            }
            finally {
                this.currentFunctionExpression = previousFunctionExpression;
            }
            if (!func.body) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.callableBlockMissingEndKeyword(functionTypeText)), { range: this.peek().range }));
                throw this.lastDiagnosticAsError();
            }
            //prepend comment to body
            if (comment) {
                func.body.statements.unshift(comment);
            }
            // consume 'end sub' or 'end function'
            func.end = this.advance();
            let expectedEndKind = isSub ? lexer_1.TokenKind.EndSub : lexer_1.TokenKind.EndFunction;
            //if `function` is ended with `end sub`, or `sub` is ended with `end function`, then
            //add an error but don't hard-fail so the AST can continue more gracefully
            if (func.end.kind !== expectedEndKind) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.mismatchedEndCallableKeyword(functionTypeText, func.end.text)), { range: this.peek().range }));
            }
            func.callExpressions = this.callExpressions;
            if (isAnonymous) {
                return func;
            }
            else {
                // only consume trailing newlines in the statement context; expressions
                // expect to handle their own trailing whitespace
                while (this.match(lexer_1.TokenKind.Newline)) {
                }
                let result = new Statement_1.FunctionStatement(name, func, this.currentNamespaceName);
                func.functionStatement = result;
                this._references.functionStatements.push(result);
                return result;
            }
        }
        finally {
            this.namespaceAndFunctionDepth--;
            //restore the previous CallExpression list
            this.callExpressions = previousCallExpressions;
        }
    }
    functionParameter() {
        if (!this.checkAny(lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers)) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedParameterNameButFound(this.peek().text)), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        let name = this.advance();
        // force the name into an identifier so the AST makes some sense
        name.kind = lexer_1.TokenKind.Identifier;
        let typeToken;
        let defaultValue;
        // parse argument default value
        if (this.match(lexer_1.TokenKind.Equal)) {
            // it seems any expression is allowed here -- including ones that operate on other arguments!
            defaultValue = this.expression();
        }
        let asToken = null;
        if (this.check(lexer_1.TokenKind.As)) {
            asToken = this.advance();
            typeToken = this.advance();
            if (!util_1.util.tokenToBscType(typeToken)) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.functionParameterTypeIsInvalid(name.text, typeToken.text)), { range: typeToken.range }));
                throw this.lastDiagnosticAsError();
            }
        }
        return new Expression_1.FunctionParameterExpression(name, typeToken, defaultValue, asToken);
    }
    assignment(...additionalterminators) {
        let name = this.advance();
        //add diagnostic if name is a reserved word that cannot be used as an identifier
        if (lexer_1.DisallowedLocalIdentifiersText.has(name.text.toLowerCase())) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.cannotUseReservedWordAsIdentifier(name.text)), { range: name.range }));
        }
        let operator = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedOperatorAfterIdentifier(lexer_1.AssignmentOperators, name.text), ...lexer_1.AssignmentOperators);
        let value = this.expression();
        if (!this.checkAny(...additionalterminators, lexer_1.TokenKind.Comment)) {
            this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterAssignment(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Eof, ...additionalterminators);
        }
        while (this.match(lexer_1.TokenKind.Newline)) { }
        let result;
        if (operator.kind === lexer_1.TokenKind.Equal) {
            result = new Statement_1.AssignmentStatement(operator, name, value, this.currentFunctionExpression);
        }
        else {
            result = new Statement_1.AssignmentStatement(operator, name, new Expression_1.BinaryExpression(new Expression_1.VariableExpression(name, this.currentNamespaceName), operator, value), this.currentFunctionExpression);
        }
        this._references.assignmentStatements.push(result);
        return result;
    }
    checkLibrary() {
        let isLibraryToken = this.check(lexer_1.TokenKind.Library);
        //if we are at the top level, any line that starts with "library" should be considered a library statement
        if (this.isAtRootLevel() && isLibraryToken) {
            return true;
            //not at root level, library statements are all invalid here, but try to detect if the tokens look
            //like a library statement (and let the libraryStatement function handle emitting the diagnostics)
        }
        else if (isLibraryToken && this.checkNext(lexer_1.TokenKind.StringLiteral)) {
            return true;
            //definitely not a library statement
        }
        else {
            return false;
        }
    }
    statement(...additionalterminators) {
        if (this.checkLibrary()) {
            return this.libraryStatement();
        }
        if (this.check(lexer_1.TokenKind.Import)) {
            return this.importStatement();
        }
        if (this.check(lexer_1.TokenKind.Stop)) {
            return this.stopStatement();
        }
        if (this.check(lexer_1.TokenKind.If)) {
            return this.ifStatement();
        }
        if (this.check(lexer_1.TokenKind.Try)) {
            return this.tryCatchStatement();
        }
        if (this.check(lexer_1.TokenKind.Throw)) {
            return this.throwStatement();
        }
        if (this.check(lexer_1.TokenKind.Print)) {
            return this.printStatement(...additionalterminators);
        }
        if (this.check(lexer_1.TokenKind.While)) {
            return this.whileStatement();
        }
        if (this.check(lexer_1.TokenKind.ExitWhile)) {
            return this.exitWhile();
        }
        if (this.check(lexer_1.TokenKind.For)) {
            return this.forStatement();
        }
        if (this.check(lexer_1.TokenKind.ForEach)) {
            return this.forEachStatement();
        }
        if (this.check(lexer_1.TokenKind.ExitFor)) {
            return this.exitFor();
        }
        if (this.check(lexer_1.TokenKind.End)) {
            return this.endStatement();
        }
        if (this.match(lexer_1.TokenKind.Return)) {
            return this.returnStatement();
        }
        if (this.check(lexer_1.TokenKind.Goto)) {
            return this.gotoStatement();
        }
        //does this line look like a label? (i.e.  `someIdentifier:` )
        if (this.check(lexer_1.TokenKind.Identifier) && this.checkNext(lexer_1.TokenKind.Colon)) {
            return this.labelStatement();
        }
        // TODO: support multi-statements
        return this.setStatement(...additionalterminators);
    }
    whileStatement() {
        const whileKeyword = this.advance();
        const condition = this.expression();
        let comment;
        if (this.check(lexer_1.TokenKind.Comment)) {
            comment = this.commentStatement();
        }
        //support an optional single colon after the condition
        if (this.check(lexer_1.TokenKind.Colon)) {
            this.advance();
        }
        this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineAfterWhileCondition(), lexer_1.TokenKind.Newline);
        while (this.match(lexer_1.TokenKind.Newline)) { }
        const whileBlock = this.block(lexer_1.TokenKind.EndWhile);
        if (!whileBlock) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.couldNotFindMatchingEndKeyword('while')), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        //set comment as first statement in block
        if (comment) {
            whileBlock.statements.unshift(comment);
        }
        const endWhile = this.advance();
        while (this.match(lexer_1.TokenKind.Newline)) {
        }
        return new Statement_1.WhileStatement({ while: whileKeyword, endWhile: endWhile }, condition, whileBlock);
    }
    exitWhile() {
        let keyword = this.advance();
        if (this.checkAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Comment) === false) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedNewlineAfterExitWhile()), { range: this.peek().range }));
        }
        while (this.match(lexer_1.TokenKind.Newline)) { }
        return new Statement_1.ExitWhileStatement({ exitWhile: keyword });
    }
    forStatement() {
        const forToken = this.advance();
        const initializer = this.assignment(lexer_1.TokenKind.To);
        const toToken = this.advance();
        const finalValue = this.expression();
        let incrementExpression;
        let stepToken;
        if (this.check(lexer_1.TokenKind.Step)) {
            stepToken = this.advance();
            incrementExpression = this.expression();
        }
        else {
            // BrightScript for/to/step loops default to a step of 1 if no `step` is provided
        }
        //support an optional single colon after the `to` expression
        if (this.check(lexer_1.TokenKind.Colon)) {
            this.advance();
        }
        while (this.match(lexer_1.TokenKind.Newline)) { }
        let body = this.block(lexer_1.TokenKind.EndFor, lexer_1.TokenKind.Next);
        if (!body) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedEndForOrNextToTerminateForLoop()), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        let endForToken = this.advance();
        while (this.match(lexer_1.TokenKind.Newline)) { }
        // WARNING: BrightScript doesn't delete the loop initial value after a for/to loop! It just
        // stays around in scope with whatever value it was when the loop exited.
        return new Statement_1.ForStatement(forToken, initializer, toToken, finalValue, body, endForToken, stepToken, incrementExpression);
    }
    forEachStatement() {
        let forEach = this.advance();
        let name = this.advance();
        let maybeIn = this.peek();
        if (this.check(lexer_1.TokenKind.Identifier) && maybeIn.text.toLowerCase() === 'in') {
            this.advance();
        }
        else {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedInAfterForEach(name.text)), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        let target = this.expression();
        if (!target) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedExpressionAfterForEachIn()), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        let comment;
        if (this.check(lexer_1.TokenKind.Comment)) {
            comment = this.commentStatement();
        }
        this.advance();
        while (this.match(lexer_1.TokenKind.Newline)) {
        }
        let body = this.block(lexer_1.TokenKind.EndFor, lexer_1.TokenKind.Next);
        if (!body) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedEndForOrNextToTerminateForLoop()), { range: this.peek().range }));
            throw this.lastDiagnosticAsError();
        }
        //add comment to beginning of block of avaiable
        if (comment) {
            body.statements.unshift(comment);
        }
        let endFor = this.advance();
        while (this.match(lexer_1.TokenKind.Newline)) { }
        return new Statement_1.ForEachStatement({
            forEach: forEach,
            in: maybeIn,
            endFor: endFor
        }, name, target, body);
    }
    exitFor() {
        let keyword = this.advance();
        if (!this.check(lexer_1.TokenKind.Comment)) {
            this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineAfterExitFor(), lexer_1.TokenKind.Newline);
            while (this.match(lexer_1.TokenKind.Newline)) { }
        }
        return new Statement_1.ExitForStatement({ exitFor: keyword });
    }
    commentStatement() {
        //if this comment is on the same line as the previous statement,
        //then this comment should be treated as a single-line comment
        let prev = this.previous();
        if (prev && prev.range.end.line === this.peek().range.start.line) {
            return new Statement_1.CommentStatement([this.advance()]);
        }
        else {
            let comments = [this.advance()];
            while (this.check(lexer_1.TokenKind.Newline)) {
                //absorb newlines
                while (this.match(lexer_1.TokenKind.Newline)) { }
                //if this is a comment, and it's the next line down from the previous comment
                if (this.check(lexer_1.TokenKind.Comment) && comments[comments.length - 1].range.end.line === this.peek().range.start.line - 1) {
                    comments.push(this.advance());
                }
                else {
                    break;
                }
            }
            return new Statement_1.CommentStatement(comments);
        }
    }
    namespaceStatement() {
        this.warnIfNotBrighterScriptMode('namespace');
        let keyword = this.advance();
        if (!this.isAtRootLevel()) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.keywordMustBeDeclaredAtRootLevel('namespace')), { range: keyword.range }));
        }
        this.namespaceAndFunctionDepth++;
        let name = this.getNamespacedVariableNameExpression();
        //the only thing allowed after a namespace declaration is a comment or a newline
        this.flagUntil(lexer_1.TokenKind.Comment, lexer_1.TokenKind.Newline);
        //set the current namespace name
        this.currentNamespaceName = name;
        this.globalTerminators.push([lexer_1.TokenKind.EndNamespace]);
        let body = this.body();
        this.globalTerminators.pop();
        //unset the current namespace name
        this.currentNamespaceName = undefined;
        let endKeyword;
        if (this.check(lexer_1.TokenKind.EndNamespace)) {
            endKeyword = this.advance();
        }
        else {
            //the `end namespace` keyword is missing. add a diagnostic, but keep parsing
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.couldNotFindMatchingEndKeyword('namespace')), { range: keyword.range }));
        }
        //scrap newlines
        while (this.match(lexer_1.TokenKind.Newline)) { }
        this.namespaceAndFunctionDepth--;
        let result = new Statement_1.NamespaceStatement(keyword, name, body, endKeyword);
        this._references.namespaceStatements.push(result);
        return result;
    }
    /**
     * Get an expression with identifiers separated by periods. Useful for namespaces and class extends
     */
    getNamespacedVariableNameExpression() {
        let firstIdentifier = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedIdentifierAfterKeyword(this.previous().text), lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers);
        let expr;
        if (firstIdentifier) {
            // force it into an identifier so the AST makes some sense
            firstIdentifier.kind = lexer_1.TokenKind.Identifier;
            expr = new Expression_1.VariableExpression(firstIdentifier, null);
            //consume multiple dot identifiers (i.e. `Name.Space.Can.Have.Many.Parts`)
            while (this.check(lexer_1.TokenKind.Dot)) {
                let dot = this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.foundUnexpectedToken(this.peek().text), lexer_1.TokenKind.Dot);
                if (!dot) {
                    break;
                }
                let identifier = this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.expectedIdentifier(), lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers, ...lexer_1.AllowedProperties);
                // force it into an identifier so the AST makes some sense
                identifier.kind = lexer_1.TokenKind.Identifier;
                if (!identifier) {
                    break;
                }
                expr = new Expression_1.DottedGetExpression(expr, identifier, dot);
            }
        }
        return new Expression_1.NamespacedVariableNameExpression(expr);
    }
    /**
     * Add an 'unexpected token' diagnostic for any token found between current and the first stopToken found.
     */
    flagUntil(...stopTokens) {
        while (!this.checkAny(...stopTokens) && !this.isAtEnd()) {
            let token = this.advance();
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.foundUnexpectedToken(token.text)), { range: token.range }));
        }
    }
    /**
     * Consume tokens until one of the `stopTokenKinds` is encountered
     * @param tokenKinds
     * @return - the list of tokens consumed, EXCLUDING the `stopTokenKind` (you can use `this.peek()` to see which one it was)
     */
    consumeUntil(...stopTokenKinds) {
        let result = [];
        //take tokens until we encounter one of the stopTokenKinds
        while (!stopTokenKinds.includes(this.peek().kind)) {
            result.push(this.advance());
        }
        return result;
    }
    libraryStatement() {
        let libStatement = new Statement_1.LibraryStatement({
            library: this.advance(),
            //grab the next token only if it's a string
            filePath: this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.expectedStringLiteralAfterKeyword('library'), lexer_1.TokenKind.StringLiteral)
        });
        //consume all tokens until the end of the line
        this.flagUntil(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Comment);
        //consume to the next newline, eof, or colon
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Colon)) { }
        this._references.libraryStatements.push(libStatement);
        return libStatement;
    }
    importStatement() {
        this.warnIfNotBrighterScriptMode('import statements');
        let importStatement = new Statement_1.ImportStatement(this.advance(), 
        //grab the next token only if it's a string
        this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.expectedStringLiteralAfterKeyword('import'), lexer_1.TokenKind.StringLiteral));
        //consume all tokens until the end of the line
        this.flagUntil(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Comment);
        //consume to the next newline, eof, or colon
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Colon)) { }
        this._references.importStatements.push(importStatement);
        return importStatement;
    }
    annotationExpression() {
        let annotation = new Expression_1.AnnotationExpression(this.advance(), this.advance());
        this.pendingAnnotations.push(annotation);
        //optional arguments
        if (this.check(lexer_1.TokenKind.LeftParen)) {
            let leftParen = this.advance();
            annotation.call = this.finishCall(leftParen, annotation, false);
        }
        //consume to the next newline, eof, or colon
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Colon)) { }
    }
    templateString(isTagged) {
        this.warnIfNotBrighterScriptMode('template string');
        //get the tag name
        let tagName;
        if (isTagged) {
            tagName = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedIdentifier(), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
            // force it into an identifier so the AST makes some sense
            tagName.kind = lexer_1.TokenKind.Identifier;
        }
        let quasis = [];
        let expressions = [];
        let openingBacktick = this.peek();
        this.advance();
        let currentQuasiExpressionParts = [];
        while (!this.isAtEnd() && !this.check(lexer_1.TokenKind.BackTick)) {
            let next = this.peek();
            if (next.kind === lexer_1.TokenKind.TemplateStringQuasi) {
                //a quasi can actually be made up of multiple quasis when it includes char literals
                currentQuasiExpressionParts.push(new Expression_1.LiteralExpression(next));
                this.advance();
            }
            else if (next.kind === lexer_1.TokenKind.EscapedCharCodeLiteral) {
                currentQuasiExpressionParts.push(new Expression_1.EscapedCharCodeLiteralExpression(next));
                this.advance();
            }
            else {
                //finish up the current quasi
                quasis.push(new Expression_1.TemplateStringQuasiExpression(currentQuasiExpressionParts));
                currentQuasiExpressionParts = [];
                if (next.kind === lexer_1.TokenKind.TemplateStringExpressionBegin) {
                    this.advance();
                }
                //now keep this expression
                expressions.push(this.expression());
                if (!this.isAtEnd() && this.check(lexer_1.TokenKind.TemplateStringExpressionEnd)) {
                    //TODO is it an error if this is not present?
                    this.advance();
                }
                else {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unterminatedTemplateExpression()), { range: util_1.util.getRange(openingBacktick, this.peek()) }));
                    throw this.lastDiagnosticAsError();
                }
            }
        }
        //store the final set of quasis
        quasis.push(new Expression_1.TemplateStringQuasiExpression(currentQuasiExpressionParts));
        if (this.isAtEnd()) {
            //error - missing backtick
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unterminatedTemplateStringAtEndOfFile()), { range: util_1.util.getRange(openingBacktick, this.peek()) }));
            throw this.lastDiagnosticAsError();
        }
        else {
            let closingBacktick = this.advance();
            if (isTagged) {
                return new Expression_1.TaggedTemplateStringExpression(tagName, openingBacktick, quasis, expressions, closingBacktick);
            }
            else {
                return new Expression_1.TemplateStringExpression(openingBacktick, quasis, expressions, closingBacktick);
            }
        }
    }
    tryCatchStatement() {
        const tryToken = this.advance();
        const statement = new Statement_1.TryCatchStatement(tryToken);
        //consume one or more newlines
        while (this.match(lexer_1.TokenKind.Newline)) { }
        //consume exactly 1 colon token if exists
        this.match(lexer_1.TokenKind.Colon);
        statement.tryBranch = this.block(lexer_1.TokenKind.Catch);
        statement.catchToken = this.advance();
        const exceptionVarToken = this.tryConsume(DiagnosticMessages_1.DiagnosticMessages.missingExceptionVarToFollowCatch(), lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers);
        if (exceptionVarToken) {
            // force it into an identifier so the AST makes some sense
            exceptionVarToken.kind = lexer_1.TokenKind.Identifier;
            statement.exceptionVariable = exceptionVarToken;
        }
        //consume one or more newlines
        while (this.match(lexer_1.TokenKind.Newline)) { }
        //consume exactly 1 colon token if exists
        this.match(lexer_1.TokenKind.Colon);
        statement.catchBranch = this.block(lexer_1.TokenKind.EndTry);
        //consume exactly 1 colon token if exists
        this.match(lexer_1.TokenKind.Colon);
        statement.endTryToken = this.advance();
        return statement;
    }
    throwStatement() {
        const throwToken = this.advance();
        let expression;
        if (this.checkAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
            this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.missingExceptionExpressionAfterThrowKeyword()), { range: throwToken.range }));
        }
        else {
            expression = this.expression();
        }
        return new Statement_1.ThrowStatement(throwToken, expression);
    }
    ifStatement() {
        const ifToken = this.advance();
        const startingRange = ifToken.range;
        const condition = this.expression();
        let thenBranch;
        let elseIfBranches = [];
        let elseBranch;
        let thenToken;
        let endIfToken;
        let elseToken;
        if (this.check(lexer_1.TokenKind.Then)) {
            // `then` is optional after `if ...condition...`, so only advance to the next token if `then` is present
            thenToken = this.advance();
        }
        let comment;
        if (this.check(lexer_1.TokenKind.Comment)) {
            comment = this.commentStatement();
        }
        if (this.match(lexer_1.TokenKind.Newline) || this.match(lexer_1.TokenKind.Colon)) {
            //consume until no more colons
            while (this.check(lexer_1.TokenKind.Colon)) {
                this.advance();
            }
            //consume exactly 1 newline, if found
            if (this.check(lexer_1.TokenKind.Newline)) {
                this.advance();
            }
            //keep track of the current error count, because if the then branch fails,
            //we will trash them in favor of a single error on if
            let diagnosticsLengthBeforeBlock = this.diagnostics.length;
            // we're parsing a multi-line ("block") form of the BrightScript if/then/else and must find
            // a trailing "end if"
            let maybeThenBranch = this.block(lexer_1.TokenKind.EndIf, lexer_1.TokenKind.Else, lexer_1.TokenKind.ElseIf);
            if (!maybeThenBranch) {
                //throw out any new diagnostics created as a result of a `then` block parse failure.
                //the block() function will discard the current line, so any discarded diagnostics will
                //resurface if they are legitimate, and not a result of a malformed if statement
                this.diagnostics.splice(diagnosticsLengthBeforeBlock, this.diagnostics.length - diagnosticsLengthBeforeBlock);
                //this whole if statement is bogus...add error to the if token and hard-fail
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedEndIfElseIfOrElseToTerminateThenBlock()), { range: ifToken.range }));
                throw this.lastDiagnosticAsError();
            }
            //add any comment from the same line as the if statement
            if (comment) {
                maybeThenBranch.statements.unshift(comment);
            }
            let blockEnd = this.previous();
            if (blockEnd.kind === lexer_1.TokenKind.EndIf) {
                endIfToken = blockEnd;
            }
            thenBranch = maybeThenBranch;
            this.match(lexer_1.TokenKind.Newline);
            // attempt to read a bunch of "else if" clauses
            while (this.check(lexer_1.TokenKind.ElseIf)) {
                let elseIfToken = this.advance();
                let elseIfCondition = this.expression();
                let thenToken;
                if (this.check(lexer_1.TokenKind.Then)) {
                    // `then` is optional after `else if ...condition...`, so only advance to the next token if `then` is present
                    thenToken = this.advance();
                }
                //consume any trailing colons
                while (this.check(lexer_1.TokenKind.Colon)) {
                    this.advance();
                }
                while (this.match(lexer_1.TokenKind.Newline)) { }
                let elseIfThen = this.block(lexer_1.TokenKind.EndIf, lexer_1.TokenKind.Else, lexer_1.TokenKind.ElseIf);
                if (!elseIfThen) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedEndIfElseIfOrElseToTerminateThenBlock()), { range: this.peek().range }));
                }
                let blockEnd = this.previous();
                if (blockEnd.kind === lexer_1.TokenKind.EndIf) {
                    endIfToken = blockEnd;
                }
                elseIfBranches.push({
                    condition: elseIfCondition,
                    thenBranch: elseIfThen,
                    thenToken: thenToken,
                    elseIfToken: elseIfToken
                });
            }
            if (this.match(lexer_1.TokenKind.Else)) {
                elseToken = this.previous();
                //consume any trailing colons
                while (this.check(lexer_1.TokenKind.Colon)) {
                    this.advance();
                }
                while (this.match(lexer_1.TokenKind.Newline)) { }
                elseBranch = this.block(lexer_1.TokenKind.EndIf);
                endIfToken = this.advance(); // skip past "end if"
                //ensure that single-line `if` statements have a colon right before 'end if'
                if (util_1.util.sameStartLine(ifToken, endIfToken)) {
                    let index = this.tokens.indexOf(endIfToken);
                    let previousToken = this.tokens[index - 1];
                    if (previousToken.kind !== lexer_1.TokenKind.Colon) {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedColonToPreceedEndIf()), { range: ifToken.range }));
                    }
                }
                this.match(lexer_1.TokenKind.Newline);
            }
            else {
                this.match(lexer_1.TokenKind.Newline);
                endIfToken = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedEndIfToCloseIfStatement(startingRange.start), lexer_1.TokenKind.EndIf);
                //ensure that single-line `if` statements have a colon right before 'end if'
                if (util_1.util.sameStartLine(ifToken, endIfToken)) {
                    let index = this.tokens.indexOf(endIfToken);
                    let previousToken = this.tokens[index - 1];
                    if (previousToken.kind !== lexer_1.TokenKind.Colon) {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedColonToPreceedEndIf()), { range: endIfToken.range }));
                    }
                }
                this.match(lexer_1.TokenKind.Newline);
            }
        }
        else {
            let thenStatement = this.declaration(lexer_1.TokenKind.ElseIf, lexer_1.TokenKind.Else);
            if (!thenStatement) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedStatementToFollowConditionalCondition(ifToken.text)), { range: this.peek().range }));
                throw this.lastDiagnosticAsError();
            }
            thenBranch = new Statement_1.Block([thenStatement], this.peek().range);
            //add any comment from the same line as the if statement
            if (comment) {
                thenBranch.statements.unshift(comment);
            }
            while (this.previous().kind !== lexer_1.TokenKind.Newline && this.match(lexer_1.TokenKind.ElseIf)) {
                let elseIf = this.previous();
                let elseIfCondition = this.expression();
                let thenToken;
                if (this.check(lexer_1.TokenKind.Then)) {
                    // `then` is optional after `else if ...condition...`, so only advance to the next token if `then` is present
                    thenToken = this.advance();
                }
                let elseIfThen = this.declaration(lexer_1.TokenKind.ElseIf, lexer_1.TokenKind.Else);
                if (!elseIfThen) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedStatementToFollowConditionalCondition(elseIf.text)), { range: this.peek().range }));
                    throw this.lastDiagnosticAsError();
                }
                elseIfBranches.push({
                    condition: elseIfCondition,
                    thenBranch: new Statement_1.Block([elseIfThen], this.peek().range),
                    thenToken: thenToken,
                    elseIfToken: elseIf
                });
            }
            if (this.previous().kind !== lexer_1.TokenKind.Newline && this.match(lexer_1.TokenKind.Else)) {
                elseToken = this.previous();
                let elseStatement = this.declaration();
                if (!elseStatement) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedStatementToFollowElse()), { range: this.peek().range }));
                    throw this.lastDiagnosticAsError();
                }
                elseBranch = new Statement_1.Block([elseStatement], this.peek().range);
            }
        }
        return new Statement_1.IfStatement({
            if: ifToken,
            then: thenToken,
            endIf: endIfToken,
            else: elseToken
        }, condition, thenBranch, elseIfBranches, elseBranch);
    }
    expressionStatement(expr, additionalTerminators) {
        let expressionStart = this.peek();
        if (this.checkAny(lexer_1.TokenKind.PlusPlus, lexer_1.TokenKind.MinusMinus)) {
            let operator = this.advance();
            if (this.checkAny(lexer_1.TokenKind.PlusPlus, lexer_1.TokenKind.MinusMinus)) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.consecutiveIncrementDecrementOperatorsAreNotAllowed()), { range: this.peek().range }));
                throw this.lastDiagnosticAsError();
            }
            else if (reflection_1.isCallExpression(expr)) {
                this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.incrementDecrementOperatorsAreNotAllowedAsResultOfFunctionCall()), { range: expressionStart.range }));
                throw this.lastDiagnosticAsError();
            }
            while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
            }
            return new Statement_1.IncrementStatement(expr, operator);
        }
        if (!this.checkAny(...additionalTerminators, lexer_1.TokenKind.Comment)) {
            this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterExpressionStatement(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Eof);
        }
        if (reflection_1.isCallExpression(expr) || reflection_1.isCallfuncExpression(expr)) {
            return new Statement_1.ExpressionStatement(expr);
        }
        //at this point, it's probably an error. However, we recover a little more gracefully by creating an assignment
        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.expectedStatementOrFunctionCallButReceivedExpression()), { range: expressionStart.range }));
        throw this.lastDiagnosticAsError();
    }
    setStatement(...additionalTerminators) {
        /**
         * Attempts to find an expression-statement or an increment statement.
         * While calls are valid expressions _and_ statements, increment (e.g. `foo++`)
         * statements aren't valid expressions. They _do_ however fall under the same parsing
         * priority as standalone function calls though, so we can parse them in the same way.
         */
        let expr = this.call();
        if (this.checkAny(...lexer_1.AssignmentOperators) && !(reflection_1.isCallExpression(expr))) {
            let left = expr;
            let operator = this.advance();
            let right = this.expression();
            // Create a dotted or indexed "set" based on the left-hand side's type
            if (reflection_1.isIndexedGetExpression(left)) {
                this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterIndexedSetStatement(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Else, lexer_1.TokenKind.ElseIf, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Comment);
                //if we just consumed a comment, backtrack 1 token so it can be collected later
                if (this.checkPrevious(lexer_1.TokenKind.Comment)) {
                    this.current--;
                }
                return new Statement_1.IndexedSetStatement(left.obj, left.index, operator.kind === lexer_1.TokenKind.Equal
                    ? right
                    : new Expression_1.BinaryExpression(left, operator, right), left.openingSquare, left.closingSquare);
            }
            else if (reflection_1.isDottedGetExpression(left)) {
                this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterDottedSetStatement(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Else, lexer_1.TokenKind.ElseIf, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Eof, lexer_1.TokenKind.Comment);
                //if we just consumed a comment, backtrack 1 token so it can be collected later
                if (this.checkPrevious(lexer_1.TokenKind.Comment)) {
                    this.current--;
                }
                return new Statement_1.DottedSetStatement(left.obj, left.name, operator.kind === lexer_1.TokenKind.Equal
                    ? right
                    : new Expression_1.BinaryExpression(left, operator, right));
            }
            else {
                return this.expressionStatement(expr, additionalTerminators);
            }
        }
        else {
            return this.expressionStatement(expr, additionalTerminators);
        }
    }
    printStatement(...additionalterminators) {
        let printKeyword = this.advance();
        let values = [];
        //print statements can be empty, so look for empty print conditions
        if (this.isAtEnd() || this.checkAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
            //TODO we aren't a runtime, so do we need to do this?
            let emptyStringLiteral = creators_1.createStringLiteral('');
            values.push(emptyStringLiteral);
        }
        else {
            values.push(this.expression());
        }
        while (!this.checkAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon, ...additionalterminators, lexer_1.TokenKind.Comment) && !this.isAtEnd()) {
            if (this.check(lexer_1.TokenKind.Semicolon)) {
                values.push(this.advance());
            }
            if (this.check(lexer_1.TokenKind.Comma)) {
                values.push(this.advance());
            }
            if (!this.checkAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon) && !this.isAtEnd()) {
                values.push(this.expression());
            }
        }
        if (!this.checkAny(...additionalterminators, lexer_1.TokenKind.Comment)) {
            this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedNewlineOrColonAfterPrintedValues(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Eof);
        }
        //consume excess newlines
        while (this.match(lexer_1.TokenKind.Newline)) { }
        return new Statement_1.PrintStatement({ print: printKeyword }, values);
    }
    /**
     * Parses a return statement with an optional return value.
     * @returns an AST representation of a return statement.
     */
    returnStatement() {
        let tokens = { return: this.previous() };
        if (this.checkAny(lexer_1.TokenKind.Colon, lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof)) {
            while (this.matchAny(lexer_1.TokenKind.Colon, lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof)) { }
            return new Statement_1.ReturnStatement(tokens);
        }
        let toReturn = this.expression();
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
        }
        return new Statement_1.ReturnStatement(tokens, toReturn);
    }
    /**
     * Parses a `label` statement
     * @returns an AST representation of an `label` statement.
     */
    labelStatement() {
        let tokens = {
            identifier: this.advance(),
            colon: this.advance()
        };
        if (!this.check(lexer_1.TokenKind.Comment)) {
            this.consume(DiagnosticMessages_1.DiagnosticMessages.labelsMustBeDeclaredOnTheirOwnLine(), lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof);
        }
        return new Statement_1.LabelStatement(tokens);
    }
    /**
     * Parses a `goto` statement
     * @returns an AST representation of an `goto` statement.
     */
    gotoStatement() {
        let tokens = {
            goto: this.advance(),
            label: this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedLabelIdentifierAfterGotoKeyword(), lexer_1.TokenKind.Identifier)
        };
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) { }
        return new Statement_1.GotoStatement(tokens);
    }
    /**
     * Parses an `end` statement
     * @returns an AST representation of an `end` statement.
     */
    endStatement() {
        let endTokens = { end: this.advance() };
        while (this.match(lexer_1.TokenKind.Newline)) { }
        return new Statement_1.EndStatement(endTokens);
    }
    /**
     * Parses a `stop` statement
     * @returns an AST representation of a `stop` statement
     */
    stopStatement() {
        let tokens = { stop: this.advance() };
        while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
        }
        return new Statement_1.StopStatement(tokens);
    }
    /**
     * Parses a block, looking for a specific terminating TokenKind to denote completion.
     * @param terminators the token(s) that signifies the end of this block; all other terminators are
     *                    ignored.
     */
    block(...terminators) {
        let startingToken = this.peek();
        const statements = [];
        while (!this.checkAny(...terminators) && !this.isAtEnd()) {
            //grab the location of the current token
            let loopCurrent = this.current;
            let dec = this.declaration();
            if (dec) {
                //attach annotations to statements
                if (this.pendingAnnotations.length) {
                    dec.annotations = this.pendingAnnotations;
                    this.pendingAnnotations = [];
                }
                statements.push(dec);
            }
            else {
                //something went wrong. reset to the top of the loop
                this.current = loopCurrent;
                //scrap the entire line (hopefully whatever failed has added a diagnostic)
                this.consumeUntil(lexer_1.TokenKind.Colon, lexer_1.TokenKind.Newline, lexer_1.TokenKind.Eof);
                //trash the next token. this prevents an infinite loop. not exactly sure why we need this,
                //but there's already an error in the file being parsed, so just leave this line here
                this.advance();
            }
            //trash any newline characters
            while (this.match(lexer_1.TokenKind.Newline)) { }
        }
        if (this.isAtEnd()) {
            return undefined;
            // TODO: Figure out how to handle unterminated blocks well
        }
        return new Statement_1.Block(statements, startingToken.range);
    }
    expression() {
        return this.anonymousFunction();
    }
    anonymousFunction() {
        if (this.checkAny(lexer_1.TokenKind.Sub, lexer_1.TokenKind.Function)) {
            return this.functionDeclaration(true);
        }
        //template string
        if (this.check(lexer_1.TokenKind.BackTick)) {
            return this.templateString(false);
            //tagged template string (currently we do not support spaces between the identifier and the backtick
        }
        else if (this.checkAny(lexer_1.TokenKind.Identifier, ...lexer_1.AllowedLocalIdentifiers) && this.checkNext(lexer_1.TokenKind.BackTick)) {
            return this.templateString(true);
        }
        return this.boolean();
    }
    boolean() {
        let expr = this.relational();
        while (this.matchAny(lexer_1.TokenKind.And, lexer_1.TokenKind.Or)) {
            let operator = this.previous();
            let right = this.relational();
            expr = new Expression_1.BinaryExpression(expr, operator, right);
        }
        return expr;
    }
    relational() {
        let expr = this.additive();
        while (this.matchAny(lexer_1.TokenKind.Equal, lexer_1.TokenKind.LessGreater, lexer_1.TokenKind.Greater, lexer_1.TokenKind.GreaterEqual, lexer_1.TokenKind.Less, lexer_1.TokenKind.LessEqual)) {
            let operator = this.previous();
            let right = this.additive();
            expr = new Expression_1.BinaryExpression(expr, operator, right);
        }
        return expr;
    }
    // TODO: bitshift
    additive() {
        let expr = this.multiplicative();
        while (this.matchAny(lexer_1.TokenKind.Plus, lexer_1.TokenKind.Minus)) {
            let operator = this.previous();
            let right = this.multiplicative();
            expr = new Expression_1.BinaryExpression(expr, operator, right);
        }
        return expr;
    }
    multiplicative() {
        let expr = this.exponential();
        while (this.matchAny(lexer_1.TokenKind.Forwardslash, lexer_1.TokenKind.Backslash, lexer_1.TokenKind.Star, lexer_1.TokenKind.Mod, lexer_1.TokenKind.LeftShift, lexer_1.TokenKind.RightShift)) {
            let operator = this.previous();
            let right = this.exponential();
            expr = new Expression_1.BinaryExpression(expr, operator, right);
        }
        return expr;
    }
    exponential() {
        let expr = this.prefixUnary();
        while (this.match(lexer_1.TokenKind.Caret)) {
            let operator = this.previous();
            let right = this.prefixUnary();
            expr = new Expression_1.BinaryExpression(expr, operator, right);
        }
        return expr;
    }
    prefixUnary() {
        const nextKind = this.peek().kind;
        if (nextKind === lexer_1.TokenKind.Not || nextKind === lexer_1.TokenKind.Minus) {
            this.current++; //advance
            let operator = this.previous();
            let right = this.prefixUnary();
            return new Expression_1.UnaryExpression(operator, right);
        }
        return this.call();
    }
    indexedGet(expr) {
        let openingSquare = this.previous();
        while (this.match(lexer_1.TokenKind.Newline)) { }
        let index = this.expression();
        while (this.match(lexer_1.TokenKind.Newline)) { }
        let closingSquare = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedRightSquareBraceAfterArrayOrObjectIndex(), lexer_1.TokenKind.RightSquareBracket);
        return new Expression_1.IndexedGetExpression(expr, index, openingSquare, closingSquare);
    }
    newExpression() {
        this.warnIfNotBrighterScriptMode(`using 'new' keyword to construct a class`);
        let newToken = this.advance();
        let nameExpr = this.getNamespacedVariableNameExpression();
        let leftParen = this.consume(DiagnosticMessages_1.DiagnosticMessages.foundUnexpectedToken(this.peek().text), lexer_1.TokenKind.LeftParen);
        let call = this.finishCall(leftParen, nameExpr);
        //pop the call from the  callExpressions list because this is technically something else
        this.callExpressions.pop();
        let result = new Expression_1.NewExpression(newToken, call);
        this._references.newExpressions.push(result);
        return result;
    }
    /**
     * A callfunc expression (i.e. `node@.someFunctionOnNode()`)
     */
    callfunc(callee) {
        this.warnIfNotBrighterScriptMode('callfunc operator');
        let operator = this.previous();
        let methodName = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedIdentifier(), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
        // force it into an identifier so the AST makes some sense
        methodName.kind = lexer_1.TokenKind.Identifier;
        let openParen = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedOpenParenToFollowCallfuncIdentifier(), lexer_1.TokenKind.LeftParen);
        let call = this.finishCall(openParen, callee, false);
        return new Expression_1.CallfuncExpression(callee, operator, methodName, openParen, call.args, call.closingParen);
    }
    call() {
        if (this.check(lexer_1.TokenKind.New) && this.checkAnyNext(lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers)) {
            return this.newExpression();
        }
        let expr = this.primary();
        while (true) {
            if (this.match(lexer_1.TokenKind.LeftParen)) {
                expr = this.finishCall(this.previous(), expr);
            }
            else if (this.match(lexer_1.TokenKind.LeftSquareBracket)) {
                expr = this.indexedGet(expr);
            }
            else if (this.match(lexer_1.TokenKind.Callfunc)) {
                expr = this.callfunc(expr);
            }
            else if (this.match(lexer_1.TokenKind.Dot)) {
                if (this.match(lexer_1.TokenKind.LeftSquareBracket)) {
                    expr = this.indexedGet(expr);
                }
                else {
                    let dot = this.previous();
                    let name = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedPropertyNameAfterPeriod(), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
                    // force it into an identifier so the AST makes some sense
                    name.kind = lexer_1.TokenKind.Identifier;
                    expr = new Expression_1.DottedGetExpression(expr, name, dot);
                    this.addPropertyHints(name);
                }
            }
            else if (this.check(lexer_1.TokenKind.At)) {
                let dot = this.advance();
                let name = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedAttributeNameAfterAtSymbol(), lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties);
                // force it into an identifier so the AST makes some sense
                name.kind = lexer_1.TokenKind.Identifier;
                expr = new Expression_1.XmlAttributeGetExpression(expr, name, dot);
                //only allow a single `@` expression
                break;
            }
            else {
                break;
            }
        }
        return expr;
    }
    finishCall(openingParen, callee, addToCallExpressionList = true) {
        let args = [];
        while (this.match(lexer_1.TokenKind.Newline)) {
        }
        if (!this.check(lexer_1.TokenKind.RightParen)) {
            do {
                while (this.match(lexer_1.TokenKind.Newline)) { }
                if (args.length >= Expression_1.CallExpression.MaximumArguments) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.tooManyCallableArguments(args.length, Expression_1.CallExpression.MaximumArguments)), { range: this.peek().range }));
                    throw this.lastDiagnosticAsError();
                }
                args.push(this.expression());
            } while (this.match(lexer_1.TokenKind.Comma));
        }
        while (this.match(lexer_1.TokenKind.Newline)) { }
        const closingParen = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedRightParenAfterFunctionCallArguments(), lexer_1.TokenKind.RightParen);
        if (reflection_1.isVariableExpression(callee)) {
            callee.isCalled = true;
        }
        let expression = new Expression_1.CallExpression(callee, openingParen, closingParen, args, this.currentNamespaceName);
        if (addToCallExpressionList) {
            this.callExpressions.push(expression);
        }
        return expression;
    }
    primary() {
        switch (true) {
            case this.matchAny(lexer_1.TokenKind.False, lexer_1.TokenKind.True, lexer_1.TokenKind.Invalid, lexer_1.TokenKind.IntegerLiteral, lexer_1.TokenKind.LongIntegerLiteral, lexer_1.TokenKind.FloatLiteral, lexer_1.TokenKind.DoubleLiteral, lexer_1.TokenKind.StringLiteral):
                return new Expression_1.LiteralExpression(this.previous());
            //capture source literals (LINE_NUM if brightscript, or a bunch of them if brighterscript)
            case this.matchAny(lexer_1.TokenKind.LineNumLiteral, ...(this.options.mode === ParseMode.BrightScript ? [] : lexer_1.BrighterScriptSourceLiterals)):
                return new Expression_1.SourceLiteralExpression(this.previous());
            case this.matchAny(lexer_1.TokenKind.Identifier, ...this.allowedLocalIdentifiers):
                return new Expression_1.VariableExpression(this.previous(), this.currentNamespaceName);
            case this.match(lexer_1.TokenKind.LeftParen):
                let left = this.previous();
                let expr = this.expression();
                let right = this.consume(DiagnosticMessages_1.DiagnosticMessages.unmatchedLeftParenAfterExpression(), lexer_1.TokenKind.RightParen);
                return new Expression_1.GroupingExpression({ left: left, right: right }, expr);
            case this.match(lexer_1.TokenKind.LeftSquareBracket):
                let elements = [];
                let openingSquare = this.previous();
                //add any comment found right after the opening square
                if (this.check(lexer_1.TokenKind.Comment)) {
                    elements.push(new Statement_1.CommentStatement([this.advance()]));
                }
                while (this.match(lexer_1.TokenKind.Newline)) {
                }
                if (!this.match(lexer_1.TokenKind.RightSquareBracket)) {
                    elements.push(this.expression());
                    while (this.matchAny(lexer_1.TokenKind.Comma, lexer_1.TokenKind.Newline, lexer_1.TokenKind.Comment)) {
                        if (this.checkPrevious(lexer_1.TokenKind.Comment) || this.check(lexer_1.TokenKind.Comment)) {
                            let comment = this.check(lexer_1.TokenKind.Comment) ? this.advance() : this.previous();
                            elements.push(new Statement_1.CommentStatement([comment]));
                        }
                        while (this.match(lexer_1.TokenKind.Newline)) {
                        }
                        if (this.check(lexer_1.TokenKind.RightSquareBracket)) {
                            break;
                        }
                        elements.push(this.expression());
                    }
                    this.consume(DiagnosticMessages_1.DiagnosticMessages.unmatchedLeftSquareBraceAfterArrayLiteral(), lexer_1.TokenKind.RightSquareBracket);
                }
                let closingSquare = this.previous();
                //this.consume("Expected newline or ':' after array literal", TokenKind.Newline, TokenKind.Colon, TokenKind.Eof);
                return new Expression_1.ArrayLiteralExpression(elements, openingSquare, closingSquare);
            case this.match(lexer_1.TokenKind.LeftCurlyBrace):
                let openingBrace = this.previous();
                let members = [];
                let key = () => {
                    let result = {
                        colonToken: null,
                        keyToken: null,
                        range: null
                    };
                    if (this.checkAny(lexer_1.TokenKind.Identifier, ...lexer_1.AllowedProperties)) {
                        result.keyToken = this.advance();
                    }
                    else if (this.check(lexer_1.TokenKind.StringLiteral)) {
                        result.keyToken = this.advance();
                    }
                    else {
                        this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.unexpectedAAKey()), { range: this.peek().range }));
                        throw this.lastDiagnosticAsError();
                    }
                    result.colonToken = this.consume(DiagnosticMessages_1.DiagnosticMessages.expectedColonBetweenAAKeyAndvalue(), lexer_1.TokenKind.Colon);
                    result.range = util_1.util.getRange(result.keyToken, result.colonToken);
                    return result;
                };
                while (this.match(lexer_1.TokenKind.Newline)) {
                }
                if (!this.match(lexer_1.TokenKind.RightCurlyBrace)) {
                    if (this.check(lexer_1.TokenKind.Comment)) {
                        members.push(new Statement_1.CommentStatement([this.advance()]));
                    }
                    else {
                        let k = key();
                        let expr = this.expression();
                        members.push(new Expression_1.AAMemberExpression(k.keyToken, k.colonToken, expr));
                    }
                    while (this.matchAny(lexer_1.TokenKind.Comma, lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon, lexer_1.TokenKind.Comment)) {
                        //check for comment at the end of the current line
                        if (this.check(lexer_1.TokenKind.Comment) || this.checkPrevious(lexer_1.TokenKind.Comment)) {
                            let token = this.checkPrevious(lexer_1.TokenKind.Comment) ? this.previous() : this.advance();
                            members.push(new Statement_1.CommentStatement([token]));
                        }
                        else {
                            while (this.matchAny(lexer_1.TokenKind.Newline, lexer_1.TokenKind.Colon)) {
                            }
                            //check for a comment on its own line
                            if (this.check(lexer_1.TokenKind.Comment) || this.checkPrevious(lexer_1.TokenKind.Comment)) {
                                let token = this.checkPrevious(lexer_1.TokenKind.Comment) ? this.previous() : this.advance();
                                members.push(new Statement_1.CommentStatement([token]));
                                continue;
                            }
                            if (this.check(lexer_1.TokenKind.RightCurlyBrace)) {
                                break;
                            }
                            let k = key();
                            let expr = this.expression();
                            members.push(new Expression_1.AAMemberExpression(k.keyToken, k.colonToken, expr));
                        }
                    }
                    this.consume(DiagnosticMessages_1.DiagnosticMessages.unmatchedLeftCurlyAfterAALiteral(), lexer_1.TokenKind.RightCurlyBrace);
                }
                let closingBrace = this.previous();
                const aaExpr = new Expression_1.AALiteralExpression(members, openingBrace, closingBrace);
                this.addPropertyHints(aaExpr);
                return aaExpr;
            case this.matchAny(lexer_1.TokenKind.Pos, lexer_1.TokenKind.Tab):
                let token = Object.assign(this.previous(), {
                    kind: lexer_1.TokenKind.Identifier
                });
                return new Expression_1.VariableExpression(token, this.currentNamespaceName);
            case this.checkAny(lexer_1.TokenKind.Function, lexer_1.TokenKind.Sub):
                return this.anonymousFunction();
            case this.check(lexer_1.TokenKind.Comment):
                return new Statement_1.CommentStatement([this.advance()]);
            default:
                //if we found an expected terminator, don't throw a diagnostic...just return undefined
                if (this.checkAny(...this.peekGlobalTerminators())) {
                    //don't throw a diagnostic, just return undefined
                    //something went wrong...throw an error so the upstream processor can scrap this line and move on
                }
                else {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.foundUnexpectedToken(this.peek().text)), { range: this.peek().range }));
                    throw this.lastDiagnosticAsError();
                }
        }
    }
    /**
     * Pop tokens until we encounter a token other than the specified one
     */
    match(tokenKind) {
        if (this.check(tokenKind)) {
            this.current++; //advance
            return true;
        }
        return false;
    }
    /**
     * Pop tokens until we encounter a token not in the specified list
     * @param tokenKinds
     */
    matchAny(...tokenKinds) {
        for (let tokenKind of tokenKinds) {
            if (this.check(tokenKind)) {
                this.current++; //advance
                return true;
            }
        }
        return false;
    }
    consume(diagnosticInfo, ...tokenKinds) {
        let token = this.tryConsume(diagnosticInfo, ...tokenKinds);
        if (token) {
            return token;
        }
        else {
            let error = new Error(diagnosticInfo.message);
            error.isDiagnostic = true;
            throw error;
        }
    }
    /**
     * Consume, or add a message if not found. But then continue and return undefined
     * @param message
     * @param tokenKinds
     */
    tryConsume(diagnostic, ...tokenKinds) {
        const nextKind = this.peek().kind;
        let foundTokenKind = tokenKinds.some(tokenKind => nextKind === tokenKind);
        if (foundTokenKind) {
            return this.advance();
        }
        this.diagnostics.push(Object.assign(Object.assign({}, diagnostic), { range: this.peek().range }));
    }
    advance() {
        if (!this.isAtEnd()) {
            this.current++;
        }
        return this.previous();
    }
    checkPrevious(tokenKind) {
        return this.previous().kind === tokenKind;
    }
    check(tokenKind) {
        const nextKind = this.peek().kind;
        if (nextKind === lexer_1.TokenKind.Eof) {
            return false;
        }
        return nextKind === tokenKind;
    }
    checkAny(...tokenKinds) {
        const nextKind = this.peek().kind;
        if (nextKind === lexer_1.TokenKind.Eof) {
            return false;
        }
        return tokenKinds.some(tokenKind => nextKind === tokenKind);
    }
    checkNext(tokenKind) {
        if (this.isAtEnd()) {
            return false;
        }
        return this.peekNext().kind === tokenKind;
    }
    checkAnyNext(...tokenKinds) {
        if (this.isAtEnd()) {
            return false;
        }
        const nextKind = this.peekNext().kind;
        return tokenKinds.some(tokenKind => nextKind === tokenKind);
    }
    isAtEnd() {
        return this.peek().kind === lexer_1.TokenKind.Eof;
    }
    peekNext() {
        if (this.isAtEnd()) {
            return this.peek();
        }
        return this.tokens[this.current + 1];
    }
    peek() {
        return this.tokens[this.current];
    }
    previous() {
        return this.tokens[this.current - 1];
    }
    synchronize() {
        this.advance(); // skip the erroneous token
        while (!this.isAtEnd()) {
            if (this.previous().kind === lexer_1.TokenKind.Newline || this.previous().kind === lexer_1.TokenKind.Colon) {
                // newlines and ':' characters separate statements
                return;
            }
            switch (this.peek().kind) { //eslint-disable-line @typescript-eslint/switch-exhaustiveness-check
                case lexer_1.TokenKind.Namespace:
                case lexer_1.TokenKind.Class:
                case lexer_1.TokenKind.Function:
                case lexer_1.TokenKind.Sub:
                case lexer_1.TokenKind.If:
                case lexer_1.TokenKind.For:
                case lexer_1.TokenKind.ForEach:
                case lexer_1.TokenKind.While:
                case lexer_1.TokenKind.Print:
                case lexer_1.TokenKind.Return:
                    // start parsing again from the next block starter or obvious
                    // expression start
                    return;
            }
            this.advance();
        }
    }
    /**
     * References are found during the initial parse.
     * However, sometimes plugins can modify the AST, requiring a full walk to re-compute all references.
     * This does that walk.
     */
    findReferences() {
        this._references = createReferences();
        this.ast.walk(visitors_1.createVisitor({
            AssignmentStatement: s => {
                this._references.assignmentStatements.push(s);
            },
            ClassStatement: s => {
                this._references.classStatements.push(s);
            },
            NamespaceStatement: s => {
                this._references.namespaceStatements.push(s);
            },
            FunctionStatement: s => {
                this._references.functionStatements.push(s);
            },
            ImportStatement: s => {
                this._references.importStatements.push(s);
            },
            LibraryStatement: s => {
                this._references.libraryStatements.push(s);
            },
            FunctionExpression: (expression, parent) => {
                if (!reflection_1.isClassMethodStatement(parent)) {
                    this._references.functionExpressions.push(expression);
                }
            },
            NewExpression: e => {
                this._references.newExpressions.push(e);
            },
            AALiteralExpression: e => {
                this.addPropertyHints(e);
            },
            DottedGetExpression: e => {
                this.addPropertyHints(e.name);
            },
            DottedSetStatement: e => {
                this.addPropertyHints(e.name);
            }
        }), {
            walkMode: visitors_1.WalkMode.visitAllRecursive
        });
    }
    dispose() {
    }
}
exports.Parser = Parser;
var ParseMode;
(function (ParseMode) {
    ParseMode["BrightScript"] = "BrightScript";
    ParseMode["BrighterScript"] = "BrighterScript";
})(ParseMode = exports.ParseMode || (exports.ParseMode = {}));
function createReferences() {
    return {
        assignmentStatements: [],
        classStatements: [],
        functionExpressions: [],
        functionStatements: [],
        importStatements: [],
        libraryStatements: [],
        namespaceStatements: [],
        newExpressions: [],
        propertyHints: {}
    };
}
//# sourceMappingURL=Parser.js.map