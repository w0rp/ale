"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const Parser_1 = require("../../Parser");
const lexer_1 = require("../../../lexer");
const Parser_spec_1 = require("../Parser.spec");
describe('parser if statements', () => {
    it('allows empty if blocks', () => {
        var _a;
        let { tokens } = lexer_1.Lexer.scan(`
            if true then

            else if true then
                stop
            else
                stop
            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect((_a = diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('allows empty elseif blocks', () => {
        var _a;
        let { tokens } = lexer_1.Lexer.scan(`
            if true then
                stop
            else if true then

            else
                stop
            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect((_a = diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('allows empty else blocks', () => {
        var _a;
        let { tokens } = lexer_1.Lexer.scan(`
            if true then
                stop
            else if true then
                stop
            else

            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect((_a = diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('single-line if next to else or endif', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if type(component.TextAttrs.font) = "roString"
                font = m.fonts.Lookup(component.TextAttrs.font)
                if font = invalid then font = m.fonts.medium
            else if type(component.TextAttrs.font) = "roFont"
                font = component.TextAttrs.font
            else
                font = m.fonts.reg.GetDefaultFont()
            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('single-line if inside multi-line if', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if true
                if true then t = 1
            else
                ' empty line or line with just a comment causes crash
            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('dotted set in else block', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if true then m.top.visible = true else m.top.visible = false
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        if (diagnostics.length > 0) {
            console.log(diagnostics);
        }
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    describe('single-line if', () => {
        it('parses if only', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.token(lexer_1.TokenKind.If, 'if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Less, '<'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.token(lexer_1.TokenKind.Then, 'then'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('parses if-else', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.token(lexer_1.TokenKind.If, 'if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Less, '<'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.token(lexer_1.TokenKind.Then, 'then'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Else, 'else'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.False, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('parses if-elseif-else', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.token(lexer_1.TokenKind.If, 'if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Less, '<'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.token(lexer_1.TokenKind.Then, 'then'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.ElseIf, 'else if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.token(lexer_1.TokenKind.Then, 'then'),
                Parser_spec_1.identifier('same'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Else, 'else'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('allows \'then\' to be skipped', () => {
            let { statements, diagnostics } = Parser_1.Parser.parse([
                Parser_spec_1.token(lexer_1.TokenKind.If, 'if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Less, '<'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.ElseIf, 'else if'),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '1'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.IntegerLiteral, '2'),
                Parser_spec_1.identifier('same'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.True, 'true'),
                Parser_spec_1.token(lexer_1.TokenKind.Else, 'else'),
                Parser_spec_1.identifier('foo'),
                Parser_spec_1.token(lexer_1.TokenKind.Equal, '='),
                Parser_spec_1.token(lexer_1.TokenKind.False, 'false'),
                Parser_spec_1.token(lexer_1.TokenKind.Newline, '\n'),
                Parser_spec_1.EOF
            ]);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
    });
    describe('block if', () => {
        it('parses if only', () => {
            //because the parser depends on line numbers for certain if statements, this needs to be location-aware
            let { tokens } = lexer_1.Lexer.scan(`
                if 1 < 2 THEN
                    foo = true
                    bar = true
                end if
            `);
            let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('parses if-else', () => {
            //this test requires token locations, so use the lexer
            let { tokens } = lexer_1.Lexer.scan(`
                if 1 < 2 then
                    foo = true
                else
                    foo = false
                    bar = false
                end if
            `);
            let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('parses if-elseif-else', () => {
            //this test requires token locations, so use the lexer
            let { tokens } = lexer_1.Lexer.scan(`
                if 1 < 2 then
                    foo = true
                else if 1 > 2 then
                    foo = 3
                    bar = true
                else
                    foo = false
                end if
            `);
            let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('allows \'then\' to be skipped', () => {
            //this test requires token locations, so use the lexer
            let { tokens } = lexer_1.Lexer.scan(`
                if 1 < 2
                    foo = true
                else if 1 > 2
                    foo = 3
                    bar = true
                else
                    foo = false
                end if
            `);
            let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
        });
        it('sets endif token properly', () => {
            //this test requires token locations, so use the lexer
            let { tokens } = lexer_1.Lexer.scan(`
                sub a()
                    if true then
                        print false
                    else if true then
                        print "true"
                    else
                        print "else"
                    end if 'comment
                end sub
            `);
            let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
            chai_1.expect(diagnostics).to.be.lengthOf(0);
            chai_1.expect(statements).to.be.length.greaterThan(0);
            //the endif token should be set
            chai_1.expect(statements[0].func.body.statements[0].tokens.endIf).to.exist;
        });
    });
    it('supports trailing colons after conditional statements', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            sub main()
                if 1 > 0:
                    print "positive!"
                else if 1 < 0:
                    print "negative!"
                else:
                    print "tHaT NuMbEr iS ZeRo"
                end if
            end sub
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('supports trailing colons for one-line if statements', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2: return true: end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('catches one-line if statement missing first colon', () => {
        //missing colon after 2
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2 return true : end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.length.greaterThan(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('catches one-line if statement missing second colon', () => {
        //missing colon after `2`
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2 : return true end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.length.greaterThan(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('catches one-line if statement with else missing colons', () => {
        //missing colon after `2`
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2 : return true: else return false end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.length.greaterThan(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('catches one-line if statement with colon and missing end if', () => {
        //missing colon after `2`
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2: return true
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.length.greaterThan(0);
        chai_1.expect(statements).to.be.lengthOf(0);
    });
    it('catches one-line if statement with colon and missing end if inside a function', () => {
        //missing 'end if'
        let { tokens } = lexer_1.Lexer.scan(`
            function missingendif()
                if true : return true
            end function
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(1);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('supports if statement with condition and action on one line, but end if on separate line', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if 1 < 2: return true
            end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('supports colon after return in single-line if statement', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if false : print "true" : end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('supports if elseif endif single line', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if true: print "8 worked": else if true: print "not run": else: print "not run": end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
    it('supports one-line functions inside of one-line if statement', () => {
        let { tokens } = lexer_1.Lexer.scan(`
            if true then : test = sub() : print "yes" : end sub : end if
        `);
        let { statements, diagnostics } = Parser_1.Parser.parse(tokens);
        chai_1.expect(diagnostics).to.be.lengthOf(0);
        chai_1.expect(statements).to.be.length.greaterThan(0);
    });
});
//# sourceMappingURL=If.spec.js.map