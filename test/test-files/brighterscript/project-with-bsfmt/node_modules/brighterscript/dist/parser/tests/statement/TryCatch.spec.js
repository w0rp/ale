"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const Parser_1 = require("../../Parser");
const Statement_1 = require("../../Statement");
describe('parser try/catch', () => {
    it('can parse try catch statements', () => {
        var _a, _b, _c, _d;
        const parser = Parser_1.Parser.parse(`
            sub new()
                try
                    print "hello"
                catch e
                    print "error"
                end try
            end sub
        `);
        chai_1.expect((_a = parser.diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
        const stmt = parser.references.functionExpressions[0].body.statements[0];
        chai_1.expect(stmt).to.be.instanceof(Statement_1.TryCatchStatement);
        chai_1.expect((_b = stmt.tryToken) === null || _b === void 0 ? void 0 : _b.text).to.eql('try');
        chai_1.expect(stmt.tryBranch).to.exist.and.ownProperty('statements').to.be.lengthOf(1);
        chai_1.expect((_c = stmt.catchToken) === null || _c === void 0 ? void 0 : _c.text).to.eql('catch');
        chai_1.expect(stmt.exceptionVariable.text).to.eql('e');
        chai_1.expect(stmt.catchBranch).to.exist.and.ownProperty('statements').to.be.lengthOf(1);
        chai_1.expect((_d = stmt.endTryToken) === null || _d === void 0 ? void 0 : _d.text).to.eql('end try');
    });
    it('supports various configurations of try-catch', () => {
        function expectNoParseErrors(text) {
            var _a;
            const parser = Parser_1.Parser.parse(`
                sub main()
                    ${text}
                end sub
            `);
            chai_1.expect((_a = parser.diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
        }
        expectNoParseErrors(`
            try : print a.b.c : catch e : print "error" :  end try
        `);
        //multiple statements
        expectNoParseErrors(`
            try : print "one" : print "two" : catch e : print "error" : end try
        `);
        expectNoParseErrors(`
            try : print a.b.c
            catch e : print "error" :  end try
        `);
        expectNoParseErrors(`
            try
                print a.b.c
            catch e : print "error" :  end try
        `);
        expectNoParseErrors(`
            try
                print a.b.c
            catch e
                print "error" :  end try
        `);
        expectNoParseErrors(`
            try: print a.b.c
            catch e
                print "error" :  end try
        `);
        expectNoParseErrors(`
            try: print a.b.c :  catch e
            print "error" :  end try
        `);
        expectNoParseErrors(`
            try: print a.b.c :  catch e : print "error"
            end try
        `);
        expectNoParseErrors(`
            try
            : print a.b.c : catch e : print "error" : end try
        `);
        // expectNoParseErrors(`
        //     try : print a.b.c
        //     : catch e : print "error" : end try
        // `);
        // expectNoParseErrors(`
        //     try : print a.b.c
        //     : catch e
        //     : print "error" : end try
        // `);
        // expectNoParseErrors(`
        //     try
        //     : print a.b.c
        //     : catch e
        //     : print "error"
        //     : end try
        // `);
    });
    it('recovers gracefully with syntax errors', () => {
        var _a;
        const parser = Parser_1.Parser.parse(`
            sub new()
                try
                    print "hello"
                catch e
                    print "error"
                end try
            end sub
        `);
        chai_1.expect((_a = parser.diagnostics[0]) === null || _a === void 0 ? void 0 : _a.message).not.to.exist;
    });
});
//# sourceMappingURL=TryCatch.spec.js.map