import type { Token } from '../lexer';
import type { Statement } from './Statement';
import { FunctionStatement, AssignmentStatement, LibraryStatement, NamespaceStatement, Body, ImportStatement, ClassStatement } from './Statement';
import { FunctionExpression, NewExpression } from './Expression';
import type { Diagnostic } from 'vscode-languageserver';
import { Logger } from '../Logger';
export declare class Parser {
    /**
     * The array of tokens passed to `parse()`
     */
    tokens: Token[];
    /**
     * The current token index
     */
    current: number;
    /**
     * The list of statements for the parsed file
     */
    ast: Body;
    get statements(): Statement[];
    /**
     * References for significant statements/expressions in the parser.
     * These are initially extracted during parse-time to improve performance, but will also be dynamically regenerated if need be.
     *
     * If a plugin modifies the AST, then the plugin should call Parser#invalidateReferences() to force this list to refresh
     */
    get references(): References;
    private _references;
    /**
     * Invalidates (clears) the references collection. This should be called anytime the AST has been manipulated.
     */
    invalidateReferences(): void;
    private addPropertyHints;
    /**
     * The list of diagnostics found during the parse process
     */
    diagnostics: Diagnostic[];
    /**
     * The depth of the calls to function declarations. Helps some checks know if they are at the root or not.
     */
    private namespaceAndFunctionDepth;
    /**
     * The options used to parse the file
     */
    options: ParseOptions;
    private globalTerminators;
    /**
     * When a namespace has been started, this gets set. When it's done, this gets unset.
     * It is useful for passing the namespace into certain statements that need it
     */
    private currentNamespaceName;
    /**
     * When a FunctionExpression has been started, this gets set. When it's done, this gets unset.
     * It's useful for passing the function into statements and expressions that need to be located
     * by function later on.
     */
    private currentFunctionExpression;
    /**
     * A list of identifiers that are permitted to be used as local variables. We store this in a property because we augment the list in the constructor
     * based on the parse mode
     */
    private allowedLocalIdentifiers;
    /**
     * Annotations collected which should be attached to the next statement
     */
    private pendingAnnotations;
    /**
     * Get the currently active global terminators
     */
    private peekGlobalTerminators;
    /**
     * Static wrapper around creating a new parser and parsing a list of tokens
     */
    static parse(source: string, options?: ParseOptions): Parser;
    static parse(tokens: Token[], options?: ParseOptions): Parser;
    /**
     * Parses an array of `Token`s into an abstract syntax tree
     * @param toParse the array of tokens to parse. May not contain any whitespace tokens
     * @returns the same instance of the parser which contains the diagnostics and statements
     */
    parse(tokens: Token[], options?: ParseOptions): this;
    private logger;
    private body;
    private sanitizeParseOptions;
    /**
     * Determine if the parser is currently parsing tokens at the root level.
     */
    private isAtRootLevel;
    /**
     * Throws an error if the input file type is not BrighterScript
     */
    private warnIfNotBrighterScriptMode;
    /**
     * Throws an exception using the last diagnostic message
     */
    private lastDiagnosticAsError;
    private declaration;
    /**
     * A BrighterScript class declaration
     */
    private classDeclaration;
    private classFieldDeclaration;
    /**
     * An array of CallExpression for the current function body
     */
    private callExpressions;
    private functionDeclaration;
    private functionParameter;
    private assignment;
    private checkLibrary;
    private statement;
    private whileStatement;
    private exitWhile;
    private forStatement;
    private forEachStatement;
    private exitFor;
    private commentStatement;
    private namespaceStatement;
    /**
     * Get an expression with identifiers separated by periods. Useful for namespaces and class extends
     */
    private getNamespacedVariableNameExpression;
    /**
     * Add an 'unexpected token' diagnostic for any token found between current and the first stopToken found.
     */
    private flagUntil;
    /**
     * Consume tokens until one of the `stopTokenKinds` is encountered
     * @param tokenKinds
     * @return - the list of tokens consumed, EXCLUDING the `stopTokenKind` (you can use `this.peek()` to see which one it was)
     */
    private consumeUntil;
    private libraryStatement;
    private importStatement;
    private annotationExpression;
    private templateString;
    private tryCatchStatement;
    private throwStatement;
    private ifStatement;
    private expressionStatement;
    private setStatement;
    private printStatement;
    /**
     * Parses a return statement with an optional return value.
     * @returns an AST representation of a return statement.
     */
    private returnStatement;
    /**
     * Parses a `label` statement
     * @returns an AST representation of an `label` statement.
     */
    private labelStatement;
    /**
     * Parses a `goto` statement
     * @returns an AST representation of an `goto` statement.
     */
    private gotoStatement;
    /**
     * Parses an `end` statement
     * @returns an AST representation of an `end` statement.
     */
    private endStatement;
    /**
     * Parses a `stop` statement
     * @returns an AST representation of a `stop` statement
     */
    private stopStatement;
    /**
     * Parses a block, looking for a specific terminating TokenKind to denote completion.
     * @param terminators the token(s) that signifies the end of this block; all other terminators are
     *                    ignored.
     */
    private block;
    private expression;
    private anonymousFunction;
    private boolean;
    private relational;
    private additive;
    private multiplicative;
    private exponential;
    private prefixUnary;
    private indexedGet;
    private newExpression;
    /**
     * A callfunc expression (i.e. `node@.someFunctionOnNode()`)
     */
    private callfunc;
    private call;
    private finishCall;
    private primary;
    /**
     * Pop tokens until we encounter a token other than the specified one
     */
    private match;
    /**
     * Pop tokens until we encounter a token not in the specified list
     * @param tokenKinds
     */
    private matchAny;
    private consume;
    /**
     * Consume, or add a message if not found. But then continue and return undefined
     * @param message
     * @param tokenKinds
     */
    private tryConsume;
    private advance;
    private checkPrevious;
    private check;
    private checkAny;
    private checkNext;
    private checkAnyNext;
    private isAtEnd;
    private peekNext;
    private peek;
    private previous;
    private synchronize;
    /**
     * References are found during the initial parse.
     * However, sometimes plugins can modify the AST, requiring a full walk to re-compute all references.
     * This does that walk.
     */
    private findReferences;
    dispose(): void;
}
export declare enum ParseMode {
    BrightScript = "BrightScript",
    BrighterScript = "BrighterScript"
}
export interface ParseOptions {
    /**
     * The parse mode. When in 'BrightScript' mode, no BrighterScript syntax is allowed, and will emit diagnostics.
     */
    mode: ParseMode;
    /**
     * A logger that should be used for logging. If omitted, a default logger is used
     */
    logger?: Logger;
}
export interface References {
    assignmentStatements: AssignmentStatement[];
    classStatements: ClassStatement[];
    functionExpressions: FunctionExpression[];
    functionStatements: FunctionStatement[];
    importStatements: ImportStatement[];
    libraryStatements: LibraryStatement[];
    namespaceStatements: NamespaceStatement[];
    newExpressions: NewExpression[];
    propertyHints: Record<string, string>;
}
