import type { Token, Identifier } from '../lexer';
import { TokenKind } from '../lexer';
import { SourceNode } from 'source-map';
import type { Expression, NamespacedVariableNameExpression, FunctionExpression, AnnotationExpression } from './Expression';
import type { Range } from 'vscode-languageserver';
import type { TranspileState } from './TranspileState';
import { ParseMode } from './Parser';
import type { WalkVisitor, WalkOptions } from '../astUtils/visitors';
import { InternalWalkMode } from '../astUtils/visitors';
import type { TranspileResult, TypedefProvider } from '../interfaces';
/**
 * A BrightScript statement
 */
export declare abstract class Statement {
    /**
     *  The starting and ending location of the statement.
     **/
    abstract range: Range;
    /**
     * Statement annotations
     */
    annotations: AnnotationExpression[];
    abstract transpile(state: TranspileState): TranspileResult;
    /**
     * When being considered by the walk visitor, this describes what type of element the current class is.
     */
    visitMode: InternalWalkMode;
    abstract walk(visitor: WalkVisitor, options: WalkOptions): any;
}
export declare class EmptyStatement extends Statement {
    /**
     * Create a negative range to indicate this is an interpolated location
     */
    range: Range;
    constructor(
    /**
     * Create a negative range to indicate this is an interpolated location
     */
    range?: Range);
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
/**
 * This is a top-level statement. Consider this the root of the AST
 */
export declare class Body extends Statement implements TypedefProvider {
    statements: Statement[];
    constructor(statements?: Statement[]);
    get range(): Range;
    transpile(state: TranspileState): TranspileResult;
    getTypedef(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class AssignmentStatement extends Statement {
    readonly equals: Token;
    readonly name: Identifier;
    readonly value: Expression;
    readonly containingFunction: FunctionExpression;
    constructor(equals: Token, name: Identifier, value: Expression, containingFunction: FunctionExpression);
    readonly range: Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class Block extends Statement {
    readonly statements: Statement[];
    readonly startingRange: Range;
    constructor(statements: Statement[], startingRange: Range);
    readonly range: Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ExpressionStatement extends Statement {
    readonly expression: Expression;
    constructor(expression: Expression);
    readonly range: Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class CommentStatement extends Statement implements Expression, TypedefProvider {
    comments: Token[];
    constructor(comments: Token[]);
    range: Range;
    get text(): string;
    transpile(state: TranspileState): Array<SourceNode | string>;
    getTypedef(state: TranspileState): (string | SourceNode)[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ExitForStatement extends Statement {
    readonly tokens: {
        exitFor: Token;
    };
    constructor(tokens: {
        exitFor: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ExitWhileStatement extends Statement {
    readonly tokens: {
        exitWhile: Token;
    };
    constructor(tokens: {
        exitWhile: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class FunctionStatement extends Statement implements TypedefProvider {
    name: Identifier;
    func: FunctionExpression;
    namespaceName: NamespacedVariableNameExpression;
    constructor(name: Identifier, func: FunctionExpression, namespaceName: NamespacedVariableNameExpression);
    readonly range: Range;
    /**
     * Get the name of this expression based on the parse mode
     */
    getName(parseMode: ParseMode): string;
    transpile(state: TranspileState): any[];
    getTypedef(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export interface ElseIf {
    elseIfToken: Token;
    thenToken?: Token;
    condition: Expression;
    thenBranch: Block;
}
export declare class IfStatement extends Statement {
    readonly tokens: {
        if: Token;
        then?: Token;
        else?: Token;
        endIf?: Token;
    };
    readonly condition: Expression;
    readonly thenBranch: Block;
    readonly elseIfs: ElseIf[];
    readonly elseBranch?: Block;
    constructor(tokens: {
        if: Token;
        then?: Token;
        else?: Token;
        endIf?: Token;
    }, condition: Expression, thenBranch: Block, elseIfs: ElseIf[], elseBranch?: Block);
    readonly range: Range;
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class IncrementStatement extends Statement {
    readonly value: Expression;
    readonly operator: Token;
    constructor(value: Expression, operator: Token);
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
/** Used to indent the current `print` position to the next 16-character-width output zone. */
export interface PrintSeparatorTab extends Token {
    kind: TokenKind.Comma;
}
/** Used to insert a single whitespace character at the current `print` position. */
export interface PrintSeparatorSpace extends Token {
    kind: TokenKind.Semicolon;
}
/**
 * Represents a `print` statement within BrightScript.
 */
export declare class PrintStatement extends Statement {
    readonly tokens: {
        print: Token;
    };
    readonly expressions: Array<Expression | PrintSeparatorTab | PrintSeparatorSpace>;
    /**
     * Creates a new internal representation of a BrightScript `print` statement.
     * @param expressions an array of expressions or `PrintSeparator`s to be
     *                    evaluated and printed.
     */
    constructor(tokens: {
        print: Token;
    }, expressions: Array<Expression | PrintSeparatorTab | PrintSeparatorSpace>);
    readonly range: Range;
    transpile(state: TranspileState): (string | SourceNode)[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class GotoStatement extends Statement {
    readonly tokens: {
        goto: Token;
        label: Token;
    };
    constructor(tokens: {
        goto: Token;
        label: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class LabelStatement extends Statement {
    readonly tokens: {
        identifier: Token;
        colon: Token;
    };
    constructor(tokens: {
        identifier: Token;
        colon: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ReturnStatement extends Statement {
    readonly tokens: {
        return: Token;
    };
    readonly value?: Expression;
    constructor(tokens: {
        return: Token;
    }, value?: Expression);
    readonly range: Range;
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class EndStatement extends Statement {
    readonly tokens: {
        end: Token;
    };
    constructor(tokens: {
        end: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): SourceNode[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class StopStatement extends Statement {
    readonly tokens: {
        stop: Token;
    };
    constructor(tokens: {
        stop: Token;
    });
    readonly range: Range;
    transpile(state: TranspileState): SourceNode[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ForStatement extends Statement {
    forToken: Token;
    counterDeclaration: AssignmentStatement;
    toToken: Token;
    finalValue: Expression;
    body: Block;
    endForToken: Token;
    stepToken?: Token;
    increment?: Expression;
    constructor(forToken: Token, counterDeclaration: AssignmentStatement, toToken: Token, finalValue: Expression, body: Block, endForToken: Token, stepToken?: Token, increment?: Expression);
    readonly range: Range;
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ForEachStatement extends Statement {
    readonly tokens: {
        forEach: Token;
        in: Token;
        endFor: Token;
    };
    readonly item: Token;
    readonly target: Expression;
    readonly body: Block;
    constructor(tokens: {
        forEach: Token;
        in: Token;
        endFor: Token;
    }, item: Token, target: Expression, body: Block);
    readonly range: Range;
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class WhileStatement extends Statement {
    readonly tokens: {
        while: Token;
        endWhile: Token;
    };
    readonly condition: Expression;
    readonly body: Block;
    constructor(tokens: {
        while: Token;
        endWhile: Token;
    }, condition: Expression, body: Block);
    readonly range: Range;
    transpile(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class DottedSetStatement extends Statement {
    readonly obj: Expression;
    readonly name: Identifier;
    readonly value: Expression;
    constructor(obj: Expression, name: Identifier, value: Expression);
    readonly range: Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class IndexedSetStatement extends Statement {
    readonly obj: Expression;
    readonly index: Expression;
    readonly value: Expression;
    readonly openingSquare: Token;
    readonly closingSquare: Token;
    constructor(obj: Expression, index: Expression, value: Expression, openingSquare: Token, closingSquare: Token);
    readonly range: Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class LibraryStatement extends Statement implements TypedefProvider {
    readonly tokens: {
        library: Token;
        filePath: Token | undefined;
    };
    constructor(tokens: {
        library: Token;
        filePath: Token | undefined;
    });
    readonly range: Range;
    transpile(state: TranspileState): any[];
    getTypedef(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class NamespaceStatement extends Statement implements TypedefProvider {
    keyword: Token;
    nameExpression: NamespacedVariableNameExpression;
    body: Body;
    endKeyword: Token;
    constructor(keyword: Token, nameExpression: NamespacedVariableNameExpression, body: Body, endKeyword: Token);
    /**
     * The string name for this namespace
     */
    name: string;
    get range(): Range;
    getName(parseMode: ParseMode): string;
    transpile(state: TranspileState): TranspileResult;
    getTypedef(state: TranspileState): string[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ImportStatement extends Statement implements TypedefProvider {
    readonly importToken: Token;
    readonly filePathToken: Token;
    constructor(importToken: Token, filePathToken: Token);
    filePath: string;
    range: Range;
    transpile(state: TranspileState): SourceNode[];
    /**
     * Get the typedef for this statement
     */
    getTypedef(state: TranspileState): string[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ClassStatement extends Statement implements TypedefProvider {
    readonly classKeyword: Token;
    /**
     * The name of the class (without namespace prefix)
     */
    readonly name: Identifier;
    body: Statement[];
    readonly end: Token;
    readonly extendsKeyword?: Token;
    readonly parentClassName?: NamespacedVariableNameExpression;
    readonly namespaceName?: NamespacedVariableNameExpression;
    constructor(classKeyword: Token, 
    /**
     * The name of the class (without namespace prefix)
     */
    name: Identifier, body: Statement[], end: Token, extendsKeyword?: Token, parentClassName?: NamespacedVariableNameExpression, namespaceName?: NamespacedVariableNameExpression);
    getName(parseMode: ParseMode): string;
    memberMap: Record<string, ClassMemberStatement>;
    methods: ClassMethodStatement[];
    fields: ClassFieldStatement[];
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    getTypedef(state: TranspileState): (string | SourceNode)[];
    /**
     * Find the parent index for this class's parent.
     * For class inheritance, every class is given an index.
     * The base class is index 0, its child is index 1, and so on.
     */
    getParentClassIndex(state: TranspileState): number;
    hasParentClass(): boolean;
    /**
     * Get all ancestor classes, in closest-to-furthest order (i.e. 0 is parent, 1 is grandparent, etc...).
     * This will return an empty array if no ancestors were found
     */
    getAncestors(state: TranspileState): any[];
    private getBuilderName;
    /**
     * Get the constructor function for this class (if exists), or undefined if not exist
     */
    private getConstructorFunction;
    private getEmptyNewFunction;
    /**
     * Determine if the specified field was declared in one of the ancestor classes
     */
    isFieldDeclaredByAncestor(fieldName: string, ancestors: ClassStatement[]): boolean;
    /**
     * The builder is a function that assigns all of the methods and property names to a class instance.
     * This needs to be a separate function so that child classes can call the builder from their parent
     * without instantiating the parent constructor at that point in time.
     */
    private getTranspiledBuilder;
    /**
     * The class function is the function with the same name as the class. This is the function that
     * consumers should call to create a new instance of that class.
     * This invokes the builder, gets an instance of the class, then invokes the "new" function on that class.
     */
    private getTranspiledClassFunction;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ClassMethodStatement extends FunctionStatement {
    readonly accessModifier: Token;
    readonly override: Token;
    constructor(accessModifier: Token, name: Identifier, func: FunctionExpression, override: Token);
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    getTypedef(state: TranspileState): string[];
    /**
     * All child classes must call the parent constructor. The type checker will warn users when they don't call it in their own class,
     * but we still need to call it even if they have omitted it. This injects the super call if it's missing
     */
    private ensureSuperConstructorCall;
    /**
     * Inject field initializers at the top of the `new` function (after any present `super()` call)
     */
    private injectFieldInitializersForConstructor;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ClassFieldStatement extends Statement implements TypedefProvider {
    readonly accessModifier?: Token;
    readonly name?: Identifier;
    readonly as?: Token;
    readonly type?: Token;
    readonly equal?: Token;
    readonly initialValue?: Expression;
    constructor(accessModifier?: Token, name?: Identifier, as?: Token, type?: Token, equal?: Token, initialValue?: Expression);
    /**
     * Derive a ValueKind from the type token, or the intial value.
     * Defaults to `ValueKind.Dynamic`
     */
    private getType;
    readonly range: Range;
    transpile(state: TranspileState): Array<SourceNode | string>;
    getTypedef(state: TranspileState): any[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare type ClassMemberStatement = ClassFieldStatement | ClassMethodStatement;
export declare class TryCatchStatement extends Statement {
    tryToken: Token;
    tryBranch?: Block;
    catchToken?: Token;
    exceptionVariable?: Identifier;
    catchBranch?: Block;
    endTryToken?: Token;
    constructor(tryToken: Token, tryBranch?: Block, catchToken?: Token, exceptionVariable?: Identifier, catchBranch?: Block, endTryToken?: Token);
    get range(): Range;
    transpile(state: TranspileState): TranspileResult;
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
export declare class ThrowStatement extends Statement {
    throwToken: Token;
    expression?: Expression;
    constructor(throwToken: Token, expression?: Expression);
    range: Range;
    transpile(state: TranspileState): (string | SourceNode)[];
    walk(visitor: WalkVisitor, options: WalkOptions): void;
}
