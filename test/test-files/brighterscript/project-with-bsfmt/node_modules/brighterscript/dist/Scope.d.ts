import type { CompletionItem, Position, Range } from 'vscode-languageserver';
import { Location } from 'vscode-languageserver';
import type { CallableContainer, BsDiagnostic, BscFile } from './interfaces';
import type { Program } from './Program';
import type { NamespaceStatement, Statement, NewExpression, FunctionStatement, ClassStatement } from './parser';
import { ParseMode } from './parser';
import { Cache } from './Cache';
/**
 * A class to keep track of all declarations within a given scope (like source scope, component scope)
 */
export declare class Scope {
    name: string;
    dependencyGraphKey: string;
    program: Program;
    constructor(name: string, dependencyGraphKey: string, program: Program);
    /**
     * Indicates whether this scope needs to be validated.
     * Will be true when first constructed, or anytime one of its dependencies changes
     */
    readonly isValidated: boolean;
    protected programHandles: (() => void)[];
    protected cache: Cache;
    /**
     * A dictionary of namespaces, indexed by the lower case full name of each namespace.
     * If a namespace is declared as "NameA.NameB.NameC", there will be 3 entries in this dictionary,
     * "namea", "namea.nameb", "namea.nameb.namec"
     */
    get namespaceLookup(): Record<string, NamespaceContainer>;
    /**
     * Get the class with the specified name.
     * @param className - the all-lower-case namespace-included class name
     */
    getClass(className: string): ClassStatement;
    /**
     * A dictionary of all classes in this scope. This includes namespaced classes always with their full name.
     * The key is stored in lower case
     */
    private getClassMap;
    /**
     * The list of diagnostics found specifically for this scope. Individual file diagnostics are stored on the files themselves.
     */
    protected diagnostics: BsDiagnostic[];
    protected onDependenciesChanged(key: string): void;
    /**
     * Clean up all event handles
     */
    dispose(): void;
    /**
     * Does this scope know about the given namespace name?
     * @param namespaceName - the name of the namespace (i.e. "NameA", or "NameA.NameB", etc...)
     */
    isKnownNamespace(namespaceName: string): boolean;
    /**
     * Get the parent scope for this scope (for source scope this will always be the globalScope).
     * XmlScope overrides this to return the parent xml scope if available.
     * For globalScope this will return null.
     */
    getParentScope(): Scope;
    /**
     * Get the file with the specified pkgPath
     */
    getFile(pathAbsolute: string): BscFile;
    getFiles(): BscFile[];
    get fileCount(): number;
    /**
     * Get the list of errors for this scope. It's calculated on the fly, so
     * call this sparingly.
     */
    getDiagnostics(): BsDiagnostic[];
    addDiagnostics(diagnostics: BsDiagnostic[]): void;
    /**
     * Get the list of callables available in this scope (either declared in this scope or in a parent scope)
     */
    getAllCallables(): CallableContainer[];
    /**
     * Get the callable with the specified name.
     * If there are overridden callables with the same name, the closest callable to this scope is returned
     * @param name
     */
    getCallableByName(name: string): import("./interfaces").Callable;
    enumerateFiles(callback: (file: BscFile) => void): void;
    /**
     * Get the list of callables explicitly defined in files in this scope.
     * This excludes ancestor callables
     */
    getOwnCallables(): CallableContainer[];
    /**
     * Builds a tree of namespace objects
     */
    buildNamespaceLookup(): Record<string, NamespaceContainer>;
    getNamespaceStatements(): NamespaceStatement[];
    protected logDebug(...args: any[]): void;
    private _debugLogComponentName;
    validate(force?: boolean): void;
    /**
     * Mark this scope as invalid, which means its `validate()` function needs to be called again before use.
     */
    invalidate(): void;
    private detectVariableNamespaceCollisions;
    /**
     * Find various function collisions
     */
    private diagnosticDetectFunctionCollisions;
    getNewExpressions(): AugmentedNewExpression[];
    private validateClasses;
    /**
     * Detect calls to functions with the incorrect number of parameters
     * @param file
     * @param callableContainersByLowerName
     */
    private diagnosticDetectFunctionCallsWithWrongParamCount;
    /**
     * Detect local variables (function scope) that have the same name as scope calls
     * @param file
     * @param callableContainerMap
     */
    private diagnosticDetectShadowedLocalVars;
    /**
     * Detect calls to functions that are not defined in this scope
     * @param file
     * @param callablesByLowerName
     */
    private diagnosticDetectCallsToUnknownFunctions;
    /**
     * Create diagnostics for any duplicate function declarations
     * @param callablesByLowerName
     */
    private diagnosticFindDuplicateFunctionDeclarations;
    /**
     * Get the list of all script imports for this scope
     */
    private getScriptImports;
    /**
     * Verify that all of the scripts imported by each file in this scope actually exist
     */
    private diagnosticValidateScriptImportPaths;
    /**
     * Find the file with the specified relative path
     * @param relativePath
     */
    protected getFileByRelativePath(relativePath: string): BscFile;
    /**
     * Determine if this scope is referenced and known by the file.
     * @param file
     */
    hasFile(file: BscFile): boolean;
    /**
     * Get all callables as completionItems
     */
    getCallablesAsCompletions(parseMode: ParseMode): CompletionItem[];
    /**
     * Get the definition (where was this thing first defined) of the symbol under the position
     */
    getDefinition(file: BscFile, position: Position): Location[];
    /**
     * Scan all files for property names, and return them as completions
     */
    getPropertyNameCompletions(): CompletionItem[];
}
interface NamespaceContainer {
    file: BscFile;
    fullName: string;
    nameRange: Range;
    lastPartName: string;
    statements: Statement[];
    classStatements: Record<string, ClassStatement>;
    functionStatements: Record<string, FunctionStatement>;
    namespaces: Record<string, NamespaceContainer>;
}
interface AugmentedNewExpression extends NewExpression {
    file: BscFile;
}
export {};
