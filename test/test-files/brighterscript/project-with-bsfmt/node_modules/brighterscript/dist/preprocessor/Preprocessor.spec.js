"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Parser_spec_1 = require("../parser/tests/Parser.spec");
const TokenKind_1 = require("../lexer/TokenKind");
const Preprocessor_1 = require("./Preprocessor");
const Chunk_1 = require("./Chunk");
const chai_1 = require("chai");
const sinon_1 = require("sinon");
let sinon = sinon_1.createSandbox();
describe('preprocessor', () => {
    afterEach(() => {
        sinon.restore();
    });
    it('forwards brightscript chunk contents unmodified', () => {
        let unprocessed = [
            Parser_spec_1.identifier('foo'),
            Parser_spec_1.token(TokenKind_1.TokenKind.LeftParen, '('),
            Parser_spec_1.token(TokenKind_1.TokenKind.RightParen, ')'),
            Parser_spec_1.token(TokenKind_1.TokenKind.Newline, '\n'),
            Parser_spec_1.EOF
        ];
        let { processedTokens } = new Preprocessor_1.Preprocessor().filter([new Chunk_1.BrightScriptChunk(unprocessed)]);
        chai_1.expect(processedTokens).to.eql(unprocessed);
    });
    describe('#const', () => {
        it('removes #const declarations from output', () => {
            let { processedTokens } = new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('lorem'), Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'))
            ]);
            chai_1.expect(processedTokens).to.eql([]);
        });
        describe('values', () => {
            it('allows `true`', () => {
                chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('lorem'), Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'))
                ])).not.to.throw;
            });
            it('allows `false`', () => {
                chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('ipsum'), Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'))
                ])).not.to.throw;
            });
            it('allows identifiers', () => {
                chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                    // 'ipsum' must be defined before it's referenced
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('ipsum'), Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false')),
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('dolor'), Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'))
                ])).not.to.throw;
            });
            it('disallows strings', () => {
                chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('sit'), Parser_spec_1.token(TokenKind_1.TokenKind.String, 'good boy!'))
                ])).to.throw; //('#const declarations can only have');
            });
            it('disallows re-declaration of values', () => {
                chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('lorem'), Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false')),
                    new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('lorem'), Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'))
                ])).to.throw;
            });
        });
    });
    describe('#error', () => {
        it('throws error when #error directives encountered', () => {
            chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.ErrorChunk(Parser_spec_1.token(TokenKind_1.TokenKind.HashError, '#error'), Parser_spec_1.token(TokenKind_1.TokenKind.HashError, 'I\'m an error message!'))
            ])).to.throw;
        });
        it('doesn\'t throw when branched around', () => {
            chai_1.expect(() => new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.HashIfStatement(Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'), [
                    new Chunk_1.ErrorChunk(Parser_spec_1.token(TokenKind_1.TokenKind.HashError, '#error'), Parser_spec_1.token(TokenKind_1.TokenKind.HashError, 'I\'m an error message!'))
                ], [] // no else-ifs necessary
                )
            ])).not.to.throw;
        });
    });
    describe('#if', () => {
        let elseChunk;
        let elseIfChunk;
        let ifChunk;
        beforeEach(() => {
            ifChunk = new Chunk_1.BrightScriptChunk([]);
            elseIfChunk = new Chunk_1.BrightScriptChunk([]);
            elseChunk = new Chunk_1.BrightScriptChunk([]);
            sinon.spy(ifChunk, 'accept');
            sinon.spy(elseIfChunk, 'accept');
            sinon.spy(elseChunk, 'accept');
        });
        it('enters #if branch', () => {
            new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.HashIfStatement(Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'), [ifChunk], [
                    {
                        condition: Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'),
                        thenChunks: [elseIfChunk]
                    }
                ], [elseChunk])
            ]);
            chai_1.expect(ifChunk.accept.callCount).to.equal(1);
            chai_1.expect(elseIfChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseChunk.accept.callCount).to.equal(0);
        });
        it('enters #else if branch', () => {
            new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.HashIfStatement(Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'), [ifChunk], [
                    {
                        condition: Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true'),
                        thenChunks: [elseIfChunk]
                    }
                ], [elseChunk])
            ]);
            chai_1.expect(ifChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseIfChunk.accept.callCount).to.equal(1);
            chai_1.expect(elseChunk.accept.callCount).to.equal(0);
        });
        it('enters #else branch', () => {
            new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.HashIfStatement(Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'), [ifChunk], [
                    {
                        condition: Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'),
                        thenChunks: [elseIfChunk]
                    }
                ], [elseChunk])
            ]);
            chai_1.expect(ifChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseIfChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseChunk.accept.callCount).to.equal(1);
        });
        it('enters no branches if none pass', () => {
            new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.HashIfStatement(Parser_spec_1.token(TokenKind_1.TokenKind.False, 'false'), [ifChunk], [] // no else-if chunks
                // NOTE: no 'else" chunk!
                )
            ]);
            chai_1.expect(ifChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseIfChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseChunk.accept.callCount).to.equal(0);
        });
        it('uses #const values to determine truth', () => {
            new Preprocessor_1.Preprocessor().filter([
                new Chunk_1.DeclarationChunk(Parser_spec_1.identifier('lorem'), Parser_spec_1.token(TokenKind_1.TokenKind.True, 'true')),
                new Chunk_1.HashIfStatement(Parser_spec_1.identifier('lorem'), [ifChunk], [] // no else-if chunks
                // NOTE: no 'else" chunk!
                )
            ]);
            chai_1.expect(ifChunk.accept.callCount).to.equal(1);
            chai_1.expect(elseIfChunk.accept.callCount).to.equal(0);
            chai_1.expect(elseChunk.accept.callCount).to.equal(0);
        });
    });
});
//# sourceMappingURL=Preprocessor.spec.js.map