"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-multi-spaces */
const chai_1 = require("chai");
const Statement_1 = require("../parser/Statement");
const Expression_1 = require("../parser/Expression");
const lexer_1 = require("../lexer");
const reflection_1 = require("./reflection");
const creators_1 = require("./creators");
const Program_1 = require("../Program");
const BrsFile_1 = require("../files/BrsFile");
const XmlFile_1 = require("../files/XmlFile");
describe('reflection', () => {
    describe('Files', () => {
        it('recognizes files', () => {
            const program = new Program_1.Program({});
            const file = new BrsFile_1.BrsFile('path/to/source/file.brs', 'pkg:/source/file.brs', program);
            const comp = new XmlFile_1.XmlFile('path/to/components/file.xml', 'pkg:/components/file.brs', program);
            chai_1.expect(reflection_1.isBrsFile(file)).to.be.true;
            chai_1.expect(reflection_1.isXmlFile(file)).to.be.false;
            chai_1.expect(reflection_1.isBrsFile(comp)).to.be.false;
            chai_1.expect(reflection_1.isXmlFile(comp)).to.be.true;
        });
    });
    describe('Statements', () => {
        const ident = creators_1.createToken(lexer_1.TokenKind.Identifier, 'a', creators_1.interpolatedRange);
        const expr = creators_1.createStringLiteral('', creators_1.interpolatedRange);
        const token = creators_1.createToken(lexer_1.TokenKind.StringLiteral, '', creators_1.interpolatedRange);
        const body = new Statement_1.Body([]);
        const assignment = new Statement_1.AssignmentStatement(undefined, ident, expr, undefined);
        const block = new Statement_1.Block([], creators_1.interpolatedRange);
        const expression = new Statement_1.ExpressionStatement(expr);
        const comment = new Statement_1.CommentStatement([token]);
        const exitFor = new Statement_1.ExitForStatement({ exitFor: token });
        const exitWhile = new Statement_1.ExitWhileStatement({ exitWhile: token });
        const funs = new Statement_1.FunctionStatement(ident, new Expression_1.FunctionExpression([], block, token, token, token, token), undefined);
        const ifs = new Statement_1.IfStatement({ if: token }, expr, block, []);
        const increment = new Statement_1.IncrementStatement(expr, token);
        const print = new Statement_1.PrintStatement({ print: token }, []);
        const gotos = new Statement_1.GotoStatement({ goto: token, label: token });
        const labels = new Statement_1.LabelStatement({ identifier: ident, colon: token });
        const returns = new Statement_1.ReturnStatement({ return: token });
        const ends = new Statement_1.EndStatement({ end: token });
        const stop = new Statement_1.StopStatement({ stop: token });
        const fors = new Statement_1.ForStatement(token, assignment, token, expr, block, token, token, expr);
        const foreach = new Statement_1.ForEachStatement({ forEach: token, in: token, endFor: token }, token, expr, block);
        const whiles = new Statement_1.WhileStatement({ while: token, endWhile: token }, expr, block);
        const dottedSet = new Statement_1.DottedSetStatement(expr, ident, expr);
        const indexedSet = new Statement_1.IndexedSetStatement(expr, expr, expr, token, token);
        const library = new Statement_1.LibraryStatement({ library: token, filePath: token });
        const namespace = new Statement_1.NamespaceStatement(token, new Expression_1.NamespacedVariableNameExpression(creators_1.createIdentifier('a', creators_1.interpolatedRange)), body, token);
        const cls = new Statement_1.ClassStatement(token, ident, [], token);
        const imports = new Statement_1.ImportStatement(token, token);
        it('isStatement', () => {
            chai_1.expect(reflection_1.isStatement(library)).to.be.true;
            chai_1.expect(reflection_1.isStatement(creators_1.createStringLiteral('test'))).to.be.false;
            //doesn't fail for undefined
            chai_1.expect(reflection_1.isStatement(undefined)).to.be.false;
        });
        it('isBody', () => {
            chai_1.expect(reflection_1.isBody(body)).to.be.true;
            chai_1.expect(reflection_1.isBody(assignment)).to.be.false;
        });
        it('isAssignmentStatement', () => {
            chai_1.expect(reflection_1.isAssignmentStatement(assignment)).to.be.true;
            chai_1.expect(reflection_1.isAssignmentStatement(body)).to.be.false;
        });
        it('isBlock', () => {
            chai_1.expect(reflection_1.isBlock(block)).to.be.true;
            chai_1.expect(reflection_1.isBlock(body)).to.be.false;
        });
        it('isExpressionStatement', () => {
            chai_1.expect(reflection_1.isExpressionStatement(expression)).to.be.true;
            chai_1.expect(reflection_1.isExpressionStatement(body)).to.be.false;
        });
        it('isCommentStatement', () => {
            chai_1.expect(reflection_1.isCommentStatement(comment)).to.be.true;
            chai_1.expect(reflection_1.isCommentStatement(body)).to.be.false;
        });
        it('isExitForStatement', () => {
            chai_1.expect(reflection_1.isExitForStatement(exitFor)).to.be.true;
            chai_1.expect(reflection_1.isExitForStatement(body)).to.be.false;
        });
        it('isExitWhileStatement', () => {
            chai_1.expect(reflection_1.isExitWhileStatement(exitWhile)).to.be.true;
            chai_1.expect(reflection_1.isExitWhileStatement(body)).to.be.false;
        });
        it('isFunctionStatement', () => {
            chai_1.expect(reflection_1.isFunctionStatement(funs)).to.be.true;
            chai_1.expect(reflection_1.isFunctionStatement(body)).to.be.false;
        });
        it('isIfStatement', () => {
            chai_1.expect(reflection_1.isIfStatement(ifs)).to.be.true;
            chai_1.expect(reflection_1.isIfStatement(body)).to.be.false;
        });
        it('isIncrementStatement', () => {
            chai_1.expect(reflection_1.isIncrementStatement(increment)).to.be.true;
            chai_1.expect(reflection_1.isIncrementStatement(body)).to.be.false;
        });
        it('isPrintStatement', () => {
            chai_1.expect(reflection_1.isPrintStatement(print)).to.be.true;
            chai_1.expect(reflection_1.isPrintStatement(body)).to.be.false;
        });
        it('isGotoStatement', () => {
            chai_1.expect(reflection_1.isGotoStatement(gotos)).to.be.true;
            chai_1.expect(reflection_1.isGotoStatement(body)).to.be.false;
        });
        it('isLabelStatement', () => {
            chai_1.expect(reflection_1.isLabelStatement(labels)).to.be.true;
            chai_1.expect(reflection_1.isLabelStatement(body)).to.be.false;
        });
        it('isReturnStatement', () => {
            chai_1.expect(reflection_1.isReturnStatement(returns)).to.be.true;
            chai_1.expect(reflection_1.isReturnStatement(body)).to.be.false;
        });
        it('isEndStatement', () => {
            chai_1.expect(reflection_1.isEndStatement(ends)).to.be.true;
            chai_1.expect(reflection_1.isEndStatement(body)).to.be.false;
        });
        it('isStopStatement', () => {
            chai_1.expect(reflection_1.isStopStatement(stop)).to.be.true;
            chai_1.expect(reflection_1.isStopStatement(body)).to.be.false;
        });
        it('isForStatement', () => {
            chai_1.expect(reflection_1.isForStatement(fors)).to.be.true;
            chai_1.expect(reflection_1.isForStatement(body)).to.be.false;
        });
        it('isForEachStatement', () => {
            chai_1.expect(reflection_1.isForEachStatement(foreach)).to.be.true;
            chai_1.expect(reflection_1.isForEachStatement(body)).to.be.false;
        });
        it('isWhileStatement', () => {
            chai_1.expect(reflection_1.isWhileStatement(whiles)).to.be.true;
            chai_1.expect(reflection_1.isWhileStatement(body)).to.be.false;
        });
        it('isDottedSetStatement', () => {
            chai_1.expect(reflection_1.isDottedSetStatement(dottedSet)).to.be.true;
            chai_1.expect(reflection_1.isDottedSetStatement(body)).to.be.false;
        });
        it('isIndexedSetStatement', () => {
            chai_1.expect(reflection_1.isIndexedSetStatement(indexedSet)).to.be.true;
            chai_1.expect(reflection_1.isIndexedSetStatement(body)).to.be.false;
        });
        it('isLibraryStatement', () => {
            chai_1.expect(reflection_1.isLibraryStatement(library)).to.be.true;
            chai_1.expect(reflection_1.isLibraryStatement(body)).to.be.false;
        });
        it('isNamespaceStatement', () => {
            chai_1.expect(reflection_1.isNamespaceStatement(namespace)).to.be.true;
            chai_1.expect(reflection_1.isNamespaceStatement(body)).to.be.false;
        });
        it('isClassStatement', () => {
            chai_1.expect(reflection_1.isClassStatement(cls)).to.be.true;
            chai_1.expect(reflection_1.isClassStatement(body)).to.be.false;
        });
        it('isImportStatement', () => {
            chai_1.expect(reflection_1.isImportStatement(imports)).to.be.true;
            chai_1.expect(reflection_1.isImportStatement(body)).to.be.false;
        });
    });
    describe('Expressions', () => {
        const ident = creators_1.createToken(lexer_1.TokenKind.Identifier, 'a', creators_1.interpolatedRange);
        const expr = creators_1.createStringLiteral('', creators_1.interpolatedRange);
        const token = creators_1.createToken(lexer_1.TokenKind.StringLiteral, '', creators_1.interpolatedRange);
        const block = new Statement_1.Block([], creators_1.interpolatedRange);
        const charCode = {
            kind: lexer_1.TokenKind.EscapedCharCodeLiteral,
            text: '0',
            range: creators_1.interpolatedRange,
            isReserved: false,
            charCode: 0,
            leadingWhitespace: ''
        };
        const nsVar = new Expression_1.NamespacedVariableNameExpression(creators_1.createIdentifier('a', creators_1.interpolatedRange));
        const binary = new Expression_1.BinaryExpression(expr, token, expr);
        const call = new Expression_1.CallExpression(expr, token, token, [], undefined);
        const fun = new Expression_1.FunctionExpression([], block, token, token, token, token);
        const dottedGet = new Expression_1.DottedGetExpression(expr, ident, token);
        const xmlAttrGet = new Expression_1.XmlAttributeGetExpression(expr, ident, token);
        const indexedGet = new Expression_1.IndexedGetExpression(expr, expr, token, token);
        const grouping = new Expression_1.GroupingExpression({ left: token, right: token }, expr);
        const literal = creators_1.createStringLiteral('test');
        const escapedCarCode = new Expression_1.EscapedCharCodeLiteralExpression(charCode);
        const arrayLit = new Expression_1.ArrayLiteralExpression([], token, token);
        const aaLit = new Expression_1.AALiteralExpression([], token, token);
        const unary = new Expression_1.UnaryExpression(token, expr);
        const variable = new Expression_1.VariableExpression(ident, undefined);
        const sourceLit = new Expression_1.SourceLiteralExpression(token);
        const newx = new Expression_1.NewExpression(token, call);
        const callfunc = new Expression_1.CallfuncExpression(expr, token, ident, token, [], token);
        const tplQuasi = new Expression_1.TemplateStringQuasiExpression([expr]);
        const tplString = new Expression_1.TemplateStringExpression(token, [tplQuasi], [], token);
        const taggedTpl = new Expression_1.TaggedTemplateStringExpression(ident, token, [tplQuasi], [], token);
        const annotation = new Expression_1.AnnotationExpression(token, token);
        it('isExpression', () => {
            chai_1.expect(reflection_1.isExpression(binary)).to.be.true;
            chai_1.expect(reflection_1.isExpression(binary.operator)).to.be.false;
        });
        it('isBinaryExpression', () => {
            chai_1.expect(reflection_1.isBinaryExpression(binary)).to.be.true;
            chai_1.expect(reflection_1.isBinaryExpression(fun)).to.be.false;
        });
        it('isCallExpression', () => {
            chai_1.expect(reflection_1.isCallExpression(call)).to.be.true;
            chai_1.expect(reflection_1.isCallExpression(fun)).to.be.false;
        });
        it('isFunctionExpression', () => {
            chai_1.expect(reflection_1.isFunctionExpression(fun)).to.be.true;
            chai_1.expect(reflection_1.isFunctionExpression(call)).to.be.false;
        });
        it('isNamespacedVariableNameExpression', () => {
            chai_1.expect(reflection_1.isNamespacedVariableNameExpression(nsVar)).to.be.true;
            chai_1.expect(reflection_1.isNamespacedVariableNameExpression(fun)).to.be.false;
        });
        it('isDottedGetExpression', () => {
            chai_1.expect(reflection_1.isDottedGetExpression(dottedGet)).to.be.true;
            chai_1.expect(reflection_1.isDottedGetExpression(fun)).to.be.false;
        });
        it('iisXmlAttributeGetExpressions', () => {
            chai_1.expect(reflection_1.isXmlAttributeGetExpression(xmlAttrGet)).to.be.true;
            chai_1.expect(reflection_1.isXmlAttributeGetExpression(fun)).to.be.false;
        });
        it('isIndexedGetExpression', () => {
            chai_1.expect(reflection_1.isIndexedGetExpression(indexedGet)).to.be.true;
            chai_1.expect(reflection_1.isIndexedGetExpression(fun)).to.be.false;
        });
        it('isGroupingExpression', () => {
            chai_1.expect(reflection_1.isGroupingExpression(grouping)).to.be.true;
            chai_1.expect(reflection_1.isGroupingExpression(fun)).to.be.false;
        });
        it('isLiteralExpression', () => {
            chai_1.expect(reflection_1.isLiteralExpression(literal)).to.be.true;
            chai_1.expect(reflection_1.isLiteralExpression(fun)).to.be.false;
        });
        it('isEscapedCharCodeLiteral', () => {
            chai_1.expect(reflection_1.isEscapedCharCodeLiteralExpression(escapedCarCode)).to.be.true;
            chai_1.expect(reflection_1.isEscapedCharCodeLiteralExpression(fun)).to.be.false;
        });
        it('isArrayLiteralExpression', () => {
            chai_1.expect(reflection_1.isArrayLiteralExpression(arrayLit)).to.be.true;
            chai_1.expect(reflection_1.isArrayLiteralExpression(fun)).to.be.false;
        });
        it('isAALiteralExpression', () => {
            chai_1.expect(reflection_1.isAALiteralExpression(aaLit)).to.be.true;
            chai_1.expect(reflection_1.isAALiteralExpression(fun)).to.be.false;
        });
        it('isUnaryExpression', () => {
            chai_1.expect(reflection_1.isUnaryExpression(unary)).to.be.true;
            chai_1.expect(reflection_1.isUnaryExpression(fun)).to.be.false;
        });
        it('isVariableExpression', () => {
            chai_1.expect(reflection_1.isVariableExpression(variable)).to.be.true;
            chai_1.expect(reflection_1.isVariableExpression(fun)).to.be.false;
        });
        it('isSourceLiteralExpression', () => {
            chai_1.expect(reflection_1.isSourceLiteralExpression(sourceLit)).to.be.true;
            chai_1.expect(reflection_1.isSourceLiteralExpression(fun)).to.be.false;
        });
        it('isNewExpression', () => {
            chai_1.expect(reflection_1.isNewExpression(newx)).to.be.true;
            chai_1.expect(reflection_1.isNewExpression(fun)).to.be.false;
        });
        it('isCallfuncExpression', () => {
            chai_1.expect(reflection_1.isCallfuncExpression(callfunc)).to.be.true;
            chai_1.expect(reflection_1.isCallfuncExpression(fun)).to.be.false;
        });
        it('isTemplateStringQuasiExpression', () => {
            chai_1.expect(reflection_1.isTemplateStringQuasiExpression(tplQuasi)).to.be.true;
            chai_1.expect(reflection_1.isTemplateStringQuasiExpression(fun)).to.be.false;
        });
        it('isTemplateStringExpression', () => {
            chai_1.expect(reflection_1.isTemplateStringExpression(tplString)).to.be.true;
            chai_1.expect(reflection_1.isTemplateStringExpression(fun)).to.be.false;
        });
        it('isTaggedTemplateStringExpression', () => {
            chai_1.expect(reflection_1.isTaggedTemplateStringExpression(taggedTpl)).to.be.true;
            chai_1.expect(reflection_1.isTaggedTemplateStringExpression(fun)).to.be.false;
        });
        it('isAnnotationExpression', () => {
            chai_1.expect(reflection_1.isAnnotationExpression(annotation)).to.be.true;
            chai_1.expect(reflection_1.isAnnotationExpression(fun)).to.be.false;
        });
        it('isExpression', () => {
            chai_1.expect(reflection_1.isExpression(call)).to.be.true;
            chai_1.expect(reflection_1.isExpression(new Statement_1.EmptyStatement())).to.be.false;
            //doesn't fail for invalid param types
            chai_1.expect(reflection_1.isExpression(undefined)).to.be.false;
            chai_1.expect(reflection_1.isExpression(1)).to.be.false;
        });
    });
});
//# sourceMappingURL=reflection.spec.js.map