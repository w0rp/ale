"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCall = exports.createBooleanLiteral = exports.createInvalidLiteral = exports.createFloatLiteral = exports.createIntegerLiteral = exports.createStringLiteral = exports.createDottedIdentifier = exports.createIdentifier = exports.createToken = exports.interpolatedRange = void 0;
const TokenKind_1 = require("../lexer/TokenKind");
const Expression_1 = require("../parser/Expression");
/**
 * A range that points to nowhere. Used to give non-null ranges to programmatically-added source code.
 * (Hardcoded range to prevent circular dependency issue in `../util.ts`
 */
exports.interpolatedRange = {
    start: {
        line: -1,
        character: -1
    },
    end: {
        line: -1,
        character: -1
    }
};
function createToken(kind, text, range = exports.interpolatedRange) {
    return {
        kind: kind,
        text: text || kind.toString(),
        isReserved: !text || text === kind.toString(),
        range: range,
        leadingWhitespace: ''
    };
}
exports.createToken = createToken;
function createIdentifier(ident, range, namespaceName) {
    return new Expression_1.VariableExpression(createToken(TokenKind_1.TokenKind.Identifier, ident, range), namespaceName);
}
exports.createIdentifier = createIdentifier;
function createDottedIdentifier(path, range, namespaceName) {
    const ident = path.pop();
    const obj = path.length > 1 ? createDottedIdentifier(path, range, namespaceName) : createIdentifier(path[0], range, namespaceName);
    return new Expression_1.DottedGetExpression(obj, createToken(TokenKind_1.TokenKind.Identifier, ident, range), createToken(TokenKind_1.TokenKind.Dot, '.', range));
}
exports.createDottedIdentifier = createDottedIdentifier;
function createStringLiteral(value, range) {
    return new Expression_1.LiteralExpression(createToken(TokenKind_1.TokenKind.StringLiteral, value, range));
}
exports.createStringLiteral = createStringLiteral;
function createIntegerLiteral(value, range) {
    return new Expression_1.LiteralExpression(createToken(TokenKind_1.TokenKind.IntegerLiteral, value, range));
}
exports.createIntegerLiteral = createIntegerLiteral;
function createFloatLiteral(value, range) {
    return new Expression_1.LiteralExpression(createToken(TokenKind_1.TokenKind.FloatLiteral, value, range));
}
exports.createFloatLiteral = createFloatLiteral;
function createInvalidLiteral(value, range) {
    return new Expression_1.LiteralExpression(createToken(TokenKind_1.TokenKind.Invalid, value, range));
}
exports.createInvalidLiteral = createInvalidLiteral;
function createBooleanLiteral(value, range) {
    return new Expression_1.LiteralExpression(createToken(value === 'true' ? TokenKind_1.TokenKind.True : TokenKind_1.TokenKind.False, value, range));
}
exports.createBooleanLiteral = createBooleanLiteral;
function createCall(callee, args, namespaceName) {
    return new Expression_1.CallExpression(callee, createToken(TokenKind_1.TokenKind.LeftParen, '('), createToken(TokenKind_1.TokenKind.RightParen, ')'), args || [], namespaceName);
}
exports.createCall = createCall;
//# sourceMappingURL=creators.js.map