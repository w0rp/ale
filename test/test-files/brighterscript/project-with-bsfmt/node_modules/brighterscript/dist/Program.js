"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Program = void 0;
const assert = require("assert");
const fsExtra = require("fs-extra");
const path = require("path");
const vscode_languageserver_1 = require("vscode-languageserver");
const Scope_1 = require("./Scope");
const DiagnosticMessages_1 = require("./DiagnosticMessages");
const BrsFile_1 = require("./files/BrsFile");
const XmlFile_1 = require("./files/XmlFile");
const util_1 = require("./util");
const XmlScope_1 = require("./XmlScope");
const DiagnosticFilterer_1 = require("./DiagnosticFilterer");
const DependencyGraph_1 = require("./DependencyGraph");
const Logger_1 = require("./Logger");
const chalk_1 = require("chalk");
const globalCallables_1 = require("./globalCallables");
const Manifest_1 = require("./preprocessor/Manifest");
const vscode_uri_1 = require("vscode-uri");
const PluginInterface_1 = require("./PluginInterface");
const reflection_1 = require("./astUtils/reflection");
const visitors_1 = require("./astUtils/visitors");
const startOfSourcePkgPath = `source${path.sep}`;
class Program {
    constructor(
    /**
     * The root directory for this program
     */
    options, logger, plugins) {
        this.options = options;
        /**
         * A graph of all files and their dependencies.
         * For example:
         *      File.xml -> [lib1.brs, lib2.brs]
         *      lib2.brs -> [lib3.brs] //via an import statement
         */
        this.dependencyGraph = new DependencyGraph_1.DependencyGraph();
        this.diagnosticFilterer = new DiagnosticFilterer_1.DiagnosticFilterer();
        this.util = util_1.util;
        /**
         * A list of functions that will be used to load file contents.
         * In most cases, there will only be the "read from filesystem" resolver.
         * However, when running inside the LanguageServer, a second resolver will be added
         * to resolve the opened file contents from memory instead of going to disk.
         */
        this.fileResolvers = [];
        /**
         * A set of diagnostics. This does not include any of the scope diagnostics.
         * Should only be set from `this.validate()`
         */
        this.diagnostics = [];
        /**
         * A map of every file loaded into this program, indexed by its original file location
         */
        this.files = {};
        this.pkgMap = {};
        this.scopes = {};
        /**
         * A map of every component currently loaded into the program, indexed by the component name
         */
        this.components = {};
        this.options = util_1.util.normalizeConfig(options);
        this.logger = logger || new Logger_1.Logger(options.logLevel);
        this.plugins = plugins || new PluginInterface_1.default([], undefined);
        //normalize the root dir path
        this.options.rootDir = util_1.util.getRootDir(this.options);
        this.createGlobalScope();
        //add the default file resolver (used by this program to load source file contents).
        this.fileResolvers.push(async (pathAbsolute) => {
            let contents = await this.util.getFileContents(pathAbsolute);
            return contents;
        });
    }
    createGlobalScope() {
        //create the 'global' scope
        this.globalScope = new Scope_1.Scope('global', 'scope:global', this);
        this.scopes.global = this.globalScope;
        //hardcode the files list for global scope to only contain the global file
        this.globalScope.getFiles = () => [globalCallables_1.globalFile];
        this.globalScope.validate();
        //for now, disable validation of global scope because the global files have some duplicate method declarations
        this.globalScope.getDiagnostics = () => [];
        //TODO we might need to fix this because the isValidated clears stuff now
        this.globalScope.isValidated = true;
    }
    addScope(scope) {
        this.scopes[scope.name] = scope;
        this.plugins.emit('afterScopeCreate', scope);
    }
    /**
     * Get the component with the specified name
     */
    getComponent(componentName) {
        if (componentName) {
            return this.components[componentName.toLowerCase()];
        }
    }
    /**
     * Register (or replace) the reference to a component in the component map
     */
    registerComponent(xmlFile, scope) {
        var _a;
        //store a reference to this component by its component name
        this.components[((_a = xmlFile.componentName) !== null && _a !== void 0 ? _a : xmlFile.pkgPath).toLowerCase()] = {
            file: xmlFile,
            scope: scope
        };
    }
    /**
     * Remove the specified component from the components map
     */
    unregisterComponent(xmlFile) {
        var _a;
        delete this.components[((_a = xmlFile.componentName) !== null && _a !== void 0 ? _a : xmlFile.pkgPath).toLowerCase()];
    }
    /**
     * Get the contents of the specified file as a string.
     * This walks backwards through the file resolvers until we get a value.
     * This allow the language server to provide file contents directly from memory.
     */
    async getFileContents(pathAbsolute) {
        pathAbsolute = util_1.standardizePath `${pathAbsolute}`;
        let reversedResolvers = [...this.fileResolvers].reverse();
        for (let fileResolver of reversedResolvers) {
            let result = await fileResolver(pathAbsolute);
            if (typeof result === 'string') {
                return result;
            }
        }
        throw new Error(`Could not load file "${pathAbsolute}"`);
    }
    /**
     * Get a list of all files that are included in the project but are not referenced
     * by any scope in the program.
     */
    getUnreferencedFiles() {
        let result = [];
        for (let filePath in this.files) {
            let file = this.files[filePath];
            if (!this.fileIsIncludedInAnyScope(file)) {
                //no scopes reference this file. add it to the list
                result.push(file);
            }
        }
        return result;
    }
    /**
     * Get the list of errors for the entire program. It's calculated on the fly
     * by walking through every file, so call this sparingly.
     */
    getDiagnostics() {
        let diagnostics = [...this.diagnostics];
        //get the diagnostics from all scopes
        for (let scopeName in this.scopes) {
            let scope = this.scopes[scopeName];
            diagnostics.push(...scope.getDiagnostics());
        }
        //get the diagnostics from all unreferenced files
        let unreferencedFiles = this.getUnreferencedFiles();
        for (let file of unreferencedFiles) {
            diagnostics.push(...file.getDiagnostics());
        }
        //filter out diagnostics based on our diagnostic filters
        let finalDiagnostics = this.diagnosticFilterer.filter(Object.assign(Object.assign({}, this.options), { rootDir: this.options.rootDir }), diagnostics);
        return finalDiagnostics;
    }
    addDiagnostics(diagnostics) {
        this.diagnostics.push(...diagnostics);
    }
    /**
     * Determine if the specified file is loaded in this program right now.
     * @param filePath
     */
    hasFile(filePath) {
        filePath = util_1.standardizePath `${filePath}`;
        return this.files[filePath] !== undefined;
    }
    /**
     * Add and parse all of the provided files.
     * Files that are already loaded will be replaced by the latest
     * contents from the file system.
     * @param filePaths
     */
    async addOrReplaceFiles(fileObjects) {
        let promises = [];
        for (let fileObject of fileObjects) {
            promises.push(this.addOrReplaceFile(fileObject));
        }
        return Promise.all(promises);
    }
    getPkgPath(...args) {
        throw new Error('Not implemented');
    }
    /**
     * roku filesystem is case INsensitive, so find the scope by key case insensitive
     * @param scopeName
     */
    getScopeByName(scopeName) {
        if (!scopeName) {
            return undefined;
        }
        //most scopes are xml file pkg paths. however, the ones that are not are single names like "global" and "scope",
        //so it's safe to run the standardizePkgPath method
        scopeName = util_1.standardizePath `${scopeName}`;
        let key = Object.keys(this.scopes).find(x => x.toLowerCase() === scopeName.toLowerCase());
        return this.scopes[key];
    }
    /**
     * Return all scopes
     */
    getScopes() {
        return Object.values(this.scopes);
    }
    /**
     * Find the scope for the specified component
     */
    getComponentScope(componentName) {
        var _a;
        return (_a = this.getComponent(componentName)) === null || _a === void 0 ? void 0 : _a.scope;
    }
    async addOrReplaceFile(fileParam, fileContents) {
        assert.ok(fileParam, 'fileEntry is required');
        let srcPath;
        let pkgPath;
        if (typeof fileParam === 'string') {
            srcPath = util_1.standardizePath `${this.options.rootDir}/${fileParam}`;
            pkgPath = util_1.standardizePath `${fileParam}`;
        }
        else {
            srcPath = util_1.standardizePath `${fileParam.src}`;
            pkgPath = util_1.standardizePath `${fileParam.dest}`;
        }
        let file = await this.logger.time(Logger_1.LogLevel.debug, ['Program.addOrReplaceFile()', chalk_1.default.green(srcPath)], async () => {
            assert.ok(srcPath, 'fileEntry.src is required');
            assert.ok(pkgPath, 'fileEntry.dest is required');
            //if the file is already loaded, remove it
            if (this.hasFile(srcPath)) {
                this.removeFile(srcPath);
            }
            let fileExtension = path.extname(srcPath).toLowerCase();
            let file;
            //load the file contents by file path if not provided
            let getFileContents = async () => {
                if (fileContents === undefined) {
                    return this.getFileContents(srcPath);
                }
                else {
                    return fileContents;
                }
            };
            if (fileExtension === '.brs' || fileExtension === '.bs') {
                let brsFile = new BrsFile_1.BrsFile(srcPath, pkgPath, this);
                //add file to the `source` dependency list
                if (brsFile.pkgPath.startsWith(startOfSourcePkgPath)) {
                    this.createSourceScope();
                    this.dependencyGraph.addDependency('scope:source', brsFile.dependencyGraphKey);
                }
                //add the file to the program
                this.files[srcPath] = brsFile;
                this.pkgMap[brsFile.pkgPath.toLowerCase()] = brsFile;
                let fileContents = {
                    pathAbsolute: srcPath,
                    source: await getFileContents()
                };
                this.plugins.emit('beforeFileParse', fileContents);
                this.logger.time(Logger_1.LogLevel.info, ['parse', chalk_1.default.green(srcPath)], () => {
                    brsFile.parse(fileContents.source);
                });
                file = brsFile;
                brsFile.attachDependencyGraph(this.dependencyGraph);
                this.plugins.emit('afterFileValidate', brsFile);
            }
            else if (
            //is xml file
            fileExtension === '.xml' &&
                //resides in the components folder (Roku will only parse xml files in the components folder)
                pkgPath.toLowerCase().startsWith(util_1.util.pathSepNormalize(`components/`))) {
                let xmlFile = new XmlFile_1.XmlFile(srcPath, pkgPath, this);
                //add the file to the program
                this.files[srcPath] = xmlFile;
                let fileContents = {
                    pathAbsolute: srcPath,
                    source: await getFileContents()
                };
                this.plugins.emit('beforeFileParse', fileContents);
                await xmlFile.parse(fileContents.source);
                file = xmlFile;
                //create a new scope for this xml file
                let scope = new XmlScope_1.XmlScope(xmlFile, this);
                this.addScope(scope);
                //register this compoent now that we have parsed it and know its component name
                this.registerComponent(xmlFile, scope);
                //attach the dependency graph, so the component can
                //   a) be regularly notified of changes
                //   b) immediately emit its own changes
                xmlFile.attachDependencyGraph(this.dependencyGraph);
                this.plugins.emit('afterFileValidate', xmlFile);
            }
            else {
                //TODO do we actually need to implement this? Figure out how to handle img paths
                // let genericFile = this.files[pathAbsolute] = <any>{
                //     pathAbsolute: pathAbsolute,
                //     pkgPath: pkgPath,
                //     wasProcessed: true
                // } as File;
                // file = <any>genericFile;
            }
            return file;
        });
        return file;
    }
    /**
     * Ensure source scope is created.
     * Note: automatically called internally, and no-op if it exists already.
     */
    createSourceScope() {
        if (!this.scopes.source) {
            const sourceScope = new Scope_1.Scope('source', 'scope:source', this);
            this.addScope(sourceScope);
        }
    }
    /**
     * Find the file by its absolute path. This is case INSENSITIVE, since
     * Roku is a case insensitive file system. It is an error to have multiple files
     * with the same path with only case being different.
     * @param pathAbsolute
     */
    getFileByPathAbsolute(pathAbsolute) {
        pathAbsolute = util_1.standardizePath `${pathAbsolute}`;
        for (let filePath in this.files) {
            if (filePath.toLowerCase() === pathAbsolute.toLowerCase()) {
                return this.files[filePath];
            }
        }
    }
    /**
     * Get a list of files for the given (platform-normalized) pkgPath array.
     * Missing files are just ignored.
     */
    getFilesByPkgPaths(pkgPaths) {
        return pkgPaths
            .map(pkgPath => this.getFileByPkgPath(pkgPath))
            .filter(file => file !== undefined);
    }
    /**
     * Get a file with the specified (platform-normalized) pkg path.
     * If not found, return undefined
     */
    getFileByPkgPath(pkgPath) {
        return this.pkgMap[pkgPath.toLowerCase()];
    }
    /**
     * Remove a set of files from the program
     * @param absolutePaths
     */
    removeFiles(absolutePaths) {
        for (let pathAbsolute of absolutePaths) {
            this.removeFile(pathAbsolute);
        }
    }
    /**
     * Remove a file from the program
     * @param pathAbsolute
     */
    removeFile(pathAbsolute) {
        if (!path.isAbsolute(pathAbsolute)) {
            throw new Error(`Path must be absolute: "${pathAbsolute}"`);
        }
        let file = this.getFile(pathAbsolute);
        if (file) {
            this.plugins.emit('beforeFileDispose', file);
            //if there is a scope named the same as this file's path, remove it (i.e. xml scopes)
            let scope = this.scopes[file.pkgPath];
            if (scope) {
                this.plugins.emit('beforeScopeDispose', scope);
                scope.dispose();
                //notify dependencies of this scope that it has been removed
                this.dependencyGraph.remove(scope.dependencyGraphKey);
                delete this.scopes[file.pkgPath];
                this.plugins.emit('afterScopeDispose', scope);
            }
            //remove the file from the program
            delete this.files[file.pathAbsolute];
            delete this.pkgMap[file.pkgPath.toLowerCase()];
            this.dependencyGraph.remove(file.dependencyGraphKey);
            //if this is a pkg:/source file, notify the `source` scope that it has changed
            if (file.pkgPath.startsWith(startOfSourcePkgPath)) {
                this.dependencyGraph.removeDependency('scope:source', file.dependencyGraphKey);
            }
            //if this is a component, remove it from our components map
            if (reflection_1.isXmlFile(file)) {
                this.unregisterComponent(file);
            }
            this.plugins.emit('afterFileDispose', file);
        }
    }
    /**
     * Traverse the entire project, and validate all scopes
     * @param force - if true, then all scopes are force to validate, even if they aren't marked as dirty
     */
    async validate() {
        await this.logger.time(Logger_1.LogLevel.debug, ['Program.validate()'], async () => {
            this.diagnostics = [];
            this.plugins.emit('beforeProgramValidate', this);
            for (let scopeName in this.scopes) {
                let scope = this.scopes[scopeName];
                scope.validate();
            }
            //find any files NOT loaded into a scope
            for (let filePath in this.files) {
                let file = this.files[filePath];
                if (!this.fileIsIncludedInAnyScope(file)) {
                    this.logger.debug('Program.validate(): fileNotReferenced by any scope', () => chalk_1.default.green(file === null || file === void 0 ? void 0 : file.pkgPath));
                    //the file is not loaded in any scope
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.fileNotReferencedByAnyOtherFile()), { file: file, range: util_1.util.createRange(0, 0, 0, Number.MAX_VALUE) }));
                }
            }
            this.detectDuplicateComponentNames();
            this.plugins.emit('afterProgramValidate', this);
            await Promise.resolve();
        });
    }
    /**
     * Flag all duplicate component names
     */
    detectDuplicateComponentNames() {
        const componentsByName = Object.keys(this.files).reduce((map, filePath) => {
            const file = this.files[filePath];
            //if this is an XmlFile, and it has a valid `componentName` property
            if (reflection_1.isXmlFile(file) && file.componentName) {
                let lowerName = file.componentName.toLowerCase();
                if (!map[lowerName]) {
                    map[lowerName] = [];
                }
                map[lowerName].push(file);
            }
            return map;
        }, {});
        for (let componentName in componentsByName) {
            const xmlFiles = componentsByName[componentName];
            //add diagnostics for every duplicate component with this name
            if (xmlFiles.length > 1) {
                for (let xmlFile of xmlFiles) {
                    this.diagnostics.push(Object.assign(Object.assign({}, DiagnosticMessages_1.DiagnosticMessages.duplicateComponentName(xmlFile.componentName)), { range: xmlFile.componentNameRange, file: xmlFile, relatedInformation: xmlFiles.filter(x => x !== xmlFile).map(x => {
                            return {
                                location: vscode_languageserver_1.Location.create(vscode_uri_1.URI.file(xmlFile.pathAbsolute).toString(), x.componentNameRange),
                                message: 'Also defined here'
                            };
                        }) }));
                }
            }
        }
    }
    /**
     * Determine if the given file is included in at least one scope in this program
     */
    fileIsIncludedInAnyScope(file) {
        for (let scopeName in this.scopes) {
            if (this.scopes[scopeName].hasFile(file)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get the file at the given path
     * @param pathAbsolute
     */
    getFile(pathAbsolute) {
        pathAbsolute = util_1.standardizePath `${pathAbsolute}`;
        return this.files[pathAbsolute];
    }
    /**
     * Get a list of all scopes the file is loaded into
     * @param file
     */
    getScopesForFile(file) {
        let result = [];
        for (let key in this.scopes) {
            let scope = this.scopes[key];
            if (scope.hasFile(file)) {
                result.push(scope);
            }
        }
        return result;
    }
    /**
     * Find all available completion items at the given position
     * @param pathAbsolute
     * @param lineIndex
     * @param columnIndex
     */
    async getCompletions(pathAbsolute, position) {
        let file = this.getFile(pathAbsolute);
        if (!file) {
            return [];
        }
        //wait for the file to finish loading
        await file.isReady();
        //find the scopes for this file
        let scopes = this.getScopesForFile(file);
        //if there are no scopes, include the global scope so we at least get the built-in functions
        scopes = scopes.length > 0 ? scopes : [this.globalScope];
        //get the completions for this file for every scope
        //get the completions from all scopes for this file
        let allCompletions = util_1.util.flatMap(await Promise.all(scopes.map(async (ctx) => file.getCompletions(position, ctx))), c => c);
        let result = [];
        //only keep completions common to every scope for this file
        let keyCounts = {};
        for (let completion of allCompletions) {
            let key = `${completion.label}-${completion.kind}`;
            keyCounts[key] = keyCounts[key] ? keyCounts[key] + 1 : 1;
            if (keyCounts[key] === scopes.length) {
                result.push(completion);
            }
        }
        return result;
    }
    /**
     * Goes through each file and builds a list of workspace symbols for the program. Used by LanguageServer's onWorkspaceSymbol functionality
     */
    async getWorkspaceSymbols() {
        const results = await Promise.all(Object.keys(this.files).map(async (key) => {
            const file = this.files[key];
            if (reflection_1.isBrsFile(file)) {
                return file.getWorkspaceSymbols();
            }
            return [];
        }));
        const allSymbols = util_1.util.flatMap(results, c => c);
        return allSymbols;
    }
    /**
     * Given a position in a file, if the position is sitting on some type of identifier,
     * go to the definition of that identifier (where this thing was first defined)
     */
    getDefinition(pathAbsolute, position) {
        let file = this.getFile(pathAbsolute);
        if (!file) {
            return [];
        }
        if (reflection_1.isBrsFile(file)) {
            return file.getDefinition(position);
        }
        else {
            let results = [];
            const scopes = this.getScopesForFile(file);
            for (const scope of scopes) {
                results = results.concat(...scope.getDefinition(file, position));
            }
            return results;
        }
    }
    getHover(pathAbsolute, position) {
        //find the file
        let file = this.getFile(pathAbsolute);
        if (!file) {
            return null;
        }
        return file.getHover(position);
    }
    async getSignatureHelp(callSitePathAbsolute, callableName) {
        const results = [];
        callableName = callableName.toLowerCase();
        //find the file
        let file = this.getFile(callSitePathAbsolute);
        if (!file) {
            return results;
        }
        const scopes = this.getScopesForFile(file);
        for (const scope of scopes) {
            for (const file of scope.getFiles()) {
                if (reflection_1.isXmlFile(file)) {
                    continue;
                }
                await file.isReady();
                const statementHandler = (statement) => {
                    if (statement.getName(file.getParseMode()).toLowerCase() === callableName) {
                        results.push(file.getSignatureHelp(statement));
                    }
                };
                file.parser.ast.walk(visitors_1.createVisitor({
                    FunctionStatement: statementHandler,
                    ClassMethodStatement: statementHandler
                }), {
                    walkMode: visitors_1.WalkMode.visitStatements
                });
            }
        }
        return results;
    }
    getReferences(pathAbsolute, position) {
        //find the file
        let file = this.getFile(pathAbsolute);
        if (!file) {
            return null;
        }
        return file.getReferences(position);
    }
    /**
     * Get a list of all script imports, relative to the specified pkgPath
     * @param sourcePkgPath - the pkgPath of the source that wants to resolve script imports.
     */
    getScriptImportCompletions(sourcePkgPath, scriptImport) {
        let lowerSourcePkgPath = sourcePkgPath.toLowerCase();
        let result = [];
        /**
         * hashtable to prevent duplicate results
         */
        let resultPkgPaths = {};
        //restrict to only .brs files
        for (let key in this.files) {
            let file = this.files[key];
            if (
            //is a BrightScript or BrighterScript file
            (file.extension === '.bs' || file.extension === '.brs') &&
                //this file is not the current file
                lowerSourcePkgPath !== file.pkgPath.toLowerCase()) {
                //add the relative path
                let relativePath = util_1.util.getRelativePath(sourcePkgPath, file.pkgPath).replace(/\\/g, '/');
                let pkgPathStandardized = file.pkgPath.replace(/\\/g, '/');
                let filePkgPath = `pkg:/${pkgPathStandardized}`;
                let lowerFilePkgPath = filePkgPath.toLowerCase();
                if (!resultPkgPaths[lowerFilePkgPath]) {
                    resultPkgPaths[lowerFilePkgPath] = true;
                    result.push({
                        label: relativePath,
                        detail: file.pathAbsolute,
                        kind: vscode_languageserver_1.CompletionItemKind.File,
                        textEdit: {
                            newText: relativePath,
                            range: scriptImport.filePathRange
                        }
                    });
                    //add the absolute path
                    result.push({
                        label: filePkgPath,
                        detail: file.pathAbsolute,
                        kind: vscode_languageserver_1.CompletionItemKind.File,
                        textEdit: {
                            newText: filePkgPath,
                            range: scriptImport.filePathRange
                        }
                    });
                }
            }
        }
        return result;
    }
    /**
     * Transpile a single file and get the result as a string.
     * This does not write anything to the file system.
     */
    async getTranspiledFileContents(pathAbsolute) {
        let file = this.getFile(pathAbsolute);
        //wait for the file to finish being parsed
        await file.isReady();
        let result = file.transpile();
        return Object.assign(Object.assign({}, result), { pathAbsolute: file.pathAbsolute, pkgPath: file.pkgPath });
    }
    async transpile(fileEntries, stagingFolderPath) {
        const entries = Object.values(this.files).map(file => {
            let filePathObj = fileEntries.find(x => util_1.standardizePath `${x.src}` === util_1.standardizePath `${file.pathAbsolute}`);
            if (!filePathObj) {
                //this file has been added in-memory, from a plugin, for example
                filePathObj = {
                    //add an interpolated src path (since it doesn't actually exist in memory)
                    src: `bsc:/${file.pkgPath}`,
                    dest: file.pkgPath
                };
            }
            //replace the file extension
            let outputPath = filePathObj.dest.replace(/\.bs$/gi, '.brs');
            //prepend the staging folder path
            outputPath = util_1.standardizePath `${stagingFolderPath}/${outputPath}`;
            return {
                file: file,
                outputPath: outputPath
            };
        });
        this.plugins.emit('beforeProgramTranspile', this, entries);
        const promises = entries.map(async (entry) => {
            //skip transpiling typedef files
            if (reflection_1.isBrsFile(entry.file) && entry.file.isTypedef) {
                return;
            }
            this.plugins.emit('beforeFileTranspile', entry);
            const { file, outputPath } = entry;
            const result = file.transpile();
            //make sure the full dir path exists
            await fsExtra.ensureDir(path.dirname(outputPath));
            if (await fsExtra.pathExists(outputPath)) {
                throw new Error(`Error while transpiling "${file.pathAbsolute}". A file already exists at "${outputPath}" and will not be overwritten.`);
            }
            const writeMapPromise = result.map ? fsExtra.writeFile(`${outputPath}.map`, result.map.toString()) : null;
            await Promise.all([
                fsExtra.writeFile(outputPath, result.code),
                writeMapPromise
            ]);
            if (reflection_1.isBrsFile(file) && this.options.emitDefinitions) {
                const typedef = file.getTypedef();
                const typedefPath = outputPath.replace(/\.brs$/i, '.d.bs');
                await fsExtra.writeFile(typedefPath, typedef);
            }
            this.plugins.emit('afterFileTranspile', entry);
        });
        //copy the brighterscript stdlib to the output directory
        promises.push(fsExtra.ensureDir(util_1.standardizePath `${stagingFolderPath}/source`).then(() => {
            return fsExtra.copyFile(util_1.standardizePath `${__dirname}/../bslib.brs`, util_1.standardizePath `${stagingFolderPath}/source/bslib.brs`);
        }));
        await Promise.all(promises);
        this.plugins.emit('afterProgramTranspile', this, entries);
    }
    /**
     * Get a map of the manifest information
     */
    getManifest() {
        if (!this._manifest) {
            //load the manifest file.
            //TODO update this to get the manifest from the files array or require it in the options...we shouldn't assume the location of the manifest
            let manifestPath = path.join(this.options.rootDir, 'manifest');
            let contents;
            try {
                //we only load this manifest once, so do it sync to improve speed downstream
                contents = fsExtra.readFileSync(manifestPath, 'utf-8');
                this._manifest = Manifest_1.parseManifest(contents);
            }
            catch (err) {
                this._manifest = new Map();
            }
        }
        return this._manifest;
    }
    dispose() {
        for (let filePath in this.files) {
            this.files[filePath].dispose();
        }
        for (let name in this.scopes) {
            this.scopes[name].dispose();
        }
        this.globalScope.dispose();
        this.dependencyGraph.dispose();
    }
}
exports.Program = Program;
//# sourceMappingURL=Program.js.map